
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_start>:
#include <syscalls/z_errno_mrsh.c>

#else
int *z_impl_z_errno(void)
{
	return &_current->errno_var;
   0:	200011a0 	.word	0x200011a0
}
   4:	00002961 	.word	0x00002961
   8:	0000690b 	.word	0x0000690b
   c:	000029b5 	.word	0x000029b5
  10:	000029b5 	.word	0x000029b5
  14:	000029b5 	.word	0x000029b5
  18:	000029b5 	.word	0x000029b5
	...
  2c:	000026b5 	.word	0x000026b5
  30:	000029b5 	.word	0x000029b5
  34:	00000000 	.word	0x00000000
  38:	0000265d 	.word	0x0000265d
  3c:	00006843 	.word	0x00006843

00000040 <_irq_vector_table>:
  40:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  50:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  60:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  70:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  80:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  90:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  a0:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  b0:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  c0:	00002921 00002921 00002921 00002921     !)..!)..!)..!)..
  d0:	00002921 00002921 00002921              !)..!)..!)..

Disassembly of section text:

000000dc <__aeabi_uldivmod>:
      dc:	b953      	cbnz	r3, f4 <__aeabi_uldivmod+0x18>
      de:	b94a      	cbnz	r2, f4 <__aeabi_uldivmod+0x18>
      e0:	2900      	cmp	r1, #0
      e2:	bf08      	it	eq
      e4:	2800      	cmpeq	r0, #0
      e6:	bf1c      	itt	ne
      e8:	f04f 31ff 	movne.w	r1, #4294967295
      ec:	f04f 30ff 	movne.w	r0, #4294967295
      f0:	f000 b96c 	b.w	3cc <__aeabi_idiv0>
      f4:	f1ad 0c08 	sub.w	ip, sp, #8
      f8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
      fc:	f000 f806 	bl	10c <__udivmoddi4>
     100:	f8dd e004 	ldr.w	lr, [sp, #4]
     104:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     108:	b004      	add	sp, #16
     10a:	4770      	bx	lr

0000010c <__udivmoddi4>:
     10c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     110:	9e08      	ldr	r6, [sp, #32]
     112:	460d      	mov	r5, r1
     114:	4604      	mov	r4, r0
     116:	468e      	mov	lr, r1
     118:	2b00      	cmp	r3, #0
     11a:	f040 8082 	bne.w	222 <CONFIG_FLASH_SIZE+0x22>
     11e:	428a      	cmp	r2, r1
     120:	4617      	mov	r7, r2
     122:	d946      	bls.n	1b2 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x68>
     124:	fab2 f282 	clz	r2, r2
     128:	b14a      	cbz	r2, 13e <__udivmoddi4+0x32>
     12a:	f1c2 0120 	rsb	r1, r2, #32
     12e:	fa05 f302 	lsl.w	r3, r5, r2
     132:	fa20 f101 	lsr.w	r1, r0, r1
     136:	4097      	lsls	r7, r2
     138:	ea41 0e03 	orr.w	lr, r1, r3
     13c:	4094      	lsls	r4, r2
     13e:	ea4f 4817 	mov.w	r8, r7, lsr #16
     142:	0c23      	lsrs	r3, r4, #16
     144:	fbbe fcf8 	udiv	ip, lr, r8
     148:	b2b9      	uxth	r1, r7
     14a:	fb08 ee1c 	mls	lr, r8, ip, lr
     14e:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
     152:	fb0c f001 	mul.w	r0, ip, r1
     156:	4298      	cmp	r0, r3
     158:	d90a      	bls.n	170 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x26>
     15a:	18fb      	adds	r3, r7, r3
     15c:	f10c 35ff 	add.w	r5, ip, #4294967295
     160:	f080 8116 	bcs.w	390 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x90>
     164:	4298      	cmp	r0, r3
     166:	f240 8113 	bls.w	390 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x90>
     16a:	f1ac 0c02 	sub.w	ip, ip, #2
     16e:	443b      	add	r3, r7
     170:	1a1b      	subs	r3, r3, r0
     172:	b2a4      	uxth	r4, r4
     174:	fbb3 f0f8 	udiv	r0, r3, r8
     178:	fb08 3310 	mls	r3, r8, r0, r3
     17c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     180:	fb00 f101 	mul.w	r1, r0, r1
     184:	42a1      	cmp	r1, r4
     186:	d909      	bls.n	19c <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x52>
     188:	193c      	adds	r4, r7, r4
     18a:	f100 33ff 	add.w	r3, r0, #4294967295
     18e:	f080 8101 	bcs.w	394 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x94>
     192:	42a1      	cmp	r1, r4
     194:	f240 80fe 	bls.w	394 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x94>
     198:	3802      	subs	r0, #2
     19a:	443c      	add	r4, r7
     19c:	1a64      	subs	r4, r4, r1
     19e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     1a2:	2100      	movs	r1, #0
     1a4:	b11e      	cbz	r6, 1ae <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x64>
     1a6:	40d4      	lsrs	r4, r2
     1a8:	2300      	movs	r3, #0
     1aa:	e9c6 4300 	strd	r4, r3, [r6]
     1ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     1b2:	b902      	cbnz	r2, 1b6 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x6c>
     1b4:	deff      	udf	#255	; 0xff
     1b6:	fab2 f282 	clz	r2, r2
     1ba:	2a00      	cmp	r2, #0
     1bc:	d14f      	bne.n	25e <CONFIG_FLASH_SIZE+0x5e>
     1be:	1bcb      	subs	r3, r1, r7
     1c0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     1c4:	fa1f f887 	uxth.w	r8, r7
     1c8:	2101      	movs	r1, #1
     1ca:	fbb3 fcfe 	udiv	ip, r3, lr
     1ce:	0c25      	lsrs	r5, r4, #16
     1d0:	fb0e 331c 	mls	r3, lr, ip, r3
     1d4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     1d8:	fb08 f30c 	mul.w	r3, r8, ip
     1dc:	42ab      	cmp	r3, r5
     1de:	d907      	bls.n	1f0 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0xa6>
     1e0:	197d      	adds	r5, r7, r5
     1e2:	f10c 30ff 	add.w	r0, ip, #4294967295
     1e6:	d202      	bcs.n	1ee <CONFIG_NRF52_ANOMALY_132_DELAY_US+0xa4>
     1e8:	42ab      	cmp	r3, r5
     1ea:	f200 80e7 	bhi.w	3bc <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xbc>
     1ee:	4684      	mov	ip, r0
     1f0:	1aed      	subs	r5, r5, r3
     1f2:	b2a3      	uxth	r3, r4
     1f4:	fbb5 f0fe 	udiv	r0, r5, lr
     1f8:	fb0e 5510 	mls	r5, lr, r0, r5
     1fc:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
     200:	fb08 f800 	mul.w	r8, r8, r0
     204:	45a0      	cmp	r8, r4
     206:	d907      	bls.n	218 <CONFIG_FLASH_SIZE+0x18>
     208:	193c      	adds	r4, r7, r4
     20a:	f100 33ff 	add.w	r3, r0, #4294967295
     20e:	d202      	bcs.n	216 <CONFIG_FLASH_SIZE+0x16>
     210:	45a0      	cmp	r8, r4
     212:	f200 80d7 	bhi.w	3c4 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xc4>
     216:	4618      	mov	r0, r3
     218:	eba4 0408 	sub.w	r4, r4, r8
     21c:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
     220:	e7c0      	b.n	1a4 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x5a>
     222:	428b      	cmp	r3, r1
     224:	d908      	bls.n	238 <CONFIG_FLASH_SIZE+0x38>
     226:	2e00      	cmp	r6, #0
     228:	f000 80af 	beq.w	38a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x8a>
     22c:	2100      	movs	r1, #0
     22e:	e9c6 0500 	strd	r0, r5, [r6]
     232:	4608      	mov	r0, r1
     234:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     238:	fab3 f183 	clz	r1, r3
     23c:	2900      	cmp	r1, #0
     23e:	d14b      	bne.n	2d8 <CONFIG_FLASH_SIZE+0xd8>
     240:	42ab      	cmp	r3, r5
     242:	d302      	bcc.n	24a <CONFIG_FLASH_SIZE+0x4a>
     244:	4282      	cmp	r2, r0
     246:	f200 80b7 	bhi.w	3b8 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb8>
     24a:	1a84      	subs	r4, r0, r2
     24c:	eb65 0303 	sbc.w	r3, r5, r3
     250:	2001      	movs	r0, #1
     252:	469e      	mov	lr, r3
     254:	2e00      	cmp	r6, #0
     256:	d0aa      	beq.n	1ae <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x64>
     258:	e9c6 4e00 	strd	r4, lr, [r6]
     25c:	e7a7      	b.n	1ae <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x64>
     25e:	f1c2 0c20 	rsb	ip, r2, #32
     262:	fa01 f302 	lsl.w	r3, r1, r2
     266:	4097      	lsls	r7, r2
     268:	fa20 f00c 	lsr.w	r0, r0, ip
     26c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     270:	fa21 fc0c 	lsr.w	ip, r1, ip
     274:	4318      	orrs	r0, r3
     276:	fbbc f1fe 	udiv	r1, ip, lr
     27a:	0c05      	lsrs	r5, r0, #16
     27c:	fb0e cc11 	mls	ip, lr, r1, ip
     280:	fa1f f887 	uxth.w	r8, r7
     284:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
     288:	fb01 f308 	mul.w	r3, r1, r8
     28c:	42ab      	cmp	r3, r5
     28e:	fa04 f402 	lsl.w	r4, r4, r2
     292:	d909      	bls.n	2a8 <CONFIG_FLASH_SIZE+0xa8>
     294:	197d      	adds	r5, r7, r5
     296:	f101 3cff 	add.w	ip, r1, #4294967295
     29a:	f080 808b 	bcs.w	3b4 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb4>
     29e:	42ab      	cmp	r3, r5
     2a0:	f240 8088 	bls.w	3b4 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb4>
     2a4:	3902      	subs	r1, #2
     2a6:	443d      	add	r5, r7
     2a8:	1aeb      	subs	r3, r5, r3
     2aa:	b285      	uxth	r5, r0
     2ac:	fbb3 f0fe 	udiv	r0, r3, lr
     2b0:	fb0e 3310 	mls	r3, lr, r0, r3
     2b4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
     2b8:	fb00 f308 	mul.w	r3, r0, r8
     2bc:	42ab      	cmp	r3, r5
     2be:	d907      	bls.n	2d0 <CONFIG_FLASH_SIZE+0xd0>
     2c0:	197d      	adds	r5, r7, r5
     2c2:	f100 3cff 	add.w	ip, r0, #4294967295
     2c6:	d271      	bcs.n	3ac <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xac>
     2c8:	42ab      	cmp	r3, r5
     2ca:	d96f      	bls.n	3ac <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xac>
     2cc:	3802      	subs	r0, #2
     2ce:	443d      	add	r5, r7
     2d0:	1aeb      	subs	r3, r5, r3
     2d2:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
     2d6:	e778      	b.n	1ca <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x80>
     2d8:	f1c1 0c20 	rsb	ip, r1, #32
     2dc:	408b      	lsls	r3, r1
     2de:	fa22 f70c 	lsr.w	r7, r2, ip
     2e2:	431f      	orrs	r7, r3
     2e4:	fa20 f40c 	lsr.w	r4, r0, ip
     2e8:	fa05 f301 	lsl.w	r3, r5, r1
     2ec:	ea4f 4e17 	mov.w	lr, r7, lsr #16
     2f0:	fa25 f50c 	lsr.w	r5, r5, ip
     2f4:	431c      	orrs	r4, r3
     2f6:	0c23      	lsrs	r3, r4, #16
     2f8:	fbb5 f9fe 	udiv	r9, r5, lr
     2fc:	fa1f f887 	uxth.w	r8, r7
     300:	fb0e 5519 	mls	r5, lr, r9, r5
     304:	ea43 4505 	orr.w	r5, r3, r5, lsl #16
     308:	fb09 fa08 	mul.w	sl, r9, r8
     30c:	45aa      	cmp	sl, r5
     30e:	fa02 f201 	lsl.w	r2, r2, r1
     312:	fa00 f301 	lsl.w	r3, r0, r1
     316:	d908      	bls.n	32a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x2a>
     318:	197d      	adds	r5, r7, r5
     31a:	f109 30ff 	add.w	r0, r9, #4294967295
     31e:	d247      	bcs.n	3b0 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb0>
     320:	45aa      	cmp	sl, r5
     322:	d945      	bls.n	3b0 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xb0>
     324:	f1a9 0902 	sub.w	r9, r9, #2
     328:	443d      	add	r5, r7
     32a:	eba5 050a 	sub.w	r5, r5, sl
     32e:	b2a4      	uxth	r4, r4
     330:	fbb5 f0fe 	udiv	r0, r5, lr
     334:	fb0e 5510 	mls	r5, lr, r0, r5
     338:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
     33c:	fb00 f808 	mul.w	r8, r0, r8
     340:	45a0      	cmp	r8, r4
     342:	d907      	bls.n	354 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x54>
     344:	193c      	adds	r4, r7, r4
     346:	f100 35ff 	add.w	r5, r0, #4294967295
     34a:	d22d      	bcs.n	3a8 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xa8>
     34c:	45a0      	cmp	r8, r4
     34e:	d92b      	bls.n	3a8 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0xa8>
     350:	3802      	subs	r0, #2
     352:	443c      	add	r4, r7
     354:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
     358:	eba4 0408 	sub.w	r4, r4, r8
     35c:	fba0 8902 	umull	r8, r9, r0, r2
     360:	454c      	cmp	r4, r9
     362:	46c6      	mov	lr, r8
     364:	464d      	mov	r5, r9
     366:	d319      	bcc.n	39c <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x9c>
     368:	d016      	beq.n	398 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x98>
     36a:	b15e      	cbz	r6, 384 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x84>
     36c:	ebb3 020e 	subs.w	r2, r3, lr
     370:	eb64 0405 	sbc.w	r4, r4, r5
     374:	fa04 fc0c 	lsl.w	ip, r4, ip
     378:	40ca      	lsrs	r2, r1
     37a:	ea4c 0202 	orr.w	r2, ip, r2
     37e:	40cc      	lsrs	r4, r1
     380:	e9c6 2400 	strd	r2, r4, [r6]
     384:	2100      	movs	r1, #0
     386:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     38a:	4631      	mov	r1, r6
     38c:	4630      	mov	r0, r6
     38e:	e70e      	b.n	1ae <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x64>
     390:	46ac      	mov	ip, r5
     392:	e6ed      	b.n	170 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x26>
     394:	4618      	mov	r0, r3
     396:	e701      	b.n	19c <CONFIG_NRF52_ANOMALY_132_DELAY_US+0x52>
     398:	4543      	cmp	r3, r8
     39a:	d2e6      	bcs.n	36a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x6a>
     39c:	ebb8 0e02 	subs.w	lr, r8, r2
     3a0:	eb69 0507 	sbc.w	r5, r9, r7
     3a4:	3801      	subs	r0, #1
     3a6:	e7e0      	b.n	36a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x6a>
     3a8:	4628      	mov	r0, r5
     3aa:	e7d3      	b.n	354 <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x54>
     3ac:	4660      	mov	r0, ip
     3ae:	e78f      	b.n	2d0 <CONFIG_FLASH_SIZE+0xd0>
     3b0:	4681      	mov	r9, r0
     3b2:	e7ba      	b.n	32a <CONFIG_LOG_PROCESS_THREAD_STACK_SIZE+0x2a>
     3b4:	4661      	mov	r1, ip
     3b6:	e777      	b.n	2a8 <CONFIG_FLASH_SIZE+0xa8>
     3b8:	4608      	mov	r0, r1
     3ba:	e74b      	b.n	254 <CONFIG_FLASH_SIZE+0x54>
     3bc:	f1ac 0c02 	sub.w	ip, ip, #2
     3c0:	443d      	add	r5, r7
     3c2:	e715      	b.n	1f0 <CONFIG_NRF52_ANOMALY_132_DELAY_US+0xa6>
     3c4:	3802      	subs	r0, #2
     3c6:	443c      	add	r4, r7
     3c8:	e726      	b.n	218 <CONFIG_FLASH_SIZE+0x18>
     3ca:	bf00      	nop

000003cc <__aeabi_idiv0>:
     3cc:	4770      	bx	lr
     3ce:	bf00      	nop

000003d0 <button1_work_handler>:
		printk("Button2 work is already in queue\n");
	}
}

void button1_work_handler(struct k_work *work)
{
     3d0:	b508      	push	{r3, lr}
	gpio_pin_toggle(my_gpio_port,LED1_PIN);
     3d2:	4b04      	ldr	r3, [pc, #16]	; (3e4 <button1_work_handler+0x14>)
     3d4:	6818      	ldr	r0, [r3, #0]
				    gpio_port_pins_t pins);

static inline int z_impl_gpio_port_toggle_bits(const struct device *port,
					       gpio_port_pins_t pins)
{
	const struct gpio_driver_api *api =
     3d6:	6883      	ldr	r3, [r0, #8]
		(const struct gpio_driver_api *)port->api;

	return api->port_toggle_bits(port, pins);
     3d8:	695b      	ldr	r3, [r3, #20]
     3da:	f44f 3100 	mov.w	r1, #131072	; 0x20000
     3de:	4798      	blx	r3
	// k_msleep(SLEEP_TIME_MS);
}
     3e0:	bd08      	pop	{r3, pc}
     3e2:	bf00      	nop
     3e4:	200003b0 	.word	0x200003b0

000003e8 <button2_work_handler>:

void button2_work_handler(struct k_work *work)
{
     3e8:	b508      	push	{r3, lr}
	gpio_pin_toggle(my_gpio_port,LED2_PIN);
     3ea:	4b04      	ldr	r3, [pc, #16]	; (3fc <CONFIG_LOG_PROCESS_THREAD_SLEEP_MS+0x14>)
     3ec:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_api *api =
     3ee:	6883      	ldr	r3, [r0, #8]
	return api->port_toggle_bits(port, pins);
     3f0:	695b      	ldr	r3, [r3, #20]
     3f2:	f44f 2180 	mov.w	r1, #262144	; 0x40000
     3f6:	4798      	blx	r3
	// k_msleep(SLEEP_TIME_MS);
}
     3f8:	bd08      	pop	{r3, pc}
     3fa:	bf00      	nop
     3fc:	200003b0 	.word	0x200003b0

00000400 <button1_pressed>:
{
     400:	b508      	push	{r3, lr}
	printk("Button1 work is pressed\n");
     402:	4806      	ldr	r0, [pc, #24]	; (41c <CONFIG_LOG_BUFFER_SIZE+0x1c>)
     404:	f005 fbdc 	bl	5bc0 <printk>
	ret = k_work_submit(&button1_work);
     408:	4805      	ldr	r0, [pc, #20]	; (420 <CONFIG_LOG_BUFFER_SIZE+0x20>)
     40a:	f004 fcf7 	bl	4dfc <k_work_submit>
	if(ret == 0)
     40e:	b100      	cbz	r0, 412 <button1_pressed+0x12>
}
     410:	bd08      	pop	{r3, pc}
		printk("Button1 work is already in queue\n");
     412:	4804      	ldr	r0, [pc, #16]	; (424 <CONFIG_LOG_BUFFER_SIZE+0x24>)
     414:	f005 fbd4 	bl	5bc0 <printk>
}
     418:	e7fa      	b.n	410 <button1_pressed+0x10>
     41a:	bf00      	nop
     41c:	00007aa8 	.word	0x00007aa8
     420:	20000384 	.word	0x20000384
     424:	00007ac4 	.word	0x00007ac4

00000428 <button2_pressed>:
{
     428:	b508      	push	{r3, lr}
	printk("Button2 work is pressed\n");
     42a:	4806      	ldr	r0, [pc, #24]	; (444 <button2_pressed+0x1c>)
     42c:	f005 fbc8 	bl	5bc0 <printk>
	ret = k_work_submit(&button2_work);
     430:	4805      	ldr	r0, [pc, #20]	; (448 <button2_pressed+0x20>)
     432:	f004 fce3 	bl	4dfc <k_work_submit>
		if(ret == 0)
     436:	b100      	cbz	r0, 43a <button2_pressed+0x12>
}
     438:	bd08      	pop	{r3, pc}
		printk("Button2 work is already in queue\n");
     43a:	4804      	ldr	r0, [pc, #16]	; (44c <button2_pressed+0x24>)
     43c:	f005 fbc0 	bl	5bc0 <printk>
}
     440:	e7fa      	b.n	438 <button2_pressed+0x10>
     442:	bf00      	nop
     444:	00007ae8 	.word	0x00007ae8
     448:	200003a0 	.word	0x200003a0
     44c:	00007b04 	.word	0x00007b04

00000450 <configure_gpios>:


void configure_gpios()
{
     450:	b510      	push	{r4, lr}
		/* coverity[OVERRUN] */
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     452:	4840      	ldr	r0, [pc, #256]	; (554 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x6c>)
     454:	f003 ff82 	bl	435c <z_impl_device_get_binding>
	int ret;

	my_gpio_port = device_get_binding(GPIO_PORT);
     458:	4c3f      	ldr	r4, [pc, #252]	; (558 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x70>)
     45a:	6020      	str	r0, [r4, #0]
	const struct gpio_driver_api *api =
     45c:	6881      	ldr	r1, [r0, #8]
	struct gpio_driver_data *data =
     45e:	6902      	ldr	r2, [r0, #16]
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
     460:	6813      	ldr	r3, [r2, #0]
     462:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
     466:	6013      	str	r3, [r2, #0]
	return api->pin_configure(port, pin, flags);
     468:	680b      	ldr	r3, [r1, #0]
     46a:	f44f 7288 	mov.w	r2, #272	; 0x110
     46e:	210d      	movs	r1, #13
     470:	4798      	blx	r3

	gpio_pin_configure(my_gpio_port,BUTTON1_PIN , GPIO_INPUT | GPIO_PULL_UP);
	gpio_pin_configure(my_gpio_port,BUTTON2_PIN , GPIO_INPUT | GPIO_PULL_UP);
     472:	6820      	ldr	r0, [r4, #0]
	const struct gpio_driver_api *api =
     474:	6881      	ldr	r1, [r0, #8]
	struct gpio_driver_data *data =
     476:	6902      	ldr	r2, [r0, #16]
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
     478:	6813      	ldr	r3, [r2, #0]
     47a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
     47e:	6013      	str	r3, [r2, #0]
	return api->pin_configure(port, pin, flags);
     480:	680b      	ldr	r3, [r1, #0]
     482:	f44f 7288 	mov.w	r2, #272	; 0x110
     486:	210e      	movs	r1, #14
     488:	4798      	blx	r3

	gpio_pin_configure(my_gpio_port, LED1_PIN , GPIO_OUTPUT | GPIO_OUTPUT_ACTIVE);
     48a:	6820      	ldr	r0, [r4, #0]
	const struct gpio_driver_api *api =
     48c:	6881      	ldr	r1, [r0, #8]
	struct gpio_driver_data *data =
     48e:	6902      	ldr	r2, [r0, #16]
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
     490:	6813      	ldr	r3, [r2, #0]
     492:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
     496:	6013      	str	r3, [r2, #0]
	return api->pin_configure(port, pin, flags);
     498:	680b      	ldr	r3, [r1, #0]
     49a:	f44f 6220 	mov.w	r2, #2560	; 0xa00
     49e:	2111      	movs	r1, #17
     4a0:	4798      	blx	r3
	gpio_pin_configure(my_gpio_port, LED2_PIN , GPIO_OUTPUT | GPIO_OUTPUT_ACTIVE);
     4a2:	6820      	ldr	r0, [r4, #0]
	const struct gpio_driver_api *api =
     4a4:	6881      	ldr	r1, [r0, #8]
	struct gpio_driver_data *data =
     4a6:	6902      	ldr	r2, [r0, #16]
		data->invert &= ~(gpio_port_pins_t)BIT(pin);
     4a8:	6813      	ldr	r3, [r2, #0]
     4aa:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
     4ae:	6013      	str	r3, [r2, #0]
	return api->pin_configure(port, pin, flags);
     4b0:	680b      	ldr	r3, [r1, #0]
     4b2:	f44f 6220 	mov.w	r2, #2560	; 0xa00
     4b6:	2112      	movs	r1, #18
     4b8:	4798      	blx	r3
				      gpio_port_pins_t pin_mask)
{
	__ASSERT(callback, "Callback pointer should not be NULL");
	__ASSERT(handler, "Callback handler pointer should not be NULL");

	callback->handler = handler;
     4ba:	4b28      	ldr	r3, [pc, #160]	; (55c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x74>)
     4bc:	4a28      	ldr	r2, [pc, #160]	; (560 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x78>)
     4be:	605a      	str	r2, [r3, #4]
	callback->pin_mask = pin_mask;
     4c0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
     4c4:	609a      	str	r2, [r3, #8]

	gpio_init_callback(&button1_cb_data, button1_pressed, BIT(BUTTON1_PIN));
	gpio_add_callback(my_gpio_port, &button1_cb_data);
     4c6:	6820      	ldr	r0, [r4, #0]
 * Note: enables to add as many callback as needed on the same port.
 */
static inline int gpio_add_callback(const struct device *port,
				    struct gpio_callback *callback)
{
	const struct gpio_driver_api *api =
     4c8:	6883      	ldr	r3, [r0, #8]
		(const struct gpio_driver_api *)port->api;

	if (api->manage_callback == NULL) {
     4ca:	69db      	ldr	r3, [r3, #28]
     4cc:	b113      	cbz	r3, 4d4 <configure_gpios+0x84>
		return -ENOTSUP;
	}

	return api->manage_callback(port, callback, true);
     4ce:	2201      	movs	r2, #1
     4d0:	4922      	ldr	r1, [pc, #136]	; (55c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x74>)
     4d2:	4798      	blx	r3
	callback->handler = handler;
     4d4:	4b23      	ldr	r3, [pc, #140]	; (564 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x7c>)
     4d6:	4a24      	ldr	r2, [pc, #144]	; (568 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x80>)
     4d8:	605a      	str	r2, [r3, #4]
	callback->pin_mask = pin_mask;
     4da:	f44f 4280 	mov.w	r2, #16384	; 0x4000
     4de:	609a      	str	r2, [r3, #8]
	gpio_init_callback(&button2_cb_data, button2_pressed, BIT(BUTTON2_PIN));
	gpio_add_callback(my_gpio_port, &button2_cb_data);
     4e0:	4b1d      	ldr	r3, [pc, #116]	; (558 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x70>)
     4e2:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_api *api =
     4e4:	6883      	ldr	r3, [r0, #8]
	if (api->manage_callback == NULL) {
     4e6:	69db      	ldr	r3, [r3, #28]
     4e8:	b113      	cbz	r3, 4f0 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x8>
	return api->manage_callback(port, callback, true);
     4ea:	2201      	movs	r2, #1
     4ec:	491d      	ldr	r1, [pc, #116]	; (564 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x7c>)
     4ee:	4798      	blx	r3

	gpio_pin_interrupt_configure(my_gpio_port, BUTTON1_PIN, GPIO_INT_EDGE_TO_INACTIVE);
     4f0:	4b19      	ldr	r3, [pc, #100]	; (558 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x70>)
     4f2:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_api *api =
     4f4:	6883      	ldr	r3, [r0, #8]
	const struct gpio_driver_data *const data =
     4f6:	6902      	ldr	r2, [r0, #16]
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
     4f8:	6812      	ldr	r2, [r2, #0]
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
     4fa:	f412 5f00 	tst.w	r2, #8192	; 0x2000
     4fe:	d122      	bne.n	546 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x5e>
     500:	f44f 3270 	mov.w	r2, #245760	; 0x3c000
	return api->pin_interrupt_configure(port, pin, mode, trig);
     504:	699c      	ldr	r4, [r3, #24]
     506:	f402 23c0 	and.w	r3, r2, #393216	; 0x60000
     50a:	f402 32a0 	and.w	r2, r2, #81920	; 0x14000
     50e:	210d      	movs	r1, #13
     510:	47a0      	blx	r4
	gpio_pin_interrupt_configure(my_gpio_port, BUTTON2_PIN, GPIO_INT_EDGE_TO_INACTIVE);
     512:	4b11      	ldr	r3, [pc, #68]	; (558 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x70>)
     514:	6818      	ldr	r0, [r3, #0]
	const struct gpio_driver_api *api =
     516:	6883      	ldr	r3, [r0, #8]
	const struct gpio_driver_data *const data =
     518:	6902      	ldr	r2, [r0, #16]
	    ((data->invert & (gpio_port_pins_t)BIT(pin)) != 0)) {
     51a:	6812      	ldr	r2, [r2, #0]
	if (((flags & GPIO_INT_LEVELS_LOGICAL) != 0) &&
     51c:	f412 4f80 	tst.w	r2, #16384	; 0x4000
     520:	d114      	bne.n	54c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x64>
     522:	f44f 3270 	mov.w	r2, #245760	; 0x3c000
	return api->pin_interrupt_configure(port, pin, mode, trig);
     526:	699c      	ldr	r4, [r3, #24]
     528:	f402 23c0 	and.w	r3, r2, #393216	; 0x60000
     52c:	f402 32a0 	and.w	r2, r2, #81920	; 0x14000
     530:	210e      	movs	r1, #14
     532:	47a0      	blx	r4

	k_work_init(&button1_work, button1_work_handler);
     534:	490d      	ldr	r1, [pc, #52]	; (56c <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x84>)
     536:	480e      	ldr	r0, [pc, #56]	; (570 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x88>)
     538:	f006 ff07 	bl	734a <k_work_init>
	k_work_init(&button2_work, button2_work_handler);
     53c:	490d      	ldr	r1, [pc, #52]	; (574 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x8c>)
     53e:	480e      	ldr	r0, [pc, #56]	; (578 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x90>)
     540:	f006 ff03 	bl	734a <k_work_init>
}
     544:	bd10      	pop	{r4, pc}
		flags ^= (GPIO_INT_LOW_0 | GPIO_INT_HIGH_1);
     546:	f44f 22b8 	mov.w	r2, #376832	; 0x5c000
     54a:	e7db      	b.n	504 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x1c>
     54c:	f44f 22b8 	mov.w	r2, #376832	; 0x5c000
     550:	e7e9      	b.n	526 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x3e>
     552:	bf00      	nop
     554:	00007b28 	.word	0x00007b28
     558:	200003b0 	.word	0x200003b0
     55c:	20000378 	.word	0x20000378
     560:	00000401 	.word	0x00000401
     564:	20000394 	.word	0x20000394
     568:	00000429 	.word	0x00000429
     56c:	000003d1 	.word	0x000003d1
     570:	20000384 	.word	0x20000384
     574:	000003e9 	.word	0x000003e9
     578:	200003a0 	.word	0x200003a0

0000057c <main>:

void main(void)
{
     57c:	b508      	push	{r3, lr}
	printk("Hello World! %s\n", CONFIG_BOARD);
     57e:	4903      	ldr	r1, [pc, #12]	; (58c <main+0x10>)
     580:	4803      	ldr	r0, [pc, #12]	; (590 <main+0x14>)
     582:	f005 fb1d 	bl	5bc0 <printk>

	configure_gpios();
     586:	f7ff ff63 	bl	450 <configure_gpios>
}
     58a:	bd08      	pop	{r3, pc}
     58c:	00007b30 	.word	0x00007b30
     590:	00007b44 	.word	0x00007b44

00000594 <__printk_hook_install>:
 *
 * @return N/A
 */
void __printk_hook_install(int (*fn)(int))
{
	_char_out = fn;
     594:	4b01      	ldr	r3, [pc, #4]	; (59c <__printk_hook_install+0x8>)
     596:	6018      	str	r0, [r3, #0]
}
     598:	4770      	bx	lr
     59a:	bf00      	nop
     59c:	20000000 	.word	0x20000000

000005a0 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
     5a0:	b510      	push	{r4, lr}
     5a2:	b084      	sub	sp, #16
     5a4:	4604      	mov	r4, r0
	struct str_context ctx = { str, size, 0 };
     5a6:	9001      	str	r0, [sp, #4]
     5a8:	9102      	str	r1, [sp, #8]
     5aa:	2100      	movs	r1, #0
     5ac:	9103      	str	r1, [sp, #12]

	cbvprintf(str_out, &ctx, fmt, ap);
     5ae:	a901      	add	r1, sp, #4
     5b0:	4805      	ldr	r0, [pc, #20]	; (5c8 <vsnprintk+0x28>)
     5b2:	f000 f8b7 	bl	724 <cbvprintf>

	if (ctx.count < ctx.max) {
     5b6:	9b03      	ldr	r3, [sp, #12]
     5b8:	9a02      	ldr	r2, [sp, #8]
     5ba:	4293      	cmp	r3, r2
     5bc:	da01      	bge.n	5c2 <vsnprintk+0x22>
		str[ctx.count] = '\0';
     5be:	2200      	movs	r2, #0
     5c0:	54e2      	strb	r2, [r4, r3]
	}

	return ctx.count;
}
     5c2:	9803      	ldr	r0, [sp, #12]
     5c4:	b004      	add	sp, #16
     5c6:	bd10      	pop	{r4, pc}
     5c8:	00005b91 	.word	0x00005b91

000005cc <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     5cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     5d0:	b083      	sub	sp, #12
     5d2:	4604      	mov	r4, r0
     5d4:	4608      	mov	r0, r1
     5d6:	4615      	mov	r5, r2
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     5d8:	8b23      	ldrh	r3, [r4, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     5da:	f013 0f08 	tst.w	r3, #8
     5de:	d105      	bne.n	5ec <process_event+0x20>
     5e0:	f003 0607 	and.w	r6, r3, #7
 *
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
     5e4:	2300      	movs	r3, #0
     5e6:	9300      	str	r3, [sp, #0]
	list->tail = NULL;
     5e8:	9301      	str	r3, [sp, #4]
}
     5ea:	e069      	b.n	6c0 <process_event+0xf4>
		if (evt == EVT_COMPLETE) {
     5ec:	2901      	cmp	r1, #1
     5ee:	d009      	beq.n	604 <process_event+0x38>
			mgr->flags |= ONOFF_FLAG_COMPLETE;
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     5f0:	f043 0320 	orr.w	r3, r3, #32
     5f4:	8323      	strh	r3, [r4, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     5f6:	f385 8811 	msr	BASEPRI, r5
     5fa:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     5fe:	b003      	add	sp, #12
     600:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     604:	f043 0310 	orr.w	r3, r3, #16
     608:	8323      	strh	r3, [r4, #24]
     60a:	e7f4      	b.n	5f6 <process_event+0x2a>
			evt = process_recheck(mgr);
     60c:	4620      	mov	r0, r4
     60e:	f005 fb1a 	bl	5c46 <process_recheck>
     612:	e057      	b.n	6c4 <process_event+0xf8>
			res = mgr->last_res;
     614:	f8d4 9014 	ldr.w	r9, [r4, #20]
			process_complete(mgr, &clients, res);
     618:	464a      	mov	r2, r9
     61a:	4669      	mov	r1, sp
     61c:	4620      	mov	r0, r4
     61e:	f005 fb2b 	bl	5c78 <process_complete>
		onoff_transition_fn transit = NULL;
     622:	2700      	movs	r7, #0
     624:	e05a      	b.n	6dc <process_event+0x110>
			transit = mgr->transitions->start;
     626:	6923      	ldr	r3, [r4, #16]
     628:	681f      	ldr	r7, [r3, #0]
			set_state(mgr, ONOFF_STATE_TO_ON);
     62a:	2106      	movs	r1, #6
     62c:	4620      	mov	r0, r4
     62e:	f005 fae3 	bl	5bf8 <set_state>
		res = 0;
     632:	f04f 0900 	mov.w	r9, #0
     636:	e051      	b.n	6dc <process_event+0x110>
			transit = mgr->transitions->stop;
     638:	6923      	ldr	r3, [r4, #16]
     63a:	685f      	ldr	r7, [r3, #4]
			set_state(mgr, ONOFF_STATE_TO_OFF);
     63c:	2104      	movs	r1, #4
     63e:	4620      	mov	r0, r4
     640:	f005 fada 	bl	5bf8 <set_state>
		res = 0;
     644:	f04f 0900 	mov.w	r9, #0
     648:	e048      	b.n	6dc <process_event+0x110>
			transit = mgr->transitions->reset;
     64a:	6923      	ldr	r3, [r4, #16]
     64c:	689f      	ldr	r7, [r3, #8]
			set_state(mgr, ONOFF_STATE_RESETTING);
     64e:	2105      	movs	r1, #5
     650:	4620      	mov	r0, r4
     652:	f005 fad1 	bl	5bf8 <set_state>
		res = 0;
     656:	f04f 0900 	mov.w	r9, #0
     65a:	e03f      	b.n	6dc <process_event+0x110>
				   && !sys_slist_is_empty(&mgr->monitors);
     65c:	2200      	movs	r2, #0
     65e:	e046      	b.n	6ee <process_event+0x122>
     660:	2200      	movs	r2, #0
     662:	e044      	b.n	6ee <process_event+0x122>
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     664:	f043 0308 	orr.w	r3, r3, #8
			mgr->flags = flags;
     668:	8323      	strh	r3, [r4, #24]
     66a:	f385 8811 	msr	BASEPRI, r5
     66e:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
     672:	2900      	cmp	r1, #0
     674:	d144      	bne.n	700 <process_event+0x134>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
     676:	9b00      	ldr	r3, [sp, #0]
			if (!sys_slist_is_empty(&clients)) {
     678:	b12b      	cbz	r3, 686 <process_event+0xba>
				notify_all(mgr, &clients, state, res);
     67a:	464b      	mov	r3, r9
     67c:	4642      	mov	r2, r8
     67e:	4669      	mov	r1, sp
     680:	4620      	mov	r0, r4
     682:	f005 fb6f 	bl	5d64 <notify_all>
			if (transit != NULL) {
     686:	b117      	cbz	r7, 68e <process_event+0xc2>
				transit(mgr, transition_complete);
     688:	4925      	ldr	r1, [pc, #148]	; (720 <process_event+0x154>)
     68a:	4620      	mov	r0, r4
     68c:	47b8      	blx	r7
	__asm__ volatile(
     68e:	f04f 0320 	mov.w	r3, #32
     692:	f3ef 8511 	mrs	r5, BASEPRI
     696:	f383 8811 	msr	BASEPRI, r3
     69a:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     69e:	8b23      	ldrh	r3, [r4, #24]
     6a0:	f023 0308 	bic.w	r3, r3, #8
     6a4:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     6a6:	8b23      	ldrh	r3, [r4, #24]
     6a8:	f013 0f10 	tst.w	r3, #16
     6ac:	d02e      	beq.n	70c <process_event+0x140>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     6ae:	f023 0310 	bic.w	r3, r3, #16
     6b2:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
     6b4:	2001      	movs	r0, #1
		state = mgr->flags & ONOFF_STATE_MASK;
     6b6:	8b26      	ldrh	r6, [r4, #24]
     6b8:	f006 0607 	and.w	r6, r6, #7
	} while (evt != EVT_NOP);
     6bc:	2800      	cmp	r0, #0
     6be:	d09a      	beq.n	5f6 <process_event+0x2a>
		if (evt == EVT_RECHECK) {
     6c0:	2802      	cmp	r0, #2
     6c2:	d0a3      	beq.n	60c <process_event+0x40>
		if (evt == EVT_NOP) {
     6c4:	2800      	cmp	r0, #0
     6c6:	d096      	beq.n	5f6 <process_event+0x2a>
		if (evt == EVT_COMPLETE) {
     6c8:	2801      	cmp	r0, #1
     6ca:	d0a3      	beq.n	614 <process_event+0x48>
		} else if (evt == EVT_START) {
     6cc:	2803      	cmp	r0, #3
     6ce:	d0aa      	beq.n	626 <process_event+0x5a>
		} else if (evt == EVT_STOP) {
     6d0:	2804      	cmp	r0, #4
     6d2:	d0b1      	beq.n	638 <process_event+0x6c>
		} else if (evt == EVT_RESET) {
     6d4:	2805      	cmp	r0, #5
     6d6:	d0b8      	beq.n	64a <process_event+0x7e>
		onoff_transition_fn transit = NULL;
     6d8:	2700      	movs	r7, #0
		res = 0;
     6da:	46b9      	mov	r9, r7
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     6dc:	8b23      	ldrh	r3, [r4, #24]
     6de:	f003 0807 	and.w	r8, r3, #7
				   && !sys_slist_is_empty(&mgr->monitors);
     6e2:	45b0      	cmp	r8, r6
     6e4:	d0ba      	beq.n	65c <process_event+0x90>
     6e6:	68a2      	ldr	r2, [r4, #8]
     6e8:	2a00      	cmp	r2, #0
     6ea:	d0b9      	beq.n	660 <process_event+0x94>
     6ec:	2201      	movs	r2, #1
		if (do_monitors
     6ee:	4611      	mov	r1, r2
     6f0:	2a00      	cmp	r2, #0
     6f2:	d1b7      	bne.n	664 <process_event+0x98>
     6f4:	9a00      	ldr	r2, [sp, #0]
		    || !sys_slist_is_empty(&clients)
     6f6:	2a00      	cmp	r2, #0
     6f8:	d1b4      	bne.n	664 <process_event+0x98>
		    || (transit != NULL)) {
     6fa:	2f00      	cmp	r7, #0
     6fc:	d1b2      	bne.n	664 <process_event+0x98>
     6fe:	e7d2      	b.n	6a6 <process_event+0xda>
				notify_monitors(mgr, state, res);
     700:	464a      	mov	r2, r9
     702:	4641      	mov	r1, r8
     704:	4620      	mov	r0, r4
     706:	f005 fa7f 	bl	5c08 <notify_monitors>
     70a:	e7b4      	b.n	676 <process_event+0xaa>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     70c:	f013 0f20 	tst.w	r3, #32
     710:	d004      	beq.n	71c <process_event+0x150>
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     712:	f023 0320 	bic.w	r3, r3, #32
     716:	8323      	strh	r3, [r4, #24]
			evt = EVT_RECHECK;
     718:	2002      	movs	r0, #2
     71a:	e7cc      	b.n	6b6 <process_event+0xea>
		evt = EVT_NOP;
     71c:	2000      	movs	r0, #0
     71e:	e7ca      	b.n	6b6 <process_event+0xea>
     720:	00005d93 	.word	0x00005d93

00000724 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
     724:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     728:	b093      	sub	sp, #76	; 0x4c
     72a:	4606      	mov	r6, r0
     72c:	460d      	mov	r5, r1
     72e:	4692      	mov	sl, r2
     730:	9303      	str	r3, [sp, #12]
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
     732:	2400      	movs	r4, #0
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
     734:	f89a 0000 	ldrb.w	r0, [sl]
     738:	2800      	cmp	r0, #0
     73a:	f000 84d6 	beq.w	10ea <CONFIG_FPROTECT_BLOCK_SIZE+0xea>
		if (*fp != '%') {
     73e:	2825      	cmp	r0, #37	; 0x25
     740:	d008      	beq.n	754 <cbvprintf+0x30>
			OUTC(*fp++);
     742:	f10a 0a01 	add.w	sl, sl, #1
     746:	4629      	mov	r1, r5
     748:	47b0      	blx	r6
     74a:	2800      	cmp	r0, #0
     74c:	f2c0 84ce 	blt.w	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
     750:	3401      	adds	r4, #1
			continue;
     752:	e7ef      	b.n	734 <cbvprintf+0x10>
		 * mitigate LLVM code generation bug.
		 */
		struct {
			union argument_value value;
			struct conversion conv;
		} state = {
     754:	2300      	movs	r3, #0
     756:	9306      	str	r3, [sp, #24]
     758:	9307      	str	r3, [sp, #28]
     75a:	930b      	str	r3, [sp, #44]	; 0x2c
	*conv = (struct conversion) {
     75c:	9308      	str	r3, [sp, #32]
     75e:	9309      	str	r3, [sp, #36]	; 0x24
     760:	930a      	str	r3, [sp, #40]	; 0x28
	++sp;
     762:	f10a 0801 	add.w	r8, sl, #1
	if (*sp == '%') {
     766:	f89a 3001 	ldrb.w	r3, [sl, #1]
     76a:	2b25      	cmp	r3, #37	; 0x25
     76c:	d001      	beq.n	772 <cbvprintf+0x4e>
	bool loop = true;
     76e:	2701      	movs	r7, #1
     770:	e02c      	b.n	7cc <cbvprintf+0xa8>
		conv->specifier = *sp++;
     772:	f10a 0802 	add.w	r8, sl, #2
     776:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
		return sp;
     77a:	e1a8      	b.n	ace <CONFIG_ISR_STACK_SIZE+0x2ce>
			conv->flag_dash = true;
     77c:	f89d 3020 	ldrb.w	r3, [sp, #32]
     780:	f043 0304 	orr.w	r3, r3, #4
     784:	f88d 3020 	strb.w	r3, [sp, #32]
		if (loop) {
     788:	b1ff      	cbz	r7, 7ca <cbvprintf+0xa6>
			++sp;
     78a:	f108 0801 	add.w	r8, r8, #1
     78e:	e01c      	b.n	7ca <cbvprintf+0xa6>
			conv->flag_plus = true;
     790:	f89d 3020 	ldrb.w	r3, [sp, #32]
     794:	f043 0308 	orr.w	r3, r3, #8
     798:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     79c:	e7f4      	b.n	788 <cbvprintf+0x64>
			conv->flag_space = true;
     79e:	f89d 3020 	ldrb.w	r3, [sp, #32]
     7a2:	f043 0310 	orr.w	r3, r3, #16
     7a6:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     7aa:	e7ed      	b.n	788 <cbvprintf+0x64>
			conv->flag_hash = true;
     7ac:	f89d 3020 	ldrb.w	r3, [sp, #32]
     7b0:	f043 0320 	orr.w	r3, r3, #32
     7b4:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     7b8:	e7e6      	b.n	788 <cbvprintf+0x64>
			conv->flag_zero = true;
     7ba:	f89d 3020 	ldrb.w	r3, [sp, #32]
     7be:	f043 0340 	orr.w	r3, r3, #64	; 0x40
     7c2:	f88d 3020 	strb.w	r3, [sp, #32]
			break;
     7c6:	e7df      	b.n	788 <cbvprintf+0x64>
		switch (*sp) {
     7c8:	2700      	movs	r7, #0
	} while (loop);
     7ca:	b34f      	cbz	r7, 820 <CONFIG_ISR_STACK_SIZE+0x20>
		switch (*sp) {
     7cc:	f898 3000 	ldrb.w	r3, [r8]
     7d0:	3b20      	subs	r3, #32
     7d2:	2b10      	cmp	r3, #16
     7d4:	d8f8      	bhi.n	7c8 <cbvprintf+0xa4>
     7d6:	a201      	add	r2, pc, #4	; (adr r2, 7dc <cbvprintf+0xb8>)
     7d8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     7dc:	0000079f 	.word	0x0000079f
     7e0:	000007c9 	.word	0x000007c9
     7e4:	000007c9 	.word	0x000007c9
     7e8:	000007ad 	.word	0x000007ad
     7ec:	000007c9 	.word	0x000007c9
     7f0:	000007c9 	.word	0x000007c9
     7f4:	000007c9 	.word	0x000007c9
     7f8:	000007c9 	.word	0x000007c9
     7fc:	000007c9 	.word	0x000007c9
     800:	000007c9 	.word	0x000007c9
     804:	000007c9 	.word	0x000007c9
     808:	00000791 	.word	0x00000791
     80c:	000007c9 	.word	0x000007c9
     810:	0000077d 	.word	0x0000077d
     814:	000007c9 	.word	0x000007c9
     818:	000007c9 	.word	0x000007c9
     81c:	000007bb 	.word	0x000007bb
	if (conv->flag_zero && conv->flag_dash) {
     820:	f89d 3020 	ldrb.w	r3, [sp, #32]
     824:	f003 0344 	and.w	r3, r3, #68	; 0x44
     828:	2b44      	cmp	r3, #68	; 0x44
     82a:	d06d      	beq.n	908 <CONFIG_ISR_STACK_SIZE+0x108>
	sp = extract_width(conv, sp);
     82c:	f8cd 8014 	str.w	r8, [sp, #20]
	conv->width_present = true;
     830:	f89d 3020 	ldrb.w	r3, [sp, #32]
     834:	f043 0380 	orr.w	r3, r3, #128	; 0x80
     838:	f88d 3020 	strb.w	r3, [sp, #32]
	if (*sp == '*') {
     83c:	f898 3000 	ldrb.w	r3, [r8]
     840:	2b2a      	cmp	r3, #42	; 0x2a
     842:	d068      	beq.n	916 <CONFIG_ISR_STACK_SIZE+0x116>
	size_t width = extract_decimal(&sp);
     844:	a805      	add	r0, sp, #20
     846:	f005 fb34 	bl	5eb2 <extract_decimal>
	if (sp != wp) {
     84a:	9b05      	ldr	r3, [sp, #20]
     84c:	4598      	cmp	r8, r3
     84e:	d012      	beq.n	876 <CONFIG_ISR_STACK_SIZE+0x76>
		conv->width_present = true;
     850:	f89d 3020 	ldrb.w	r3, [sp, #32]
     854:	f043 0380 	orr.w	r3, r3, #128	; 0x80
     858:	f88d 3020 	strb.w	r3, [sp, #32]
		conv->width_value = width;
     85c:	9009      	str	r0, [sp, #36]	; 0x24
		conv->unsupported |= ((conv->width_value < 0)
     85e:	f3c3 0340 	ubfx	r3, r3, #1, #1
				      || (width != (size_t)conv->width_value));
     862:	2800      	cmp	r0, #0
     864:	db60      	blt.n	928 <CONFIG_ISR_STACK_SIZE+0x128>
     866:	2200      	movs	r2, #0
		conv->unsupported |= ((conv->width_value < 0)
     868:	4313      	orrs	r3, r2
     86a:	f89d 2020 	ldrb.w	r2, [sp, #32]
     86e:	f363 0241 	bfi	r2, r3, #1, #1
     872:	f88d 2020 	strb.w	r2, [sp, #32]
	return sp;
     876:	9b05      	ldr	r3, [sp, #20]
	sp = extract_prec(conv, sp);
     878:	9305      	str	r3, [sp, #20]
	conv->prec_present = (*sp == '.');
     87a:	781b      	ldrb	r3, [r3, #0]
     87c:	2b2e      	cmp	r3, #46	; 0x2e
     87e:	bf14      	ite	ne
     880:	2300      	movne	r3, #0
     882:	2301      	moveq	r3, #1
     884:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
     888:	f363 0241 	bfi	r2, r3, #1, #1
     88c:	f88d 2021 	strb.w	r2, [sp, #33]	; 0x21
	if (!conv->prec_present) {
     890:	2b00      	cmp	r3, #0
     892:	d04b      	beq.n	92c <CONFIG_ISR_STACK_SIZE+0x12c>
	++sp;
     894:	9b05      	ldr	r3, [sp, #20]
     896:	1c5a      	adds	r2, r3, #1
     898:	9205      	str	r2, [sp, #20]
	if (*sp == '*') {
     89a:	785b      	ldrb	r3, [r3, #1]
     89c:	2b2a      	cmp	r3, #42	; 0x2a
     89e:	d048      	beq.n	932 <CONFIG_ISR_STACK_SIZE+0x132>
	size_t prec = extract_decimal(&sp);
     8a0:	a805      	add	r0, sp, #20
     8a2:	f005 fb06 	bl	5eb2 <extract_decimal>
	conv->prec_value = prec;
     8a6:	900a      	str	r0, [sp, #40]	; 0x28
	conv->unsupported |= ((conv->prec_value < 0)
     8a8:	f89d 3020 	ldrb.w	r3, [sp, #32]
     8ac:	f3c3 0340 	ubfx	r3, r3, #1, #1
			      || (prec != (size_t)conv->prec_value));
     8b0:	2800      	cmp	r0, #0
     8b2:	db47      	blt.n	944 <CONFIG_ISR_STACK_SIZE+0x144>
     8b4:	2200      	movs	r2, #0
	conv->unsupported |= ((conv->prec_value < 0)
     8b6:	4313      	orrs	r3, r2
     8b8:	f89d 2020 	ldrb.w	r2, [sp, #32]
     8bc:	f363 0241 	bfi	r2, r3, #1, #1
     8c0:	f88d 2020 	strb.w	r2, [sp, #32]
	return sp;
     8c4:	f8dd 8014 	ldr.w	r8, [sp, #20]
	switch (*sp) {
     8c8:	f898 3000 	ldrb.w	r3, [r8]
     8cc:	3b4c      	subs	r3, #76	; 0x4c
     8ce:	2b2e      	cmp	r3, #46	; 0x2e
     8d0:	f200 80dc 	bhi.w	a8c <CONFIG_ISR_STACK_SIZE+0x28c>
     8d4:	e8df f003 	tbb	[pc, r3]
     8d8:	dadadaca 	.word	0xdadadaca
     8dc:	dadadada 	.word	0xdadadada
     8e0:	dadadada 	.word	0xdadadada
     8e4:	dadadada 	.word	0xdadadada
     8e8:	dadadada 	.word	0xdadadada
     8ec:	dadadada 	.word	0xdadadada
     8f0:	dadadada 	.word	0xdadadada
     8f4:	da6ada38 	.word	0xda6ada38
     8f8:	dadada51 	.word	0xdadada51
     8fc:	dadadada 	.word	0xdadadada
     900:	dadadac0 	.word	0xdadadac0
     904:	dada      	.short	0xdada
     906:	b6          	.byte	0xb6
     907:	00          	.byte	0x00
		conv->flag_zero = false;
     908:	f89d 3020 	ldrb.w	r3, [sp, #32]
     90c:	f36f 1386 	bfc	r3, #6, #1
     910:	f88d 3020 	strb.w	r3, [sp, #32]
     914:	e78a      	b.n	82c <CONFIG_ISR_STACK_SIZE+0x2c>
		conv->width_star = true;
     916:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     91a:	f043 0301 	orr.w	r3, r3, #1
     91e:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		return ++sp;
     922:	4643      	mov	r3, r8
     924:	3301      	adds	r3, #1
     926:	e7a7      	b.n	878 <CONFIG_ISR_STACK_SIZE+0x78>
				      || (width != (size_t)conv->width_value));
     928:	2201      	movs	r2, #1
     92a:	e79d      	b.n	868 <CONFIG_ISR_STACK_SIZE+0x68>
		return sp;
     92c:	f8dd 8014 	ldr.w	r8, [sp, #20]
     930:	e7ca      	b.n	8c8 <CONFIG_ISR_STACK_SIZE+0xc8>
		conv->prec_star = true;
     932:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     936:	f043 0304 	orr.w	r3, r3, #4
     93a:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		return ++sp;
     93e:	f102 0801 	add.w	r8, r2, #1
     942:	e7c1      	b.n	8c8 <CONFIG_ISR_STACK_SIZE+0xc8>
			      || (prec != (size_t)conv->prec_value));
     944:	2201      	movs	r2, #1
     946:	e7b6      	b.n	8b6 <CONFIG_ISR_STACK_SIZE+0xb6>
		if (*++sp == 'h') {
     948:	f108 0201 	add.w	r2, r8, #1
     94c:	f898 3001 	ldrb.w	r3, [r8, #1]
     950:	2b68      	cmp	r3, #104	; 0x68
     952:	d008      	beq.n	966 <CONFIG_ISR_STACK_SIZE+0x166>
			conv->length_mod = LENGTH_H;
     954:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     958:	2102      	movs	r1, #2
     95a:	f361 03c6 	bfi	r3, r1, #3, #4
     95e:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		if (*++sp == 'h') {
     962:	4690      	mov	r8, r2
     964:	e02b      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
			conv->length_mod = LENGTH_HH;
     966:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     96a:	2201      	movs	r2, #1
     96c:	f362 03c6 	bfi	r3, r2, #3, #4
     970:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
			++sp;
     974:	f108 0802 	add.w	r8, r8, #2
     978:	e021      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
		if (*++sp == 'l') {
     97a:	f108 0201 	add.w	r2, r8, #1
     97e:	f898 3001 	ldrb.w	r3, [r8, #1]
     982:	2b6c      	cmp	r3, #108	; 0x6c
     984:	d008      	beq.n	998 <CONFIG_ISR_STACK_SIZE+0x198>
			conv->length_mod = LENGTH_L;
     986:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     98a:	2103      	movs	r1, #3
     98c:	f361 03c6 	bfi	r3, r1, #3, #4
     990:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		if (*++sp == 'l') {
     994:	4690      	mov	r8, r2
     996:	e012      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
			conv->length_mod = LENGTH_LL;
     998:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     99c:	2204      	movs	r2, #4
     99e:	f362 03c6 	bfi	r3, r2, #3, #4
     9a2:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
			++sp;
     9a6:	f108 0802 	add.w	r8, r8, #2
     9aa:	e008      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
		conv->length_mod = LENGTH_J;
     9ac:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     9b0:	2205      	movs	r2, #5
     9b2:	f362 03c6 	bfi	r3, r2, #3, #4
     9b6:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     9ba:	f108 0801 	add.w	r8, r8, #1
	conv->specifier = *sp++;
     9be:	f818 3b01 	ldrb.w	r3, [r8], #1
     9c2:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
	switch (conv->specifier) {
     9c6:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
     9ca:	2a37      	cmp	r2, #55	; 0x37
     9cc:	f200 8150 	bhi.w	c70 <CONFIG_ISR_STACK_SIZE+0x470>
     9d0:	e8df f012 	tbh	[pc, r2, lsl #1]
     9d4:	014e0126 	.word	0x014e0126
     9d8:	014e014e 	.word	0x014e014e
     9dc:	01260126 	.word	0x01260126
     9e0:	014e0126 	.word	0x014e0126
     9e4:	014e014e 	.word	0x014e014e
     9e8:	014e014e 	.word	0x014e014e
     9ec:	014e014e 	.word	0x014e014e
     9f0:	014e014e 	.word	0x014e014e
     9f4:	014e014e 	.word	0x014e014e
     9f8:	014e014e 	.word	0x014e014e
     9fc:	014e014e 	.word	0x014e014e
     a00:	0113014e 	.word	0x0113014e
     a04:	014e014e 	.word	0x014e014e
     a08:	014e014e 	.word	0x014e014e
     a0c:	014e014e 	.word	0x014e014e
     a10:	014e014e 	.word	0x014e014e
     a14:	014e0126 	.word	0x014e0126
     a18:	00630113 	.word	0x00630113
     a1c:	01260126 	.word	0x01260126
     a20:	014e0126 	.word	0x014e0126
     a24:	014e0063 	.word	0x014e0063
     a28:	014e014e 	.word	0x014e014e
     a2c:	012f014e 	.word	0x012f014e
     a30:	013f0113 	.word	0x013f0113
     a34:	014e014e 	.word	0x014e014e
     a38:	014e013f 	.word	0x014e013f
     a3c:	014e0113 	.word	0x014e0113
     a40:	0113014e 	.word	0x0113014e
		conv->length_mod = LENGTH_Z;
     a44:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     a48:	2206      	movs	r2, #6
     a4a:	f362 03c6 	bfi	r3, r2, #3, #4
     a4e:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     a52:	f108 0801 	add.w	r8, r8, #1
		break;
     a56:	e7b2      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
		conv->length_mod = LENGTH_T;
     a58:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     a5c:	2207      	movs	r2, #7
     a5e:	f362 03c6 	bfi	r3, r2, #3, #4
     a62:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     a66:	f108 0801 	add.w	r8, r8, #1
		break;
     a6a:	e7a8      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
		conv->length_mod = LENGTH_UPPER_L;
     a6c:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     a70:	2208      	movs	r2, #8
     a72:	f362 03c6 	bfi	r3, r2, #3, #4
     a76:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		++sp;
     a7a:	f108 0801 	add.w	r8, r8, #1
		conv->unsupported = true;
     a7e:	f89d 3020 	ldrb.w	r3, [sp, #32]
     a82:	f043 0302 	orr.w	r3, r3, #2
     a86:	f88d 3020 	strb.w	r3, [sp, #32]
		break;
     a8a:	e798      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
		conv->length_mod = LENGTH_NONE;
     a8c:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     a90:	f36f 03c6 	bfc	r3, #3, #4
     a94:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		break;
     a98:	e791      	b.n	9be <CONFIG_ISR_STACK_SIZE+0x1be>
		conv->specifier_cat = SPECIFIER_SINT;
     a9a:	f89d 2022 	ldrb.w	r2, [sp, #34]	; 0x22
     a9e:	2101      	movs	r1, #1
     aa0:	f361 0202 	bfi	r2, r1, #0, #3
     aa4:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
		if (conv->length_mod == LENGTH_UPPER_L) {
     aa8:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
     aac:	f002 0278 	and.w	r2, r2, #120	; 0x78
     ab0:	2a40      	cmp	r2, #64	; 0x40
     ab2:	f000 80aa 	beq.w	c0a <CONFIG_ISR_STACK_SIZE+0x40a>
		if (conv->specifier == 'c') {
     ab6:	2b63      	cmp	r3, #99	; 0x63
     ab8:	f000 80ae 	beq.w	c18 <CONFIG_ISR_STACK_SIZE+0x418>
	conv->unsupported |= unsupported;
     abc:	f89d 3020 	ldrb.w	r3, [sp, #32]
     ac0:	f3c3 0240 	ubfx	r2, r3, #1, #1
     ac4:	4317      	orrs	r7, r2
     ac6:	f367 0341 	bfi	r3, r7, #1, #1
     aca:	f88d 3020 	strb.w	r3, [sp, #32]
		fp = extract_conversion(conv, sp);

		/* If dynamic width is specified, process it,
		 * otherwise set width if present.
		 */
		if (conv->width_star) {
     ace:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     ad2:	f013 0f01 	tst.w	r3, #1
     ad6:	f000 80da 	beq.w	c8e <CONFIG_ISR_STACK_SIZE+0x48e>
			width = va_arg(ap, int);
     ada:	9b03      	ldr	r3, [sp, #12]
     adc:	1d1a      	adds	r2, r3, #4
     ade:	9203      	str	r2, [sp, #12]
     ae0:	681f      	ldr	r7, [r3, #0]

			if (width < 0) {
     ae2:	2f00      	cmp	r7, #0
     ae4:	f2c0 80cb 	blt.w	c7e <CONFIG_ISR_STACK_SIZE+0x47e>

		/* If dynamic precision is specified, process it, otherwise
		 * set precision if present.  For floating point where
		 * precision is not present use 6.
		 */
		if (conv->prec_star) {
     ae8:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     aec:	f013 0f04 	tst.w	r3, #4
     af0:	f000 80df 	beq.w	cb2 <CONFIG_ISR_STACK_SIZE+0x4b2>
			int arg = va_arg(ap, int);
     af4:	9b03      	ldr	r3, [sp, #12]
     af6:	1d1a      	adds	r2, r3, #4
     af8:	9203      	str	r2, [sp, #12]
     afa:	f8d3 b000 	ldr.w	fp, [r3]

			if (arg < 0) {
     afe:	f1bb 0f00 	cmp.w	fp, #0
     b02:	f2c0 80cd 	blt.w	ca0 <CONFIG_ISR_STACK_SIZE+0x4a0>
		}

		/* Reuse width and precision memory in conv for value
		 * padding counts.
		 */
		conv->pad0_value = 0;
     b06:	2300      	movs	r3, #0
     b08:	9309      	str	r3, [sp, #36]	; 0x24
		conv->pad0_pre_exp = 0;
     b0a:	930a      	str	r3, [sp, #40]	; 0x28
		 * This can't be extracted to a helper function because
		 * passing a pointer to va_list doesn't work on x86_64.  See
		 * https://stackoverflow.com/a/8048892.
		 */
		enum specifier_cat_enum specifier_cat
			= (enum specifier_cat_enum)conv->specifier_cat;
     b0c:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
     b10:	f003 0307 	and.w	r3, r3, #7
		enum length_mod_enum length_mod
			= (enum length_mod_enum)conv->length_mod;
     b14:	f89d 1021 	ldrb.w	r1, [sp, #33]	; 0x21
     b18:	f3c1 01c3 	ubfx	r1, r1, #3, #4
		/* Extract the value based on the argument category and length.
		 *
		 * Note that the length modifier doesn't affect the value of a
		 * pointer argument.
		 */
		if (specifier_cat == SPECIFIER_SINT) {
     b1c:	2b01      	cmp	r3, #1
     b1e:	f000 80d1 	beq.w	cc4 <CONFIG_ISR_STACK_SIZE+0x4c4>
			if (length_mod == LENGTH_HH) {
				value->sint = (char)value->sint;
			} else if (length_mod == LENGTH_H) {
				value->sint = (short)value->sint;
			}
		} else if (specifier_cat == SPECIFIER_UINT) {
     b22:	2b02      	cmp	r3, #2
     b24:	f000 8116 	beq.w	d54 <CONFIG_ISR_STACK_SIZE+0x554>
			if (length_mod == LENGTH_HH) {
				value->uint = (unsigned char)value->uint;
			} else if (length_mod == LENGTH_H) {
				value->uint = (unsigned short)value->uint;
			}
		} else if (specifier_cat == SPECIFIER_FP) {
     b28:	2b04      	cmp	r3, #4
     b2a:	f000 8167 	beq.w	dfc <CONFIG_ISR_STACK_SIZE+0x5fc>
			if (length_mod == LENGTH_UPPER_L) {
				value->ldbl = va_arg(ap, long double);
			} else {
				value->dbl = va_arg(ap, double);
			}
		} else if (specifier_cat == SPECIFIER_PTR) {
     b2e:	2b03      	cmp	r3, #3
     b30:	f000 817e 	beq.w	e30 <CONFIG_ISR_STACK_SIZE+0x630>
		/* We've now consumed all arguments related to this
		 * specification.  If the conversion is invalid, or is
		 * something we don't support, then output the original
		 * specification and move on.
		 */
		if (conv->invalid || conv->unsupported) {
     b34:	f89d 9020 	ldrb.w	r9, [sp, #32]
     b38:	f019 0303 	ands.w	r3, r9, #3
     b3c:	9302      	str	r3, [sp, #8]
     b3e:	f040 817d 	bne.w	e3c <CONFIG_ISR_STACK_SIZE+0x63c>
		}

		/* Do formatting, either into the buffer or
		 * referencing external data.
		 */
		switch (conv->specifier) {
     b42:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
     b46:	3b25      	subs	r3, #37	; 0x25
     b48:	2b53      	cmp	r3, #83	; 0x53
     b4a:	f200 8233 	bhi.w	fb4 <CONFIG_ISR_STACK_SIZE+0x7b4>
     b4e:	e8df f013 	tbh	[pc, r3, lsl #1]
     b52:	0181      	.short	0x0181
     b54:	02310231 	.word	0x02310231
     b58:	02310231 	.word	0x02310231
     b5c:	02310231 	.word	0x02310231
     b60:	02310231 	.word	0x02310231
     b64:	02310231 	.word	0x02310231
     b68:	02310231 	.word	0x02310231
     b6c:	02310231 	.word	0x02310231
     b70:	02310231 	.word	0x02310231
     b74:	02310231 	.word	0x02310231
     b78:	02310231 	.word	0x02310231
     b7c:	02310231 	.word	0x02310231
     b80:	02310231 	.word	0x02310231
     b84:	02310231 	.word	0x02310231
     b88:	02310231 	.word	0x02310231
     b8c:	02310231 	.word	0x02310231
     b90:	02310231 	.word	0x02310231
     b94:	02310231 	.word	0x02310231
     b98:	02310231 	.word	0x02310231
     b9c:	02310231 	.word	0x02310231
     ba0:	02310231 	.word	0x02310231
     ba4:	02310231 	.word	0x02310231
     ba8:	02310231 	.word	0x02310231
     bac:	02310231 	.word	0x02310231
     bb0:	02310231 	.word	0x02310231
     bb4:	02310231 	.word	0x02310231
     bb8:	023101c7 	.word	0x023101c7
     bbc:	02310231 	.word	0x02310231
     bc0:	02310231 	.word	0x02310231
     bc4:	02310231 	.word	0x02310231
     bc8:	02310231 	.word	0x02310231
     bcc:	01a10231 	.word	0x01a10231
     bd0:	023101ab 	.word	0x023101ab
     bd4:	02310231 	.word	0x02310231
     bd8:	01ab0231 	.word	0x01ab0231
     bdc:	02310231 	.word	0x02310231
     be0:	02310231 	.word	0x02310231
     be4:	01c70208 	.word	0x01c70208
     be8:	023101ea 	.word	0x023101ea
     bec:	018f0231 	.word	0x018f0231
     bf0:	01c70231 	.word	0x01c70231
     bf4:	02310231 	.word	0x02310231
     bf8:	01c7      	.short	0x01c7
		conv->specifier_cat = SPECIFIER_UINT;
     bfa:	f89d 2022 	ldrb.w	r2, [sp, #34]	; 0x22
     bfe:	2102      	movs	r1, #2
     c00:	f361 0202 	bfi	r2, r1, #0, #3
     c04:	f88d 2022 	strb.w	r2, [sp, #34]	; 0x22
     c08:	e74e      	b.n	aa8 <CONFIG_ISR_STACK_SIZE+0x2a8>
			conv->invalid = true;
     c0a:	f89d 1020 	ldrb.w	r1, [sp, #32]
     c0e:	f041 0101 	orr.w	r1, r1, #1
     c12:	f88d 1020 	strb.w	r1, [sp, #32]
     c16:	e74e      	b.n	ab6 <CONFIG_ISR_STACK_SIZE+0x2b6>
			unsupported = (conv->length_mod != LENGTH_NONE);
     c18:	1e17      	subs	r7, r2, #0
     c1a:	bf18      	it	ne
     c1c:	2701      	movne	r7, #1
     c1e:	e74d      	b.n	abc <CONFIG_ISR_STACK_SIZE+0x2bc>
		conv->specifier_cat = SPECIFIER_FP;
     c20:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
     c24:	2204      	movs	r2, #4
     c26:	f362 0302 	bfi	r3, r2, #0, #3
     c2a:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
			unsupported = true;
     c2e:	2701      	movs	r7, #1
			break;
     c30:	e744      	b.n	abc <CONFIG_ISR_STACK_SIZE+0x2bc>
		conv->specifier_cat = SPECIFIER_PTR;
     c32:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
     c36:	2203      	movs	r2, #3
     c38:	f362 0302 	bfi	r3, r2, #0, #3
     c3c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
		if (conv->length_mod == LENGTH_UPPER_L) {
     c40:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     c44:	f003 0378 	and.w	r3, r3, #120	; 0x78
     c48:	2b40      	cmp	r3, #64	; 0x40
     c4a:	f47f af37 	bne.w	abc <CONFIG_ISR_STACK_SIZE+0x2bc>
			unsupported = true;
     c4e:	2701      	movs	r7, #1
     c50:	e734      	b.n	abc <CONFIG_ISR_STACK_SIZE+0x2bc>
		conv->specifier_cat = SPECIFIER_PTR;
     c52:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
     c56:	2203      	movs	r2, #3
     c58:	f362 0302 	bfi	r3, r2, #0, #3
     c5c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
		if (conv->length_mod != LENGTH_NONE) {
     c60:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     c64:	f013 0f78 	tst.w	r3, #120	; 0x78
     c68:	f43f af28 	beq.w	abc <CONFIG_ISR_STACK_SIZE+0x2bc>
			unsupported = true;
     c6c:	2701      	movs	r7, #1
     c6e:	e725      	b.n	abc <CONFIG_ISR_STACK_SIZE+0x2bc>
		conv->invalid = true;
     c70:	f89d 3020 	ldrb.w	r3, [sp, #32]
     c74:	f043 0301 	orr.w	r3, r3, #1
     c78:	f88d 3020 	strb.w	r3, [sp, #32]
		break;
     c7c:	e71e      	b.n	abc <CONFIG_ISR_STACK_SIZE+0x2bc>
				conv->flag_dash = true;
     c7e:	f89d 3020 	ldrb.w	r3, [sp, #32]
     c82:	f043 0304 	orr.w	r3, r3, #4
     c86:	f88d 3020 	strb.w	r3, [sp, #32]
				width = -width;
     c8a:	427f      	negs	r7, r7
     c8c:	e72c      	b.n	ae8 <CONFIG_ISR_STACK_SIZE+0x2e8>
		} else if (conv->width_present) {
     c8e:	f99d 3020 	ldrsb.w	r3, [sp, #32]
     c92:	2b00      	cmp	r3, #0
     c94:	db02      	blt.n	c9c <CONFIG_ISR_STACK_SIZE+0x49c>
		int width = -1;
     c96:	f04f 37ff 	mov.w	r7, #4294967295
     c9a:	e725      	b.n	ae8 <CONFIG_ISR_STACK_SIZE+0x2e8>
			width = conv->width_value;
     c9c:	9f09      	ldr	r7, [sp, #36]	; 0x24
     c9e:	e723      	b.n	ae8 <CONFIG_ISR_STACK_SIZE+0x2e8>
				conv->prec_present = false;
     ca0:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     ca4:	f36f 0341 	bfc	r3, #1, #1
     ca8:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
		int precision = -1;
     cac:	f04f 3bff 	mov.w	fp, #4294967295
     cb0:	e729      	b.n	b06 <CONFIG_ISR_STACK_SIZE+0x306>
		} else if (conv->prec_present) {
     cb2:	f013 0f02 	tst.w	r3, #2
     cb6:	d002      	beq.n	cbe <CONFIG_ISR_STACK_SIZE+0x4be>
			precision = conv->prec_value;
     cb8:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
     cbc:	e723      	b.n	b06 <CONFIG_ISR_STACK_SIZE+0x306>
		int precision = -1;
     cbe:	f04f 3bff 	mov.w	fp, #4294967295
     cc2:	e720      	b.n	b06 <CONFIG_ISR_STACK_SIZE+0x306>
			switch (length_mod) {
     cc4:	1ecb      	subs	r3, r1, #3
     cc6:	2b04      	cmp	r3, #4
     cc8:	d804      	bhi.n	cd4 <CONFIG_ISR_STACK_SIZE+0x4d4>
     cca:	e8df f003 	tbb	[pc, r3]
     cce:	1d0b      	.short	0x1d0b
     cd0:	3529      	.short	0x3529
     cd2:	35          	.byte	0x35
     cd3:	00          	.byte	0x00
				value->sint = va_arg(ap, int);
     cd4:	9b03      	ldr	r3, [sp, #12]
     cd6:	1d1a      	adds	r2, r3, #4
     cd8:	9203      	str	r2, [sp, #12]
     cda:	681a      	ldr	r2, [r3, #0]
     cdc:	17d3      	asrs	r3, r2, #31
     cde:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
     ce2:	e006      	b.n	cf2 <CONFIG_ISR_STACK_SIZE+0x4f2>
					value->sint = va_arg(ap, long);
     ce4:	9b03      	ldr	r3, [sp, #12]
     ce6:	1d1a      	adds	r2, r3, #4
     ce8:	9203      	str	r2, [sp, #12]
     cea:	681a      	ldr	r2, [r3, #0]
     cec:	17d3      	asrs	r3, r2, #31
     cee:	e9cd 2306 	strd	r2, r3, [sp, #24]
			if (length_mod == LENGTH_HH) {
     cf2:	2901      	cmp	r1, #1
     cf4:	d028      	beq.n	d48 <CONFIG_ISR_STACK_SIZE+0x548>
			} else if (length_mod == LENGTH_H) {
     cf6:	2902      	cmp	r1, #2
     cf8:	f47f af1c 	bne.w	b34 <CONFIG_ISR_STACK_SIZE+0x334>
				value->sint = (short)value->sint;
     cfc:	f9bd 2018 	ldrsh.w	r2, [sp, #24]
     d00:	17d3      	asrs	r3, r2, #31
     d02:	e9cd 2306 	strd	r2, r3, [sp, #24]
     d06:	e715      	b.n	b34 <CONFIG_ISR_STACK_SIZE+0x334>
					(sint_value_type)va_arg(ap, long long);
     d08:	9b03      	ldr	r3, [sp, #12]
     d0a:	3307      	adds	r3, #7
     d0c:	f023 0307 	bic.w	r3, r3, #7
     d10:	f103 0208 	add.w	r2, r3, #8
     d14:	9203      	str	r2, [sp, #12]
     d16:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
     d1a:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
     d1e:	e7e8      	b.n	cf2 <CONFIG_ISR_STACK_SIZE+0x4f2>
					(sint_value_type)va_arg(ap, intmax_t);
     d20:	9b03      	ldr	r3, [sp, #12]
     d22:	3307      	adds	r3, #7
     d24:	f023 0307 	bic.w	r3, r3, #7
     d28:	f103 0208 	add.w	r2, r3, #8
     d2c:	9203      	str	r2, [sp, #12]
     d2e:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->sint =
     d32:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
     d36:	e7dc      	b.n	cf2 <CONFIG_ISR_STACK_SIZE+0x4f2>
					(sint_value_type)va_arg(ap, ptrdiff_t);
     d38:	9b03      	ldr	r3, [sp, #12]
     d3a:	1d1a      	adds	r2, r3, #4
     d3c:	9203      	str	r2, [sp, #12]
     d3e:	681a      	ldr	r2, [r3, #0]
     d40:	17d3      	asrs	r3, r2, #31
				value->sint =
     d42:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
     d46:	e7d4      	b.n	cf2 <CONFIG_ISR_STACK_SIZE+0x4f2>
				value->sint = (char)value->sint;
     d48:	f89d 3018 	ldrb.w	r3, [sp, #24]
     d4c:	9306      	str	r3, [sp, #24]
     d4e:	2300      	movs	r3, #0
     d50:	9307      	str	r3, [sp, #28]
     d52:	e6ef      	b.n	b34 <CONFIG_ISR_STACK_SIZE+0x334>
			switch (length_mod) {
     d54:	1ecb      	subs	r3, r1, #3
     d56:	2b04      	cmp	r3, #4
     d58:	d804      	bhi.n	d64 <CONFIG_ISR_STACK_SIZE+0x564>
     d5a:	e8df f003 	tbb	[pc, r3]
     d5e:	1f0b      	.short	0x1f0b
     d60:	4135      	.short	0x4135
     d62:	41          	.byte	0x41
     d63:	00          	.byte	0x00
				value->uint = va_arg(ap, unsigned int);
     d64:	9b03      	ldr	r3, [sp, #12]
     d66:	1d1a      	adds	r2, r3, #4
     d68:	9203      	str	r2, [sp, #12]
     d6a:	681b      	ldr	r3, [r3, #0]
     d6c:	9306      	str	r3, [sp, #24]
     d6e:	2300      	movs	r3, #0
     d70:	9307      	str	r3, [sp, #28]
				break;
     d72:	e01e      	b.n	db2 <CONFIG_ISR_STACK_SIZE+0x5b2>
				    && (conv->specifier == 'c')) {
     d74:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
				if ((!WCHAR_IS_SIGNED)
     d78:	2b63      	cmp	r3, #99	; 0x63
     d7a:	d007      	beq.n	d8c <CONFIG_ISR_STACK_SIZE+0x58c>
					value->uint = va_arg(ap, unsigned long);
     d7c:	9b03      	ldr	r3, [sp, #12]
     d7e:	1d1a      	adds	r2, r3, #4
     d80:	9203      	str	r2, [sp, #12]
     d82:	681b      	ldr	r3, [r3, #0]
     d84:	9306      	str	r3, [sp, #24]
     d86:	2300      	movs	r3, #0
     d88:	9307      	str	r3, [sp, #28]
     d8a:	e012      	b.n	db2 <CONFIG_ISR_STACK_SIZE+0x5b2>
					value->uint = (wchar_t)va_arg(ap,
     d8c:	9b03      	ldr	r3, [sp, #12]
     d8e:	1d1a      	adds	r2, r3, #4
     d90:	9203      	str	r2, [sp, #12]
     d92:	681b      	ldr	r3, [r3, #0]
     d94:	9306      	str	r3, [sp, #24]
     d96:	2300      	movs	r3, #0
     d98:	9307      	str	r3, [sp, #28]
     d9a:	e00a      	b.n	db2 <CONFIG_ISR_STACK_SIZE+0x5b2>
					(uint_value_type)va_arg(ap,
     d9c:	9b03      	ldr	r3, [sp, #12]
     d9e:	3307      	adds	r3, #7
     da0:	f023 0307 	bic.w	r3, r3, #7
     da4:	f103 0208 	add.w	r2, r3, #8
     da8:	9203      	str	r2, [sp, #12]
     daa:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
     dae:	e9cd 2306 	strd	r2, r3, [sp, #24]
			if (length_mod == LENGTH_HH) {
     db2:	2901      	cmp	r1, #1
     db4:	d01c      	beq.n	df0 <CONFIG_ISR_STACK_SIZE+0x5f0>
			} else if (length_mod == LENGTH_H) {
     db6:	2902      	cmp	r1, #2
     db8:	f47f aebc 	bne.w	b34 <CONFIG_ISR_STACK_SIZE+0x334>
				value->uint = (unsigned short)value->uint;
     dbc:	f8bd 3018 	ldrh.w	r3, [sp, #24]
     dc0:	9306      	str	r3, [sp, #24]
     dc2:	2300      	movs	r3, #0
     dc4:	9307      	str	r3, [sp, #28]
     dc6:	e6b5      	b.n	b34 <CONFIG_ISR_STACK_SIZE+0x334>
					(uint_value_type)va_arg(ap,
     dc8:	9b03      	ldr	r3, [sp, #12]
     dca:	3307      	adds	r3, #7
     dcc:	f023 0307 	bic.w	r3, r3, #7
     dd0:	f103 0208 	add.w	r2, r3, #8
     dd4:	9203      	str	r2, [sp, #12]
     dd6:	e9d3 2300 	ldrd	r2, r3, [r3]
				value->uint =
     dda:	e9cd 2306 	strd	r2, r3, [sp, #24]
				break;
     dde:	e7e8      	b.n	db2 <CONFIG_ISR_STACK_SIZE+0x5b2>
					(uint_value_type)va_arg(ap, size_t);
     de0:	9b03      	ldr	r3, [sp, #12]
     de2:	1d1a      	adds	r2, r3, #4
     de4:	9203      	str	r2, [sp, #12]
     de6:	681b      	ldr	r3, [r3, #0]
				value->uint =
     de8:	9306      	str	r3, [sp, #24]
     dea:	2300      	movs	r3, #0
     dec:	9307      	str	r3, [sp, #28]
				break;
     dee:	e7e0      	b.n	db2 <CONFIG_ISR_STACK_SIZE+0x5b2>
				value->uint = (unsigned char)value->uint;
     df0:	f89d 3018 	ldrb.w	r3, [sp, #24]
     df4:	9306      	str	r3, [sp, #24]
     df6:	2300      	movs	r3, #0
     df8:	9307      	str	r3, [sp, #28]
     dfa:	e69b      	b.n	b34 <CONFIG_ISR_STACK_SIZE+0x334>
			if (length_mod == LENGTH_UPPER_L) {
     dfc:	2908      	cmp	r1, #8
     dfe:	d00b      	beq.n	e18 <CONFIG_ISR_STACK_SIZE+0x618>
				value->dbl = va_arg(ap, double);
     e00:	9b03      	ldr	r3, [sp, #12]
     e02:	3307      	adds	r3, #7
     e04:	f023 0307 	bic.w	r3, r3, #7
     e08:	f103 0208 	add.w	r2, r3, #8
     e0c:	9203      	str	r2, [sp, #12]
     e0e:	e9d3 2300 	ldrd	r2, r3, [r3]
     e12:	e9cd 2306 	strd	r2, r3, [sp, #24]
     e16:	e68d      	b.n	b34 <CONFIG_ISR_STACK_SIZE+0x334>
				value->ldbl = va_arg(ap, long double);
     e18:	9b03      	ldr	r3, [sp, #12]
     e1a:	3307      	adds	r3, #7
     e1c:	f023 0307 	bic.w	r3, r3, #7
     e20:	f103 0208 	add.w	r2, r3, #8
     e24:	9203      	str	r2, [sp, #12]
     e26:	e9d3 2300 	ldrd	r2, r3, [r3]
     e2a:	e9cd 2306 	strd	r2, r3, [sp, #24]
     e2e:	e681      	b.n	b34 <CONFIG_ISR_STACK_SIZE+0x334>
			value->ptr = va_arg(ap, void *);
     e30:	9b03      	ldr	r3, [sp, #12]
     e32:	1d1a      	adds	r2, r3, #4
     e34:	9203      	str	r2, [sp, #12]
     e36:	681b      	ldr	r3, [r3, #0]
     e38:	9306      	str	r3, [sp, #24]
     e3a:	e67b      	b.n	b34 <CONFIG_ISR_STACK_SIZE+0x334>
			OUTS(sp, fp);
     e3c:	4643      	mov	r3, r8
     e3e:	4652      	mov	r2, sl
     e40:	4629      	mov	r1, r5
     e42:	4630      	mov	r0, r6
     e44:	f005 f8b2 	bl	5fac <outs>
     e48:	2800      	cmp	r0, #0
     e4a:	f2c0 814f 	blt.w	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
     e4e:	4404      	add	r4, r0
		fp = extract_conversion(conv, sp);
     e50:	46c2      	mov	sl, r8
			continue;
     e52:	e46f      	b.n	734 <cbvprintf+0x10>
		case '%':
			OUTC('%');
     e54:	4629      	mov	r1, r5
     e56:	2025      	movs	r0, #37	; 0x25
     e58:	47b0      	blx	r6
     e5a:	2800      	cmp	r0, #0
     e5c:	f2c0 8146 	blt.w	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
     e60:	3401      	adds	r4, #1
		char sign = 0;
     e62:	f8dd 9008 	ldr.w	r9, [sp, #8]
		const char *bpe = buf + sizeof(buf);
     e66:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
		const char *bps = NULL;
     e6a:	f04f 0a00 	mov.w	sl, #0
			break;
     e6e:	e0a7      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
		case 's': {
			bps = (const char *)value->ptr;
     e70:	f8dd a018 	ldr.w	sl, [sp, #24]

			size_t len;

			if (precision >= 0) {
     e74:	f1bb 0f00 	cmp.w	fp, #0
     e78:	db08      	blt.n	e8c <CONFIG_ISR_STACK_SIZE+0x68c>
				len = strnlen(bps, precision);
     e7a:	4659      	mov	r1, fp
     e7c:	4650      	mov	r0, sl
     e7e:	f005 fdd4 	bl	6a2a <strnlen>
			} else {
				len = strlen(bps);
			}

			bpe = bps + len;
     e82:	eb0a 0b00 	add.w	fp, sl, r0
		char sign = 0;
     e86:	f8dd 9008 	ldr.w	r9, [sp, #8]
			precision = -1;

			break;
     e8a:	e099      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
				len = strlen(bps);
     e8c:	4650      	mov	r0, sl
     e8e:	f005 fdc4 	bl	6a1a <strlen>
     e92:	e7f6      	b.n	e82 <CONFIG_ISR_STACK_SIZE+0x682>
		}
		case 'c':
			bps = buf;
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
     e94:	9b06      	ldr	r3, [sp, #24]
     e96:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
		char sign = 0;
     e9a:	f8dd 9008 	ldr.w	r9, [sp, #8]
			bpe = buf + 1;
     e9e:	f10d 0b31 	add.w	fp, sp, #49	; 0x31
			bps = buf;
     ea2:	f10d 0a30 	add.w	sl, sp, #48	; 0x30
			break;
     ea6:	e08b      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
		case 'd':
		case 'i':
			if (conv->flag_plus) {
     ea8:	f019 0f08 	tst.w	r9, #8
     eac:	d105      	bne.n	eba <CONFIG_ISR_STACK_SIZE+0x6ba>
				sign = '+';
			} else if (conv->flag_space) {
     eae:	f019 0910 	ands.w	r9, r9, #16
     eb2:	d004      	beq.n	ebe <CONFIG_ISR_STACK_SIZE+0x6be>
				sign = ' ';
     eb4:	f04f 0920 	mov.w	r9, #32
     eb8:	e001      	b.n	ebe <CONFIG_ISR_STACK_SIZE+0x6be>
				sign = '+';
     eba:	f04f 092b 	mov.w	r9, #43	; 0x2b

			/* sint/uint overlay in the union, and so
			 * can't appear in read and write operations
			 * in the same statement.
			 */
			sint = value->sint;
     ebe:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
			if (sint < 0) {
     ec2:	2a00      	cmp	r2, #0
     ec4:	f173 0100 	sbcs.w	r1, r3, #0
     ec8:	db02      	blt.n	ed0 <CONFIG_ISR_STACK_SIZE+0x6d0>
				sign = '-';
				value->uint = (uint_value_type)-sint;
			} else {
				value->uint = (uint_value_type)sint;
     eca:	e9cd 2306 	strd	r2, r3, [sp, #24]
     ece:	e009      	b.n	ee4 <CONFIG_ISR_STACK_SIZE+0x6e4>
				value->uint = (uint_value_type)-sint;
     ed0:	4252      	negs	r2, r2
     ed2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
     ed6:	e9cd 2306 	strd	r2, r3, [sp, #24]
				sign = '-';
     eda:	f04f 092d 	mov.w	r9, #45	; 0x2d
     ede:	e001      	b.n	ee4 <CONFIG_ISR_STACK_SIZE+0x6e4>
		switch (conv->specifier) {
     ee0:	f8dd 9008 	ldr.w	r9, [sp, #8]
			__fallthrough;
		case 'o':
		case 'u':
		case 'x':
		case 'X':
			bps = encode_uint(value->uint, conv, buf, bpe);
     ee4:	f10d 0346 	add.w	r3, sp, #70	; 0x46
     ee8:	9300      	str	r3, [sp, #0]
     eea:	ab0c      	add	r3, sp, #48	; 0x30
     eec:	aa08      	add	r2, sp, #32
     eee:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
     ef2:	f004 fff1 	bl	5ed8 <encode_uint>
     ef6:	4682      	mov	sl, r0
			/* Update pad0 values based on precision and converted
			 * length.  Note that a non-empty sign is not in the
			 * converted sequence, but it does not affect the
			 * padding size.
			 */
			if (precision >= 0) {
     ef8:	f1bb 0f00 	cmp.w	fp, #0
     efc:	f2c0 8090 	blt.w	1020 <CONFIG_FPROTECT_BLOCK_SIZE+0x20>
				size_t len = bpe - bps;
     f00:	f10d 0346 	add.w	r3, sp, #70	; 0x46
     f04:	eba3 030a 	sub.w	r3, r3, sl

				/* Zero-padding flag is ignored for integer
				 * conversions with precision.
				 */
				conv->flag_zero = false;
     f08:	f89d 2020 	ldrb.w	r2, [sp, #32]
     f0c:	f36f 1286 	bfc	r2, #6, #1
     f10:	f88d 2020 	strb.w	r2, [sp, #32]

				/* Set pad0_value to satisfy precision */
				if (len < (size_t)precision) {
     f14:	459b      	cmp	fp, r3
     f16:	f240 8086 	bls.w	1026 <CONFIG_FPROTECT_BLOCK_SIZE+0x26>
					conv->pad0_value = precision - (int)len;
     f1a:	ebab 0303 	sub.w	r3, fp, r3
     f1e:	9309      	str	r3, [sp, #36]	; 0x24
		const char *bpe = buf + sizeof(buf);
     f20:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
     f24:	e04c      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
		case 'p':
			/* Implementation-defined: null is "(nil)", non-null
			 * has 0x prefix followed by significant address hex
			 * digits, no leading zeros.
			 */
			if (value->ptr != NULL) {
     f26:	9806      	ldr	r0, [sp, #24]
     f28:	b930      	cbnz	r0, f38 <CONFIG_ISR_STACK_SIZE+0x738>
		char sign = 0;
     f2a:	f8dd 9008 	ldr.w	r9, [sp, #8]

				goto prec_int_pad0;
			}

			bps = "(nil)";
			bpe = bps + 5;
     f2e:	f8df b1c4 	ldr.w	fp, [pc, #452]	; 10f4 <CONFIG_FPROTECT_BLOCK_SIZE+0xf4>
			bps = "(nil)";
     f32:	f1ab 0a05 	sub.w	sl, fp, #5
     f36:	e043      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
				bps = encode_uint((uintptr_t)value->ptr, conv,
     f38:	f10d 0346 	add.w	r3, sp, #70	; 0x46
     f3c:	9300      	str	r3, [sp, #0]
     f3e:	ab0c      	add	r3, sp, #48	; 0x30
     f40:	aa08      	add	r2, sp, #32
     f42:	2100      	movs	r1, #0
     f44:	f004 ffc8 	bl	5ed8 <encode_uint>
     f48:	4682      	mov	sl, r0
				conv->altform_0c = true;
     f4a:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
     f4e:	f043 0310 	orr.w	r3, r3, #16
     f52:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
				conv->specifier = 'x';
     f56:	2378      	movs	r3, #120	; 0x78
     f58:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
		char sign = 0;
     f5c:	f8dd 9008 	ldr.w	r9, [sp, #8]
				goto prec_int_pad0;
     f60:	e7ca      	b.n	ef8 <CONFIG_ISR_STACK_SIZE+0x6f8>

			break;
		case 'n':
			if (IS_ENABLED(CONFIG_CBPRINTF_N_SPECIFIER)) {
				store_count(conv, value->ptr, count);
     f62:	9a06      	ldr	r2, [sp, #24]
	switch ((enum length_mod_enum)conv->length_mod) {
     f64:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
     f68:	f3c3 03c3 	ubfx	r3, r3, #3, #4
     f6c:	2b07      	cmp	r3, #7
     f6e:	d806      	bhi.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
     f70:	e8df f003 	tbb	[pc, r3]
     f74:	100e0c04 	.word	0x100e0c04
     f78:	1e1c1712 	.word	0x1e1c1712
		*(int *)dp = count;
     f7c:	6014      	str	r4, [r2, #0]
		char sign = 0;
     f7e:	f8dd 9008 	ldr.w	r9, [sp, #8]
		const char *bpe = buf + sizeof(buf);
     f82:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
		const char *bps = NULL;
     f86:	f04f 0a00 	mov.w	sl, #0
}
     f8a:	e019      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
		*(signed char *)dp = (signed char)count;
     f8c:	7014      	strb	r4, [r2, #0]
		break;
     f8e:	e7f6      	b.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
		*(short *)dp = (short)count;
     f90:	8014      	strh	r4, [r2, #0]
		break;
     f92:	e7f4      	b.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
		*(long *)dp = (long)count;
     f94:	6014      	str	r4, [r2, #0]
		break;
     f96:	e7f2      	b.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
		*(long long *)dp = (long long)count;
     f98:	4620      	mov	r0, r4
     f9a:	17e1      	asrs	r1, r4, #31
     f9c:	e9c2 0100 	strd	r0, r1, [r2]
		break;
     fa0:	e7ed      	b.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
		*(intmax_t *)dp = (intmax_t)count;
     fa2:	4620      	mov	r0, r4
     fa4:	17e1      	asrs	r1, r4, #31
     fa6:	e9c2 0100 	strd	r0, r1, [r2]
		break;
     faa:	e7e8      	b.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
		*(size_t *)dp = (size_t)count;
     fac:	6014      	str	r4, [r2, #0]
		break;
     fae:	e7e6      	b.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
     fb0:	6014      	str	r4, [r2, #0]
		break;
     fb2:	e7e4      	b.n	f7e <CONFIG_ISR_STACK_SIZE+0x77e>
		switch (conv->specifier) {
     fb4:	f8dd 9008 	ldr.w	r9, [sp, #8]
     fb8:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
     fbc:	f04f 0a00 	mov.w	sl, #0
		}

		/* If we don't have a converted value to emit, move
		 * on.
		 */
		if (bps == NULL) {
     fc0:	f1ba 0f00 	cmp.w	sl, #0
     fc4:	f000 808e 	beq.w	10e4 <CONFIG_FPROTECT_BLOCK_SIZE+0xe4>
		 *   * any exponent content from the converted value
		 * * for non-FP:
		 *   * any pad0_prefix
		 *   * the converted value
		 */
		size_t nj_len = (bpe - bps);
     fc8:	ebab 020a 	sub.w	r2, fp, sl
		int pad_len = 0;

		if (sign != 0) {
     fcc:	f1b9 0f00 	cmp.w	r9, #0
     fd0:	d000      	beq.n	fd4 <CONFIG_ISR_STACK_SIZE+0x7d4>
			nj_len += 1U;
     fd2:	3201      	adds	r2, #1
		}

		if (conv->altform_0c) {
     fd4:	f89d 1022 	ldrb.w	r1, [sp, #34]	; 0x22
     fd8:	f011 0f10 	tst.w	r1, #16
     fdc:	d026      	beq.n	102c <CONFIG_FPROTECT_BLOCK_SIZE+0x2c>
			nj_len += 2U;
     fde:	3202      	adds	r2, #2
		} else if (conv->altform_0) {
			nj_len += 1U;
		}

		nj_len += conv->pad0_value;
     fe0:	9b09      	ldr	r3, [sp, #36]	; 0x24
     fe2:	4413      	add	r3, r2
		if (conv->pad_fp) {
     fe4:	f011 0f40 	tst.w	r1, #64	; 0x40
     fe8:	d001      	beq.n	fee <CONFIG_ISR_STACK_SIZE+0x7ee>
			nj_len += conv->pad0_pre_exp;
     fea:	9a0a      	ldr	r2, [sp, #40]	; 0x28
     fec:	4413      	add	r3, r2
		 * result in no padding.
		 *
		 * If a non-negative padding width is present and we're doing
		 * right-justification, emit the padding now.
		 */
		if (width > 0) {
     fee:	2f00      	cmp	r7, #0
     ff0:	dd32      	ble.n	1058 <CONFIG_FPROTECT_BLOCK_SIZE+0x58>
			width -= (int)nj_len;
     ff2:	1aff      	subs	r7, r7, r3

			if (!conv->flag_dash) {
     ff4:	f89d 3020 	ldrb.w	r3, [sp, #32]
     ff8:	f013 0f04 	tst.w	r3, #4
     ffc:	d12c      	bne.n	1058 <CONFIG_FPROTECT_BLOCK_SIZE+0x58>
				char pad = ' ';

				/* If we're zero-padding we have to emit the
				 * sign first.
				 */
				if (conv->flag_zero) {
     ffe:	f013 0f40 	tst.w	r3, #64	; 0x40
    1002:	d018      	beq.n	1036 <CONFIG_FPROTECT_BLOCK_SIZE+0x36>
					if (sign != 0) {
    1004:	f1b9 0f00 	cmp.w	r9, #0
    1008:	d018      	beq.n	103c <CONFIG_FPROTECT_BLOCK_SIZE+0x3c>
						OUTC(sign);
    100a:	4629      	mov	r1, r5
    100c:	4648      	mov	r0, r9
    100e:	47b0      	blx	r6
    1010:	2800      	cmp	r0, #0
    1012:	db6b      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    1014:	3401      	adds	r4, #1
						sign = 0;
    1016:	f8dd 9008 	ldr.w	r9, [sp, #8]
					}
					pad = '0';
    101a:	2330      	movs	r3, #48	; 0x30
    101c:	9302      	str	r3, [sp, #8]
    101e:	e00f      	b.n	1040 <CONFIG_FPROTECT_BLOCK_SIZE+0x40>
		const char *bpe = buf + sizeof(buf);
    1020:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
    1024:	e7cc      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
    1026:	f10d 0b46 	add.w	fp, sp, #70	; 0x46
    102a:	e7c9      	b.n	fc0 <CONFIG_ISR_STACK_SIZE+0x7c0>
		} else if (conv->altform_0) {
    102c:	f011 0f08 	tst.w	r1, #8
    1030:	d0d6      	beq.n	fe0 <CONFIG_ISR_STACK_SIZE+0x7e0>
			nj_len += 1U;
    1032:	3201      	adds	r2, #1
    1034:	e7d4      	b.n	fe0 <CONFIG_ISR_STACK_SIZE+0x7e0>
				char pad = ' ';
    1036:	2320      	movs	r3, #32
    1038:	9302      	str	r3, [sp, #8]
    103a:	e001      	b.n	1040 <CONFIG_FPROTECT_BLOCK_SIZE+0x40>
					pad = '0';
    103c:	2330      	movs	r3, #48	; 0x30
    103e:	9302      	str	r3, [sp, #8]
    1040:	463b      	mov	r3, r7
				}

				while (width-- > 0) {
    1042:	1e5f      	subs	r7, r3, #1
    1044:	2b00      	cmp	r3, #0
    1046:	dd07      	ble.n	1058 <CONFIG_FPROTECT_BLOCK_SIZE+0x58>
					OUTC(pad);
    1048:	4629      	mov	r1, r5
    104a:	9802      	ldr	r0, [sp, #8]
    104c:	47b0      	blx	r6
    104e:	2800      	cmp	r0, #0
    1050:	db4c      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    1052:	3401      	adds	r4, #1
				while (width-- > 0) {
    1054:	463b      	mov	r3, r7
    1056:	e7f4      	b.n	1042 <CONFIG_FPROTECT_BLOCK_SIZE+0x42>
		}

		/* If we have a sign that hasn't been emitted, now's the
		 * time....
		 */
		if (sign != 0) {
    1058:	f1b9 0f00 	cmp.w	r9, #0
    105c:	d005      	beq.n	106a <CONFIG_FPROTECT_BLOCK_SIZE+0x6a>
			OUTC(sign);
    105e:	4629      	mov	r1, r5
    1060:	4648      	mov	r0, r9
    1062:	47b0      	blx	r6
    1064:	2800      	cmp	r0, #0
    1066:	db41      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    1068:	3401      	adds	r4, #1
				OUTC('0');
			}

			OUTS(cp, bpe);
		} else {
			if (conv->altform_0c | conv->altform_0) {
    106a:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    106e:	f3c3 1200 	ubfx	r2, r3, #4, #1
    1072:	f3c3 03c0 	ubfx	r3, r3, #3, #1
    1076:	4313      	orrs	r3, r2
    1078:	d005      	beq.n	1086 <CONFIG_FPROTECT_BLOCK_SIZE+0x86>
				OUTC('0');
    107a:	4629      	mov	r1, r5
    107c:	2030      	movs	r0, #48	; 0x30
    107e:	47b0      	blx	r6
    1080:	2800      	cmp	r0, #0
    1082:	db33      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    1084:	3401      	adds	r4, #1
			}

			if (conv->altform_0c) {
    1086:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    108a:	f013 0f10 	tst.w	r3, #16
    108e:	d006      	beq.n	109e <CONFIG_FPROTECT_BLOCK_SIZE+0x9e>
				OUTC(conv->specifier);
    1090:	4629      	mov	r1, r5
    1092:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    1096:	47b0      	blx	r6
    1098:	2800      	cmp	r0, #0
    109a:	db27      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    109c:	3401      	adds	r4, #1
			}

			pad_len = conv->pad0_value;
    109e:	9b09      	ldr	r3, [sp, #36]	; 0x24
			while (pad_len-- > 0) {
    10a0:	f103 39ff 	add.w	r9, r3, #4294967295
    10a4:	2b00      	cmp	r3, #0
    10a6:	dd07      	ble.n	10b8 <CONFIG_FPROTECT_BLOCK_SIZE+0xb8>
				OUTC('0');
    10a8:	4629      	mov	r1, r5
    10aa:	2030      	movs	r0, #48	; 0x30
    10ac:	47b0      	blx	r6
    10ae:	2800      	cmp	r0, #0
    10b0:	db1c      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    10b2:	3401      	adds	r4, #1
			while (pad_len-- > 0) {
    10b4:	464b      	mov	r3, r9
    10b6:	e7f3      	b.n	10a0 <CONFIG_FPROTECT_BLOCK_SIZE+0xa0>
			}

			OUTS(bps, bpe);
    10b8:	465b      	mov	r3, fp
    10ba:	4652      	mov	r2, sl
    10bc:	4629      	mov	r1, r5
    10be:	4630      	mov	r0, r6
    10c0:	f004 ff74 	bl	5fac <outs>
    10c4:	2800      	cmp	r0, #0
    10c6:	db11      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    10c8:	4404      	add	r4, r0
		}

		/* Finish left justification */
		while (width > 0) {
    10ca:	2f00      	cmp	r7, #0
    10cc:	dd07      	ble.n	10de <CONFIG_FPROTECT_BLOCK_SIZE+0xde>
			OUTC(' ');
    10ce:	4629      	mov	r1, r5
    10d0:	2020      	movs	r0, #32
    10d2:	47b0      	blx	r6
    10d4:	2800      	cmp	r0, #0
    10d6:	db09      	blt.n	10ec <CONFIG_FPROTECT_BLOCK_SIZE+0xec>
    10d8:	3401      	adds	r4, #1
			--width;
    10da:	3f01      	subs	r7, #1
    10dc:	e7f5      	b.n	10ca <CONFIG_FPROTECT_BLOCK_SIZE+0xca>
		fp = extract_conversion(conv, sp);
    10de:	46c2      	mov	sl, r8
    10e0:	f7ff bb28 	b.w	734 <cbvprintf+0x10>
    10e4:	46c2      	mov	sl, r8
    10e6:	f7ff bb25 	b.w	734 <cbvprintf+0x10>
		}
	}

	return count;
    10ea:	4620      	mov	r0, r4
#undef OUTS
#undef OUTC
}
    10ec:	b013      	add	sp, #76	; 0x4c
    10ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    10f2:	bf00      	nop
    10f4:	00007b5d 	.word	0x00007b5d

000010f8 <is_rodata>:
#else
	#define RO_START 0
	#define RO_END 0
#endif

	return (((const char *)addr >= (const char *)RO_START) &&
    10f8:	4b05      	ldr	r3, [pc, #20]	; (1110 <is_rodata+0x18>)
    10fa:	4298      	cmp	r0, r3
    10fc:	d304      	bcc.n	1108 <is_rodata+0x10>
    10fe:	4b05      	ldr	r3, [pc, #20]	; (1114 <is_rodata+0x1c>)
    1100:	4298      	cmp	r0, r3
    1102:	d303      	bcc.n	110c <is_rodata+0x14>
    1104:	2000      	movs	r0, #0
    1106:	4770      	bx	lr
    1108:	2000      	movs	r0, #0
    110a:	4770      	bx	lr
    110c:	2001      	movs	r0, #1
		((const char *)addr < (const char *)RO_END));
}
    110e:	4770      	bx	lr
    1110:	000077dc 	.word	0x000077dc
    1114:	000083fc 	.word	0x000083fc

00001118 <thread_set>:
		}
	}
}

static void thread_set(k_tid_t process_tid)
{
    1118:	b508      	push	{r3, lr}
	proc_tid = process_tid;
    111a:	4b06      	ldr	r3, [pc, #24]	; (1134 <thread_set+0x1c>)
    111c:	6018      	str	r0, [r3, #0]

	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE)) {
		return;
	}

	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
    111e:	b118      	cbz	r0, 1128 <thread_set+0x10>
	    process_tid &&
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
    1120:	4b05      	ldr	r3, [pc, #20]	; (1138 <thread_set+0x20>)
    1122:	681b      	ldr	r3, [r3, #0]
	    process_tid &&
    1124:	2b09      	cmp	r3, #9
    1126:	dc00      	bgt.n	112a <thread_set+0x12>
		k_sem_give(&log_process_thread_sem);
	}
}
    1128:	bd08      	pop	{r3, pc}
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
    112a:	4804      	ldr	r0, [pc, #16]	; (113c <thread_set+0x24>)
    112c:	f003 fcf8 	bl	4b20 <z_impl_k_sem_give>
}
    1130:	e7fa      	b.n	1128 <thread_set+0x10>
    1132:	bf00      	nop
    1134:	200003e4 	.word	0x200003e4
    1138:	200003b4 	.word	0x200003b4
    113c:	20000044 	.word	0x20000044

00001140 <log_process_thread_timer_expiry_fn>:
{
	return mpsc_pbuf_is_pending(&log_buffer);
}

static void log_process_thread_timer_expiry_fn(struct k_timer *timer)
{
    1140:	b508      	push	{r3, lr}
	z_impl_k_sem_give(sem);
    1142:	4802      	ldr	r0, [pc, #8]	; (114c <log_process_thread_timer_expiry_fn+0xc>)
    1144:	f003 fcec 	bl	4b20 <z_impl_k_sem_give>
	k_sem_give(&log_process_thread_sem);
}
    1148:	bd08      	pop	{r3, pc}
    114a:	bf00      	nop
    114c:	20000044 	.word	0x20000044

00001150 <next_pending>:
{
    1150:	b508      	push	{r3, lr}
	return (log_list_head_peek(&list) != NULL);
    1152:	4803      	ldr	r0, [pc, #12]	; (1160 <next_pending+0x10>)
    1154:	f004 ff53 	bl	5ffe <log_list_head_peek>
}
    1158:	3800      	subs	r0, #0
    115a:	bf18      	it	ne
    115c:	2001      	movne	r0, #1
    115e:	bd08      	pop	{r3, pc}
    1160:	200003c0 	.word	0x200003c0

00001164 <enable_logger>:

K_KERNEL_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(const struct device *arg)
{
    1164:	b530      	push	{r4, r5, lr}
    1166:	b089      	sub	sp, #36	; 0x24
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
    1168:	2200      	movs	r2, #0
    116a:	490f      	ldr	r1, [pc, #60]	; (11a8 <enable_logger+0x44>)
    116c:	480f      	ldr	r0, [pc, #60]	; (11ac <enable_logger+0x48>)
    116e:	f006 fb07 	bl	7780 <k_timer_init>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    1172:	4d0f      	ldr	r5, [pc, #60]	; (11b0 <enable_logger+0x4c>)
    1174:	2200      	movs	r2, #0
    1176:	2300      	movs	r3, #0
    1178:	e9cd 2306 	strd	r2, r3, [sp, #24]
    117c:	2400      	movs	r4, #0
    117e:	9404      	str	r4, [sp, #16]
    1180:	230e      	movs	r3, #14
    1182:	9303      	str	r3, [sp, #12]
    1184:	9402      	str	r4, [sp, #8]
    1186:	9401      	str	r4, [sp, #4]
    1188:	9400      	str	r4, [sp, #0]
    118a:	4b0a      	ldr	r3, [pc, #40]	; (11b4 <enable_logger+0x50>)
    118c:	f44f 7240 	mov.w	r2, #768	; 0x300
    1190:	4909      	ldr	r1, [pc, #36]	; (11b8 <enable_logger+0x54>)
    1192:	4628      	mov	r0, r5
    1194:	f006 f88f 	bl	72b6 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread, str);
    1198:	4908      	ldr	r1, [pc, #32]	; (11bc <enable_logger+0x58>)
    119a:	4628      	mov	r0, r5
    119c:	f003 fb0e 	bl	47bc <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
    11a0:	4620      	mov	r0, r4
    11a2:	b009      	add	sp, #36	; 0x24
    11a4:	bd30      	pop	{r4, r5, pc}
    11a6:	bf00      	nop
    11a8:	00001141 	.word	0x00001141
    11ac:	20000058 	.word	0x20000058
    11b0:	20000090 	.word	0x20000090
    11b4:	00001885 	.word	0x00001885
    11b8:	20000a80 	.word	0x20000a80
    11bc:	00007b60 	.word	0x00007b60

000011c0 <log_core_init>:
{
    11c0:	b508      	push	{r3, lr}
	panic_mode = false;
    11c2:	4b0b      	ldr	r3, [pc, #44]	; (11f0 <log_core_init+0x30>)
    11c4:	2200      	movs	r2, #0
    11c6:	701a      	strb	r2, [r3, #0]
		timestamp_func = default_get_timestamp;
    11c8:	4b0a      	ldr	r3, [pc, #40]	; (11f4 <log_core_init+0x34>)
    11ca:	4a0b      	ldr	r2, [pc, #44]	; (11f8 <log_core_init+0x38>)
    11cc:	601a      	str	r2, [r3, #0]
	log_output_timestamp_freq_set(freq);
    11ce:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    11d2:	f000 fdb5 	bl	1d40 <log_output_timestamp_freq_set>
		log_msg_pool_init();
    11d6:	f000 fb99 	bl	190c <log_msg_pool_init>
		log_list_init(&list);
    11da:	4808      	ldr	r0, [pc, #32]	; (11fc <log_core_init+0x3c>)
    11dc:	f004 ff01 	bl	5fe2 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
    11e0:	2304      	movs	r3, #4
    11e2:	2228      	movs	r2, #40	; 0x28
    11e4:	4906      	ldr	r1, [pc, #24]	; (1200 <log_core_init+0x40>)
    11e6:	4807      	ldr	r0, [pc, #28]	; (1204 <log_core_init+0x44>)
    11e8:	f006 f802 	bl	71f0 <k_mem_slab_init>
}
    11ec:	bd08      	pop	{r3, pc}
    11ee:	bf00      	nop
    11f0:	20000a71 	.word	0x20000a71
    11f4:	20000004 	.word	0x20000004
    11f8:	00006017 	.word	0x00006017
    11fc:	200003c0 	.word	0x200003c0
    1200:	20001f60 	.word	0x20001f60
    1204:	200003c8 	.word	0x200003c8

00001208 <get_msg>:
{
    1208:	b510      	push	{r4, lr}
    120a:	f04f 0320 	mov.w	r3, #32
    120e:	f3ef 8411 	mrs	r4, BASEPRI
    1212:	f383 8811 	msr	BASEPRI, r3
    1216:	f3bf 8f6f 	isb	sy
	msg.msg = log_list_head_get(&list);
    121a:	4804      	ldr	r0, [pc, #16]	; (122c <get_msg+0x24>)
    121c:	f004 fef1 	bl	6002 <log_list_head_get>
	__asm__ volatile(
    1220:	f384 8811 	msr	BASEPRI, r4
    1224:	f3bf 8f6f 	isb	sy
}
    1228:	bd10      	pop	{r4, pc}
    122a:	bf00      	nop
    122c:	200003c0 	.word	0x200003c0

00001230 <z_log_dropped>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_add(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    1230:	4b06      	ldr	r3, [pc, #24]	; (124c <z_log_dropped+0x1c>)
    1232:	f3bf 8f5b 	dmb	ish
    1236:	e853 2f00 	ldrex	r2, [r3]
    123a:	3201      	adds	r2, #1
    123c:	e843 2100 	strex	r1, r2, [r3]
    1240:	2900      	cmp	r1, #0
    1242:	d1f8      	bne.n	1236 <z_log_dropped+0x6>
    1244:	f3bf 8f5b 	dmb	ish
}
    1248:	4770      	bx	lr
    124a:	bf00      	nop
    124c:	200003b8 	.word	0x200003b8

00001250 <z_log_dropped_read_and_clear>:
{
	/* This builtin, as described by Intel, is not a traditional
	 * test-and-set operation, but rather an atomic exchange operation. It
	 * writes value into *ptr, and returns the previous contents of *ptr.
	 */
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    1250:	4b06      	ldr	r3, [pc, #24]	; (126c <z_log_dropped_read_and_clear+0x1c>)
}
    1252:	2000      	movs	r0, #0
    1254:	4602      	mov	r2, r0
    1256:	f3bf 8f5b 	dmb	ish
    125a:	e853 0f00 	ldrex	r0, [r3]
    125e:	e843 2100 	strex	r1, r2, [r3]
    1262:	2900      	cmp	r1, #0
    1264:	d1f9      	bne.n	125a <z_log_dropped_read_and_clear+0xa>
    1266:	f3bf 8f5b 	dmb	ish
    126a:	4770      	bx	lr
    126c:	200003b8 	.word	0x200003b8

00001270 <dropped_notify>:
{
    1270:	b538      	push	{r3, r4, r5, lr}
	uint32_t dropped = z_log_dropped_read_and_clear();
    1272:	f7ff ffed 	bl	1250 <z_log_dropped_read_and_clear>
    1276:	4605      	mov	r5, r0
	for (int i = 0; i < log_backend_count_get(); i++) {
    1278:	2400      	movs	r4, #0
    127a:	e000      	b.n	127e <dropped_notify+0xe>
    127c:	3401      	adds	r4, #1
    127e:	4b0b      	ldr	r3, [pc, #44]	; (12ac <dropped_notify+0x3c>)
    1280:	4a0b      	ldr	r2, [pc, #44]	; (12b0 <dropped_notify+0x40>)
    1282:	1a9b      	subs	r3, r3, r2
    1284:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1288:	da0f      	bge.n	12aa <dropped_notify+0x3a>
 *
 * @return    Pointer to the backend instance.
 */
static inline const struct log_backend *log_backend_get(uint32_t idx)
{
	return &__log_backends_start[idx];
    128a:	4809      	ldr	r0, [pc, #36]	; (12b0 <dropped_notify+0x40>)
    128c:	eb00 1004 	add.w	r0, r0, r4, lsl #4
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
    1290:	6843      	ldr	r3, [r0, #4]
    1292:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    1294:	2b00      	cmp	r3, #0
    1296:	d0f1      	beq.n	127c <dropped_notify+0xc>
	if (backend->api->dropped != NULL) {
    1298:	0123      	lsls	r3, r4, #4
    129a:	4a05      	ldr	r2, [pc, #20]	; (12b0 <dropped_notify+0x40>)
    129c:	58d3      	ldr	r3, [r2, r3]
    129e:	691b      	ldr	r3, [r3, #16]
    12a0:	2b00      	cmp	r3, #0
    12a2:	d0eb      	beq.n	127c <dropped_notify+0xc>
		backend->api->dropped(backend, cnt);
    12a4:	4629      	mov	r1, r5
    12a6:	4798      	blx	r3
    12a8:	e7e8      	b.n	127c <dropped_notify+0xc>
}
    12aa:	bd38      	pop	{r3, r4, r5, pc}
    12ac:	00007a24 	.word	0x00007a24
    12b0:	00007a04 	.word	0x00007a04

000012b4 <z_log_dropped_pending>:
	return dropped_cnt > 0;
    12b4:	4b03      	ldr	r3, [pc, #12]	; (12c4 <z_log_dropped_pending+0x10>)
    12b6:	6818      	ldr	r0, [r3, #0]
}
    12b8:	2800      	cmp	r0, #0
    12ba:	bfd4      	ite	le
    12bc:	2000      	movle	r0, #0
    12be:	2001      	movgt	r0, #1
    12c0:	4770      	bx	lr
    12c2:	bf00      	nop
    12c4:	200003b8 	.word	0x200003b8

000012c8 <log_source_name_get>:
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
    12c8:	4b05      	ldr	r3, [pc, #20]	; (12e0 <log_source_name_get+0x18>)
    12ca:	4a06      	ldr	r2, [pc, #24]	; (12e4 <log_source_name_get+0x1c>)
    12cc:	1a9b      	subs	r3, r3, r2
    12ce:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
    12d2:	d202      	bcs.n	12da <log_source_name_get+0x12>
 * @param source_id Source ID.
 * @return Name.
 */
static inline const char *log_name_get(uint32_t source_id)
{
	return __log_const_start[source_id].name;
    12d4:	f852 0031 	ldr.w	r0, [r2, r1, lsl #3]
    12d8:	4770      	bx	lr
    12da:	2000      	movs	r0, #0
}
    12dc:	4770      	bx	lr
    12de:	bf00      	nop
    12e0:	00007a04 	.word	0x00007a04
    12e4:	000079c4 	.word	0x000079c4

000012e8 <log_backend_enable>:
{
    12e8:	b508      	push	{r3, lr}
	id += backend - log_backend_get(0);
    12ea:	4b0b      	ldr	r3, [pc, #44]	; (1318 <log_backend_enable+0x30>)
    12ec:	1ac3      	subs	r3, r0, r3
    12ee:	111b      	asrs	r3, r3, #4
    12f0:	3301      	adds	r3, #1
	backend->cb->id = id;
    12f2:	6842      	ldr	r2, [r0, #4]
    12f4:	7113      	strb	r3, [r2, #4]
	backend->cb->ctx = ctx;
    12f6:	6843      	ldr	r3, [r0, #4]
    12f8:	6019      	str	r1, [r3, #0]
	backend->cb->active = true;
    12fa:	6843      	ldr	r3, [r0, #4]
    12fc:	2201      	movs	r2, #1
    12fe:	715a      	strb	r2, [r3, #5]
	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD) && !backend_attached) {
    1300:	4b06      	ldr	r3, [pc, #24]	; (131c <log_backend_enable+0x34>)
    1302:	781b      	ldrb	r3, [r3, #0]
    1304:	b11b      	cbz	r3, 130e <log_backend_enable+0x26>
	backend_attached = true;
    1306:	4b05      	ldr	r3, [pc, #20]	; (131c <log_backend_enable+0x34>)
    1308:	2201      	movs	r2, #1
    130a:	701a      	strb	r2, [r3, #0]
}
    130c:	bd08      	pop	{r3, pc}
	z_impl_k_sem_give(sem);
    130e:	4804      	ldr	r0, [pc, #16]	; (1320 <log_backend_enable+0x38>)
    1310:	f003 fc06 	bl	4b20 <z_impl_k_sem_give>
}
    1314:	e7f7      	b.n	1306 <log_backend_enable+0x1e>
    1316:	bf00      	nop
    1318:	00007a04 	.word	0x00007a04
    131c:	20000a70 	.word	0x20000a70
    1320:	20000044 	.word	0x20000044

00001324 <log_init>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    1324:	4b18      	ldr	r3, [pc, #96]	; (1388 <log_init+0x64>)
    1326:	f3bf 8f5b 	dmb	ish
    132a:	e853 2f00 	ldrex	r2, [r3]
    132e:	1c51      	adds	r1, r2, #1
    1330:	e843 1000 	strex	r0, r1, [r3]
    1334:	2800      	cmp	r0, #0
    1336:	d1f8      	bne.n	132a <log_init+0x6>
    1338:	f3bf 8f5b 	dmb	ish
	if (atomic_inc(&initialized) != 0) {
    133c:	bb1a      	cbnz	r2, 1386 <log_init+0x62>
{
    133e:	b570      	push	{r4, r5, r6, lr}
	for (i = 0; i < log_backend_count_get(); i++) {
    1340:	2400      	movs	r4, #0
    1342:	e009      	b.n	1358 <log_init+0x34>
					   backend->cb->ctx,
    1344:	4b11      	ldr	r3, [pc, #68]	; (138c <log_init+0x68>)
    1346:	eb03 1306 	add.w	r3, r3, r6, lsl #4
    134a:	685b      	ldr	r3, [r3, #4]
			log_backend_enable(backend,
    134c:	2204      	movs	r2, #4
    134e:	6819      	ldr	r1, [r3, #0]
    1350:	4628      	mov	r0, r5
    1352:	f7ff ffc9 	bl	12e8 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
    1356:	3401      	adds	r4, #1
    1358:	4b0d      	ldr	r3, [pc, #52]	; (1390 <log_init+0x6c>)
    135a:	4a0c      	ldr	r2, [pc, #48]	; (138c <log_init+0x68>)
    135c:	1a9b      	subs	r3, r3, r2
    135e:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    1362:	da0f      	bge.n	1384 <log_init+0x60>
		const struct log_backend *backend = log_backend_get(i);
    1364:	4626      	mov	r6, r4
	return &__log_backends_start[idx];
    1366:	4d09      	ldr	r5, [pc, #36]	; (138c <log_init+0x68>)
    1368:	eb05 1504 	add.w	r5, r5, r4, lsl #4
		if (backend->autostart) {
    136c:	7b2b      	ldrb	r3, [r5, #12]
    136e:	2b00      	cmp	r3, #0
    1370:	d0f1      	beq.n	1356 <log_init+0x32>
			if (backend->api->init != NULL) {
    1372:	0123      	lsls	r3, r4, #4
    1374:	4a05      	ldr	r2, [pc, #20]	; (138c <log_init+0x68>)
    1376:	58d3      	ldr	r3, [r2, r3]
    1378:	699b      	ldr	r3, [r3, #24]
    137a:	2b00      	cmp	r3, #0
    137c:	d0e2      	beq.n	1344 <log_init+0x20>
				backend->api->init(backend);
    137e:	4628      	mov	r0, r5
    1380:	4798      	blx	r3
    1382:	e7df      	b.n	1344 <log_init+0x20>
}
    1384:	bd70      	pop	{r4, r5, r6, pc}
    1386:	4770      	bx	lr
    1388:	200003bc 	.word	0x200003bc
    138c:	00007a04 	.word	0x00007a04
    1390:	00007a24 	.word	0x00007a24

00001394 <z_log_strdup>:
{
    1394:	b510      	push	{r4, lr}
    1396:	b082      	sub	sp, #8
    1398:	4604      	mov	r4, r0
	    is_rodata(str) || k_is_user_context()) {
    139a:	f7ff fead 	bl	10f8 <is_rodata>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
    139e:	bb10      	cbnz	r0, 13e6 <z_log_strdup+0x52>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
    13a0:	2200      	movs	r2, #0
    13a2:	2300      	movs	r3, #0
    13a4:	a901      	add	r1, sp, #4
    13a6:	4811      	ldr	r0, [pc, #68]	; (13ec <z_log_strdup+0x58>)
    13a8:	f003 f9b2 	bl	4710 <k_mem_slab_alloc>
	if (err != 0) {
    13ac:	b108      	cbz	r0, 13b2 <z_log_strdup+0x1e>
		return (char *)log_strdup_fail_msg;
    13ae:	4c10      	ldr	r4, [pc, #64]	; (13f0 <z_log_strdup+0x5c>)
    13b0:	e019      	b.n	13e6 <z_log_strdup+0x52>
	(void)atomic_set(&dup->refcount, 1);
    13b2:	9b01      	ldr	r3, [sp, #4]
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    13b4:	2201      	movs	r2, #1
    13b6:	f3bf 8f5b 	dmb	ish
    13ba:	e853 1f00 	ldrex	r1, [r3]
    13be:	e843 2000 	strex	r0, r2, [r3]
    13c2:	2800      	cmp	r0, #0
    13c4:	d1f9      	bne.n	13ba <z_log_strdup+0x26>
    13c6:	f3bf 8f5b 	dmb	ish
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
    13ca:	221f      	movs	r2, #31
    13cc:	4621      	mov	r1, r4
    13ce:	9801      	ldr	r0, [sp, #4]
    13d0:	3004      	adds	r0, #4
    13d2:	f005 fb08 	bl	69e6 <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
    13d6:	9c01      	ldr	r4, [sp, #4]
    13d8:	237e      	movs	r3, #126	; 0x7e
    13da:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
    13de:	2300      	movs	r3, #0
    13e0:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
	return dup->buf;
    13e4:	3404      	adds	r4, #4
}
    13e6:	4620      	mov	r0, r4
    13e8:	b002      	add	sp, #8
    13ea:	bd10      	pop	{r4, pc}
    13ec:	200003c8 	.word	0x200003c8
    13f0:	00007b68 	.word	0x00007b68

000013f4 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (uint8_t *)buf);
    13f4:	b138      	cbz	r0, 1406 <log_is_strdup+0x12>
    13f6:	4a07      	ldr	r2, [pc, #28]	; (1414 <log_is_strdup+0x20>)
    13f8:	4290      	cmp	r0, r2
    13fa:	d306      	bcc.n	140a <log_is_strdup+0x16>
    13fc:	32a0      	adds	r2, #160	; 0xa0
    13fe:	4290      	cmp	r0, r2
    1400:	d305      	bcc.n	140e <log_is_strdup+0x1a>
    1402:	2000      	movs	r0, #0
    1404:	4770      	bx	lr
    1406:	2000      	movs	r0, #0
    1408:	4770      	bx	lr
    140a:	2000      	movs	r0, #0
    140c:	4770      	bx	lr
    140e:	2001      	movs	r0, #1
}
    1410:	4770      	bx	lr
    1412:	bf00      	nop
    1414:	20001f60 	.word	0x20001f60

00001418 <detect_missed_strdup>:
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    1418:	7a03      	ldrb	r3, [r0, #8]
	if (!log_msg_is_std(msg)) {
    141a:	f013 0f01 	tst.w	r3, #1
    141e:	d000      	beq.n	1422 <detect_missed_strdup+0xa>
    1420:	4770      	bx	lr
{
    1422:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1426:	b083      	sub	sp, #12
    1428:	4606      	mov	r6, r0
	msg_str = log_msg_str_get(msg);
    142a:	f004 feae 	bl	618a <log_msg_str_get>
    142e:	4607      	mov	r7, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
    1430:	4630      	mov	r0, r6
    1432:	f004 fe95 	bl	6160 <log_msg_nargs_get>
    1436:	4601      	mov	r1, r0
    1438:	4638      	mov	r0, r7
    143a:	f004 fdf0 	bl	601e <z_log_get_s_mask>
    143e:	4605      	mov	r5, r0
	while (mask) {
    1440:	e004      	b.n	144c <detect_missed_strdup+0x34>
		mask &= ~BIT(idx);
    1442:	2301      	movs	r3, #1
    1444:	fa03 f404 	lsl.w	r4, r3, r4
    1448:	ea25 0504 	bic.w	r5, r5, r4
	while (mask) {
    144c:	b36d      	cbz	r5, 14aa <detect_missed_strdup+0x92>
		idx = 31 - __builtin_clz(mask);
    144e:	fab5 f485 	clz	r4, r5
    1452:	f1c4 041f 	rsb	r4, r4, #31
		str = (const char *)log_msg_arg_get(msg, idx);
    1456:	4621      	mov	r1, r4
    1458:	4630      	mov	r0, r6
    145a:	f004 fe84 	bl	6166 <log_msg_arg_get>
    145e:	4681      	mov	r9, r0
		if (!is_rodata(str) && !log_is_strdup(str) &&
    1460:	f7ff fe4a 	bl	10f8 <is_rodata>
    1464:	2800      	cmp	r0, #0
    1466:	d1ec      	bne.n	1442 <detect_missed_strdup+0x2a>
    1468:	4648      	mov	r0, r9
    146a:	f7ff ffc3 	bl	13f4 <log_is_strdup>
    146e:	2800      	cmp	r0, #0
    1470:	d1e7      	bne.n	1442 <detect_missed_strdup+0x2a>
    1472:	4b0f      	ldr	r3, [pc, #60]	; (14b0 <detect_missed_strdup+0x98>)
    1474:	4599      	cmp	r9, r3
    1476:	d0e4      	beq.n	1442 <detect_missed_strdup+0x2a>
	return msg->hdr.ids.source_id;
    1478:	8971      	ldrh	r1, [r6, #10]
				log_source_name_get(CONFIG_LOG_DOMAIN_ID,
    147a:	f3c1 1189 	ubfx	r1, r1, #6, #10
    147e:	f7ff ff23 	bl	12c8 <log_source_name_get>
    1482:	4602      	mov	r2, r0
 * @return Source ID.
 */
static inline uint32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((uint8_t *)data - (uint8_t *)__log_const_start)/
    1484:	4b0b      	ldr	r3, [pc, #44]	; (14b4 <detect_missed_strdup+0x9c>)
    1486:	490c      	ldr	r1, [pc, #48]	; (14b8 <detect_missed_strdup+0xa0>)
    1488:	1a5b      	subs	r3, r3, r1
    148a:	08db      	lsrs	r3, r3, #3
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
    148c:	2101      	movs	r1, #1
    148e:	f361 0802 	bfi	r8, r1, #0, #3
    1492:	f36f 08c5 	bfc	r8, #3, #3
    1496:	f363 188f 	bfi	r8, r3, #6, #10
    149a:	f8ad 8000 	strh.w	r8, [sp]
    149e:	463b      	mov	r3, r7
    14a0:	4621      	mov	r1, r4
    14a2:	4806      	ldr	r0, [pc, #24]	; (14bc <detect_missed_strdup+0xa4>)
    14a4:	f000 f8b2 	bl	160c <log_3>
    14a8:	e7cb      	b.n	1442 <detect_missed_strdup+0x2a>
}
    14aa:	b003      	add	sp, #12
    14ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    14b0:	00007b68 	.word	0x00007b68
    14b4:	000079d4 	.word	0x000079d4
    14b8:	000079c4 	.word	0x000079c4
    14bc:	00007b84 	.word	0x00007b84

000014c0 <msg_process>:
{
    14c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    14c2:	4606      	mov	r6, r0
	if (!bypass) {
    14c4:	bb19      	cbnz	r1, 150e <msg_process+0x4e>
		    !panic_mode) {
    14c6:	4b14      	ldr	r3, [pc, #80]	; (1518 <msg_process+0x58>)
    14c8:	781b      	ldrb	r3, [r3, #0]
		if (!IS_ENABLED(CONFIG_LOG2) &&
    14ca:	b10b      	cbz	r3, 14d0 <msg_process+0x10>
{
    14cc:	2400      	movs	r4, #0
    14ce:	e003      	b.n	14d8 <msg_process+0x18>
			detect_missed_strdup(msg.msg);
    14d0:	f7ff ffa2 	bl	1418 <detect_missed_strdup>
    14d4:	e7fa      	b.n	14cc <msg_process+0xc>
		for (int i = 0; i < log_backend_count_get(); i++) {
    14d6:	3401      	adds	r4, #1
    14d8:	4b10      	ldr	r3, [pc, #64]	; (151c <msg_process+0x5c>)
    14da:	4a11      	ldr	r2, [pc, #68]	; (1520 <msg_process+0x60>)
    14dc:	1a9b      	subs	r3, r3, r2
    14de:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    14e2:	da14      	bge.n	150e <msg_process+0x4e>
    14e4:	4d0e      	ldr	r5, [pc, #56]	; (1520 <msg_process+0x60>)
    14e6:	eb05 1504 	add.w	r5, r5, r4, lsl #4
	return backend->cb->active;
    14ea:	686b      	ldr	r3, [r5, #4]
    14ec:	795b      	ldrb	r3, [r3, #5]
			if (log_backend_is_active(backend) &&
    14ee:	2b00      	cmp	r3, #0
    14f0:	d0f1      	beq.n	14d6 <msg_process+0x16>
			    msg_filter_check(backend, msg)) {
    14f2:	4631      	mov	r1, r6
    14f4:	4628      	mov	r0, r5
    14f6:	f004 fd8c 	bl	6012 <msg_filter_check>
			if (log_backend_is_active(backend) &&
    14fa:	2800      	cmp	r0, #0
    14fc:	d0eb      	beq.n	14d6 <msg_process+0x16>
	backend->api->put(backend, msg);
    14fe:	0127      	lsls	r7, r4, #4
    1500:	4b07      	ldr	r3, [pc, #28]	; (1520 <msg_process+0x60>)
    1502:	59db      	ldr	r3, [r3, r7]
    1504:	685b      	ldr	r3, [r3, #4]
    1506:	4631      	mov	r1, r6
    1508:	4628      	mov	r0, r5
    150a:	4798      	blx	r3
}
    150c:	e7e3      	b.n	14d6 <msg_process+0x16>
			log_msg_put(msg.msg);
    150e:	4630      	mov	r0, r6
    1510:	f004 fe3d 	bl	618e <log_msg_put>
}
    1514:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1516:	bf00      	nop
    1518:	20000a71 	.word	0x20000a71
    151c:	00007a24 	.word	0x00007a24
    1520:	00007a04 	.word	0x00007a04

00001524 <z_impl_log_process>:
{
    1524:	b510      	push	{r4, lr}
    1526:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
    1528:	4b10      	ldr	r3, [pc, #64]	; (156c <z_impl_log_process+0x48>)
    152a:	781b      	ldrb	r3, [r3, #0]
    152c:	b903      	cbnz	r3, 1530 <z_impl_log_process+0xc>
    152e:	b1c8      	cbz	r0, 1564 <z_impl_log_process+0x40>
	msg = get_msg();
    1530:	f7ff fe6a 	bl	1208 <get_msg>
	if (msg.msg) {
    1534:	4602      	mov	r2, r0
    1536:	b178      	cbz	r0, 1558 <z_impl_log_process+0x34>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    1538:	4b0d      	ldr	r3, [pc, #52]	; (1570 <z_impl_log_process+0x4c>)
    153a:	f3bf 8f5b 	dmb	ish
    153e:	e853 1f00 	ldrex	r1, [r3]
    1542:	3901      	subs	r1, #1
    1544:	e843 1000 	strex	r0, r1, [r3]
    1548:	2800      	cmp	r0, #0
    154a:	d1f8      	bne.n	153e <z_impl_log_process+0x1a>
    154c:	f3bf 8f5b 	dmb	ish
		msg_process(msg, bypass);
    1550:	4621      	mov	r1, r4
    1552:	4610      	mov	r0, r2
    1554:	f7ff ffb4 	bl	14c0 <msg_process>
	if (!bypass && z_log_dropped_pending()) {
    1558:	b914      	cbnz	r4, 1560 <z_impl_log_process+0x3c>
    155a:	f7ff feab 	bl	12b4 <z_log_dropped_pending>
    155e:	b910      	cbnz	r0, 1566 <z_impl_log_process+0x42>
	return next_pending();
    1560:	f7ff fdf6 	bl	1150 <next_pending>
}
    1564:	bd10      	pop	{r4, pc}
		dropped_notify();
    1566:	f7ff fe83 	bl	1270 <dropped_notify>
    156a:	e7f9      	b.n	1560 <z_impl_log_process+0x3c>
    156c:	20000a70 	.word	0x20000a70
    1570:	200003b4 	.word	0x200003b4

00001574 <z_log_msg_post_finalize>:
{
    1574:	b510      	push	{r4, lr}
    1576:	b082      	sub	sp, #8
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    1578:	4b1f      	ldr	r3, [pc, #124]	; (15f8 <z_log_msg_post_finalize+0x84>)
    157a:	f3bf 8f5b 	dmb	ish
    157e:	e853 2f00 	ldrex	r2, [r3]
    1582:	3201      	adds	r2, #1
    1584:	e843 2100 	strex	r1, r2, [r3]
    1588:	2900      	cmp	r1, #0
    158a:	d1f8      	bne.n	157e <z_log_msg_post_finalize+0xa>
    158c:	f3bf 8f5b 	dmb	ish
	if (panic_mode) {
    1590:	4b1a      	ldr	r3, [pc, #104]	; (15fc <z_log_msg_post_finalize+0x88>)
    1592:	781b      	ldrb	r3, [r3, #0]
    1594:	b963      	cbnz	r3, 15b0 <z_log_msg_post_finalize+0x3c>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    1596:	4b1a      	ldr	r3, [pc, #104]	; (1600 <z_log_msg_post_finalize+0x8c>)
    1598:	681b      	ldr	r3, [r3, #0]
    159a:	b11b      	cbz	r3, 15a4 <z_log_msg_post_finalize+0x30>
    159c:	4a16      	ldr	r2, [pc, #88]	; (15f8 <z_log_msg_post_finalize+0x84>)
    159e:	6812      	ldr	r2, [r2, #0]
    15a0:	2a01      	cmp	r2, #1
    15a2:	d015      	beq.n	15d0 <z_log_msg_post_finalize+0x5c>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    15a4:	4a14      	ldr	r2, [pc, #80]	; (15f8 <z_log_msg_post_finalize+0x84>)
    15a6:	6812      	ldr	r2, [r2, #0]
    15a8:	2a0a      	cmp	r2, #10
    15aa:	d01c      	beq.n	15e6 <z_log_msg_post_finalize+0x72>
}
    15ac:	b002      	add	sp, #8
    15ae:	bd10      	pop	{r4, pc}
	__asm__ volatile(
    15b0:	f04f 0320 	mov.w	r3, #32
    15b4:	f3ef 8411 	mrs	r4, BASEPRI
    15b8:	f383 8811 	msr	BASEPRI, r3
    15bc:	f3bf 8f6f 	isb	sy
		/* coverity[OVERRUN] */
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
    15c0:	2000      	movs	r0, #0
    15c2:	f7ff ffaf 	bl	1524 <z_impl_log_process>
	__asm__ volatile(
    15c6:	f384 8811 	msr	BASEPRI, r4
    15ca:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    15ce:	e7ed      	b.n	15ac <z_log_msg_post_finalize+0x38>
	z_impl_k_timer_start(timer, duration, period);
    15d0:	2200      	movs	r2, #0
    15d2:	2300      	movs	r3, #0
    15d4:	e9cd 2300 	strd	r2, r3, [sp]
    15d8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
    15dc:	2300      	movs	r3, #0
    15de:	4809      	ldr	r0, [pc, #36]	; (1604 <z_log_msg_post_finalize+0x90>)
    15e0:	f004 fa18 	bl	5a14 <z_impl_k_timer_start>
	} else if (proc_tid != NULL && buffered_cnt == 1) {
    15e4:	e7e2      	b.n	15ac <z_log_msg_post_finalize+0x38>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
    15e6:	2b00      	cmp	r3, #0
    15e8:	d0e0      	beq.n	15ac <z_log_msg_post_finalize+0x38>
	z_impl_k_timer_stop(timer);
    15ea:	4806      	ldr	r0, [pc, #24]	; (1604 <z_log_msg_post_finalize+0x90>)
    15ec:	f006 f8d4 	bl	7798 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
    15f0:	4805      	ldr	r0, [pc, #20]	; (1608 <z_log_msg_post_finalize+0x94>)
    15f2:	f003 fa95 	bl	4b20 <z_impl_k_sem_give>
}
    15f6:	e7d9      	b.n	15ac <z_log_msg_post_finalize+0x38>
    15f8:	200003b4 	.word	0x200003b4
    15fc:	20000a71 	.word	0x20000a71
    1600:	200003e4 	.word	0x200003e4
    1604:	20000058 	.word	0x20000058
    1608:	20000044 	.word	0x20000044

0000160c <log_3>:
{
    160c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1610:	4680      	mov	r8, r0
    1612:	460f      	mov	r7, r1
    1614:	4616      	mov	r6, r2
    1616:	461d      	mov	r5, r3
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1618:	f000 f99c 	bl	1954 <log_msg_chunk_alloc>

	if (msg != NULL) {
    161c:	4604      	mov	r4, r0
    161e:	b140      	cbz	r0, 1632 <log_3+0x26>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
    1620:	2301      	movs	r3, #1
    1622:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    1624:	2200      	movs	r2, #0
    1626:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1628:	f04f 0300 	mov.w	r3, #0
    162c:	f362 0300 	bfi	r3, r2, #0, #1
    1630:	7203      	strb	r3, [r0, #8]
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();

	if (msg != NULL) {
    1632:	b14c      	cbz	r4, 1648 <log_3+0x3c>
		msg->str = str;
    1634:	f8c4 8010 	str.w	r8, [r4, #16]
		msg->hdr.params.std.nargs = 3U;
    1638:	7a63      	ldrb	r3, [r4, #9]
    163a:	2203      	movs	r2, #3
    163c:	f362 1307 	bfi	r3, r2, #4, #4
    1640:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    1642:	6167      	str	r7, [r4, #20]
		msg->payload.single.args[1] = arg2;
    1644:	61a6      	str	r6, [r4, #24]
		msg->payload.single.args[2] = arg3;
    1646:	61e5      	str	r5, [r4, #28]
		if (msg == NULL) {
    1648:	b1c4      	cbz	r4, 167c <log_3+0x70>
	msg->hdr.ids = src_level;
    164a:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    164e:	8163      	strh	r3, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1650:	4b0b      	ldr	r3, [pc, #44]	; (1680 <log_3+0x74>)
    1652:	681b      	ldr	r3, [r3, #0]
    1654:	4798      	blx	r3
    1656:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    1658:	f04f 0320 	mov.w	r3, #32
    165c:	f3ef 8511 	mrs	r5, BASEPRI
    1660:	f383 8811 	msr	BASEPRI, r3
    1664:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    1668:	4621      	mov	r1, r4
    166a:	4806      	ldr	r0, [pc, #24]	; (1684 <log_3+0x78>)
    166c:	f004 fcbd 	bl	5fea <log_list_add_tail>
	__asm__ volatile(
    1670:	f385 8811 	msr	BASEPRI, r5
    1674:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    1678:	f7ff ff7c 	bl	1574 <z_log_msg_post_finalize>
}
    167c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1680:	20000004 	.word	0x20000004
    1684:	200003c0 	.word	0x200003c0

00001688 <log_1>:
{
    1688:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    168a:	4606      	mov	r6, r0
    168c:	460d      	mov	r5, r1
    168e:	4617      	mov	r7, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1690:	f000 f960 	bl	1954 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1694:	4604      	mov	r4, r0
    1696:	b140      	cbz	r0, 16aa <log_1+0x22>
		msg->hdr.ref_cnt = 1;
    1698:	2301      	movs	r3, #1
    169a:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    169c:	2100      	movs	r1, #0
    169e:	8101      	strh	r1, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    16a0:	f04f 0300 	mov.w	r3, #0
    16a4:	f361 0300 	bfi	r3, r1, #0, #1
    16a8:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    16aa:	b134      	cbz	r4, 16ba <log_1+0x32>
		msg->str = str;
    16ac:	6126      	str	r6, [r4, #16]
		msg->hdr.params.std.nargs = 1U;
    16ae:	7a63      	ldrb	r3, [r4, #9]
    16b0:	2201      	movs	r2, #1
    16b2:	f362 1307 	bfi	r3, r2, #4, #4
    16b6:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    16b8:	6165      	str	r5, [r4, #20]
		if (msg == NULL) {
    16ba:	b1b4      	cbz	r4, 16ea <log_1+0x62>
	msg->hdr.ids = src_level;
    16bc:	8167      	strh	r7, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    16be:	4b0b      	ldr	r3, [pc, #44]	; (16ec <log_1+0x64>)
    16c0:	681b      	ldr	r3, [r3, #0]
    16c2:	4798      	blx	r3
    16c4:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    16c6:	f04f 0320 	mov.w	r3, #32
    16ca:	f3ef 8511 	mrs	r5, BASEPRI
    16ce:	f383 8811 	msr	BASEPRI, r3
    16d2:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    16d6:	4621      	mov	r1, r4
    16d8:	4805      	ldr	r0, [pc, #20]	; (16f0 <log_1+0x68>)
    16da:	f004 fc86 	bl	5fea <log_list_add_tail>
	__asm__ volatile(
    16de:	f385 8811 	msr	BASEPRI, r5
    16e2:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    16e6:	f7ff ff45 	bl	1574 <z_log_msg_post_finalize>
}
    16ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    16ec:	20000004 	.word	0x20000004
    16f0:	200003c0 	.word	0x200003c0

000016f4 <log_2>:
{
    16f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    16f8:	4607      	mov	r7, r0
    16fa:	460e      	mov	r6, r1
    16fc:	4615      	mov	r5, r2
    16fe:	4698      	mov	r8, r3
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1700:	f000 f928 	bl	1954 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1704:	4604      	mov	r4, r0
    1706:	b140      	cbz	r0, 171a <log_2+0x26>
		msg->hdr.ref_cnt = 1;
    1708:	2301      	movs	r3, #1
    170a:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    170c:	2200      	movs	r2, #0
    170e:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1710:	f04f 0300 	mov.w	r3, #0
    1714:	f362 0300 	bfi	r3, r2, #0, #1
    1718:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    171a:	b13c      	cbz	r4, 172c <log_2+0x38>
		msg->str = str;
    171c:	6127      	str	r7, [r4, #16]
		msg->hdr.params.std.nargs = 2U;
    171e:	7a63      	ldrb	r3, [r4, #9]
    1720:	2202      	movs	r2, #2
    1722:	f362 1307 	bfi	r3, r2, #4, #4
    1726:	7263      	strb	r3, [r4, #9]
		msg->payload.single.args[0] = arg1;
    1728:	6166      	str	r6, [r4, #20]
		msg->payload.single.args[1] = arg2;
    172a:	61a5      	str	r5, [r4, #24]
		if (msg == NULL) {
    172c:	b1bc      	cbz	r4, 175e <log_2+0x6a>
	msg->hdr.ids = src_level;
    172e:	f8a4 800a 	strh.w	r8, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1732:	4b0c      	ldr	r3, [pc, #48]	; (1764 <log_2+0x70>)
    1734:	681b      	ldr	r3, [r3, #0]
    1736:	4798      	blx	r3
    1738:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    173a:	f04f 0320 	mov.w	r3, #32
    173e:	f3ef 8511 	mrs	r5, BASEPRI
    1742:	f383 8811 	msr	BASEPRI, r3
    1746:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    174a:	4621      	mov	r1, r4
    174c:	4806      	ldr	r0, [pc, #24]	; (1768 <log_2+0x74>)
    174e:	f004 fc4c 	bl	5fea <log_list_add_tail>
	__asm__ volatile(
    1752:	f385 8811 	msr	BASEPRI, r5
    1756:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    175a:	f7ff ff0b 	bl	1574 <z_log_msg_post_finalize>
}
    175e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1762:	bf00      	nop
    1764:	20000004 	.word	0x20000004
    1768:	200003c0 	.word	0x200003c0

0000176c <log_0>:
{
    176c:	b570      	push	{r4, r5, r6, lr}
    176e:	4605      	mov	r5, r0
    1770:	460e      	mov	r6, r1
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
    1772:	f000 f8ef 	bl	1954 <log_msg_chunk_alloc>
	if (msg != NULL) {
    1776:	4604      	mov	r4, r0
    1778:	b140      	cbz	r0, 178c <log_0+0x20>
		msg->hdr.ref_cnt = 1;
    177a:	2301      	movs	r3, #1
    177c:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
    177e:	2200      	movs	r2, #0
    1780:	8102      	strh	r2, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
    1782:	f04f 0300 	mov.w	r3, #0
    1786:	f362 0300 	bfi	r3, r2, #0, #1
    178a:	7203      	strb	r3, [r0, #8]
	if (msg != NULL) {
    178c:	b104      	cbz	r4, 1790 <log_0+0x24>
		msg->str = str;
    178e:	6125      	str	r5, [r4, #16]
		if (msg == NULL) {
    1790:	b1b4      	cbz	r4, 17c0 <log_0+0x54>
	msg->hdr.ids = src_level;
    1792:	8166      	strh	r6, [r4, #10]
	msg->hdr.timestamp = timestamp_func();
    1794:	4b0b      	ldr	r3, [pc, #44]	; (17c4 <log_0+0x58>)
    1796:	681b      	ldr	r3, [r3, #0]
    1798:	4798      	blx	r3
    179a:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    179c:	f04f 0320 	mov.w	r3, #32
    17a0:	f3ef 8511 	mrs	r5, BASEPRI
    17a4:	f383 8811 	msr	BASEPRI, r3
    17a8:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    17ac:	4621      	mov	r1, r4
    17ae:	4806      	ldr	r0, [pc, #24]	; (17c8 <log_0+0x5c>)
    17b0:	f004 fc1b 	bl	5fea <log_list_add_tail>
	__asm__ volatile(
    17b4:	f385 8811 	msr	BASEPRI, r5
    17b8:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    17bc:	f7ff feda 	bl	1574 <z_log_msg_post_finalize>
}
    17c0:	bd70      	pop	{r4, r5, r6, pc}
    17c2:	bf00      	nop
    17c4:	20000004 	.word	0x20000004
    17c8:	200003c0 	.word	0x200003c0

000017cc <z_log_printk>:
{
    17cc:	b530      	push	{r4, r5, lr}
    17ce:	b0a3      	sub	sp, #140	; 0x8c
    17d0:	4602      	mov	r2, r0
    17d2:	460b      	mov	r3, r1
		} src_level_union = {
    17d4:	2500      	movs	r5, #0
			length = vsnprintk(str, sizeof(str), fmt, ap);
    17d6:	2181      	movs	r1, #129	; 0x81
    17d8:	a801      	add	r0, sp, #4
    17da:	f7fe fee1 	bl	5a0 <vsnprintk>
			msg = log_msg_hexdump_create(NULL, str, length);
    17de:	4602      	mov	r2, r0
    17e0:	2881      	cmp	r0, #129	; 0x81
    17e2:	bf28      	it	cs
    17e4:	2281      	movcs	r2, #129	; 0x81
    17e6:	a901      	add	r1, sp, #4
    17e8:	4628      	mov	r0, r5
    17ea:	f004 fce3 	bl	61b4 <log_msg_hexdump_create>
			if (msg == NULL) {
    17ee:	b1b8      	cbz	r0, 1820 <z_log_printk+0x54>
    17f0:	4604      	mov	r4, r0
	msg->hdr.ids = src_level;
    17f2:	8145      	strh	r5, [r0, #10]
	msg->hdr.timestamp = timestamp_func();
    17f4:	4b0b      	ldr	r3, [pc, #44]	; (1824 <z_log_printk+0x58>)
    17f6:	681b      	ldr	r3, [r3, #0]
    17f8:	4798      	blx	r3
    17fa:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    17fc:	f04f 0320 	mov.w	r3, #32
    1800:	f3ef 8511 	mrs	r5, BASEPRI
    1804:	f383 8811 	msr	BASEPRI, r3
    1808:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
    180c:	4621      	mov	r1, r4
    180e:	4806      	ldr	r0, [pc, #24]	; (1828 <z_log_printk+0x5c>)
    1810:	f004 fbeb 	bl	5fea <log_list_add_tail>
	__asm__ volatile(
    1814:	f385 8811 	msr	BASEPRI, r5
    1818:	f3bf 8f6f 	isb	sy
	z_log_msg_post_finalize();
    181c:	f7ff feaa 	bl	1574 <z_log_msg_post_finalize>
}
    1820:	b023      	add	sp, #140	; 0x8c
    1822:	bd30      	pop	{r4, r5, pc}
    1824:	20000004 	.word	0x20000004
    1828:	200003c0 	.word	0x200003c0

0000182c <z_impl_log_panic>:
	if (panic_mode) {
    182c:	4b12      	ldr	r3, [pc, #72]	; (1878 <z_impl_log_panic+0x4c>)
    182e:	781b      	ldrb	r3, [r3, #0]
    1830:	b103      	cbz	r3, 1834 <z_impl_log_panic+0x8>
    1832:	4770      	bx	lr
{
    1834:	b510      	push	{r4, lr}
	log_init();
    1836:	f7ff fd75 	bl	1324 <log_init>
	for (int i = 0; i < log_backend_count_get(); i++) {
    183a:	2400      	movs	r4, #0
    183c:	e000      	b.n	1840 <z_impl_log_panic+0x14>
    183e:	3401      	adds	r4, #1
    1840:	4b0e      	ldr	r3, [pc, #56]	; (187c <z_impl_log_panic+0x50>)
    1842:	4a0f      	ldr	r2, [pc, #60]	; (1880 <z_impl_log_panic+0x54>)
    1844:	1a9b      	subs	r3, r3, r2
    1846:	ebb4 1f23 	cmp.w	r4, r3, asr #4
    184a:	da0c      	bge.n	1866 <z_impl_log_panic+0x3a>
	return &__log_backends_start[idx];
    184c:	480c      	ldr	r0, [pc, #48]	; (1880 <z_impl_log_panic+0x54>)
    184e:	eb00 1004 	add.w	r0, r0, r4, lsl #4
	return backend->cb->active;
    1852:	6843      	ldr	r3, [r0, #4]
    1854:	795b      	ldrb	r3, [r3, #5]
		if (log_backend_is_active(backend)) {
    1856:	2b00      	cmp	r3, #0
    1858:	d0f1      	beq.n	183e <z_impl_log_panic+0x12>
	backend->api->panic(backend);
    185a:	0123      	lsls	r3, r4, #4
    185c:	4a08      	ldr	r2, [pc, #32]	; (1880 <z_impl_log_panic+0x54>)
    185e:	58d3      	ldr	r3, [r2, r3]
    1860:	695b      	ldr	r3, [r3, #20]
    1862:	4798      	blx	r3
}
    1864:	e7eb      	b.n	183e <z_impl_log_panic+0x12>
    1866:	2000      	movs	r0, #0
    1868:	f7ff fe5c 	bl	1524 <z_impl_log_process>
		while (log_process(false) == true) {
    186c:	2800      	cmp	r0, #0
    186e:	d1fa      	bne.n	1866 <z_impl_log_panic+0x3a>
	panic_mode = true;
    1870:	4b01      	ldr	r3, [pc, #4]	; (1878 <z_impl_log_panic+0x4c>)
    1872:	2201      	movs	r2, #1
    1874:	701a      	strb	r2, [r3, #0]
}
    1876:	bd10      	pop	{r4, pc}
    1878:	20000a71 	.word	0x20000a71
    187c:	00007a24 	.word	0x00007a24
    1880:	00007a04 	.word	0x00007a04

00001884 <log_process_thread_func>:
{
    1884:	b508      	push	{r3, lr}
	log_init();
    1886:	f7ff fd4d 	bl	1324 <log_init>
	return z_impl_k_current_get();
    188a:	f003 febb 	bl	5604 <z_impl_k_current_get>
	thread_set(k_current_get());
    188e:	f7ff fc43 	bl	1118 <thread_set>
    1892:	e006      	b.n	18a2 <log_process_thread_func+0x1e>
	return z_impl_k_sem_take(sem, timeout);
    1894:	f04f 32ff 	mov.w	r2, #4294967295
    1898:	f04f 33ff 	mov.w	r3, #4294967295
    189c:	4804      	ldr	r0, [pc, #16]	; (18b0 <log_process_thread_func+0x2c>)
    189e:	f003 f963 	bl	4b68 <z_impl_k_sem_take>
    18a2:	2000      	movs	r0, #0
    18a4:	f7ff fe3e 	bl	1524 <z_impl_log_process>
		if (log_process(false) == false) {
    18a8:	2800      	cmp	r0, #0
    18aa:	d1fa      	bne.n	18a2 <log_process_thread_func+0x1e>
    18ac:	e7f2      	b.n	1894 <log_process_thread_func+0x10>
    18ae:	bf00      	nop
    18b0:	20000044 	.word	0x20000044

000018b4 <log_free>:
{
    18b4:	b500      	push	{lr}
    18b6:	b083      	sub	sp, #12
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
    18b8:	3804      	subs	r0, #4
    18ba:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    18bc:	f3bf 8f5b 	dmb	ish
    18c0:	e850 3f00 	ldrex	r3, [r0]
    18c4:	1e5a      	subs	r2, r3, #1
    18c6:	e840 2100 	strex	r1, r2, [r0]
    18ca:	2900      	cmp	r1, #0
    18cc:	d1f8      	bne.n	18c0 <log_free+0xc>
    18ce:	f3bf 8f5b 	dmb	ish
	if (atomic_dec(&dup->refcount) == 1) {
    18d2:	2b01      	cmp	r3, #1
    18d4:	d002      	beq.n	18dc <log_free+0x28>
}
    18d6:	b003      	add	sp, #12
    18d8:	f85d fb04 	ldr.w	pc, [sp], #4
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
    18dc:	a901      	add	r1, sp, #4
    18de:	4802      	ldr	r0, [pc, #8]	; (18e8 <log_free+0x34>)
    18e0:	f005 fc94 	bl	720c <k_mem_slab_free>
}
    18e4:	e7f7      	b.n	18d6 <log_free+0x22>
    18e6:	bf00      	nop
    18e8:	200003c8 	.word	0x200003c8

000018ec <cont_free>:
{
	atomic_inc(&msg->hdr.ref_cnt);
}

static void cont_free(struct log_msg_cont *cont)
{
    18ec:	b510      	push	{r4, lr}
    18ee:	b082      	sub	sp, #8
    18f0:	9001      	str	r0, [sp, #4]
	struct log_msg_cont *next;

	while (cont != NULL) {
    18f2:	9b01      	ldr	r3, [sp, #4]
    18f4:	b133      	cbz	r3, 1904 <cont_free+0x18>
		next = cont->next;
    18f6:	681c      	ldr	r4, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
    18f8:	a901      	add	r1, sp, #4
    18fa:	4803      	ldr	r0, [pc, #12]	; (1908 <cont_free+0x1c>)
    18fc:	f005 fc86 	bl	720c <k_mem_slab_free>
		cont = next;
    1900:	9401      	str	r4, [sp, #4]
    1902:	e7f6      	b.n	18f2 <cont_free+0x6>
	}
}
    1904:	b002      	add	sp, #8
    1906:	bd10      	pop	{r4, pc}
    1908:	200003e8 	.word	0x200003e8

0000190c <log_msg_pool_init>:
{
    190c:	b508      	push	{r3, lr}
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
    190e:	2320      	movs	r3, #32
    1910:	461a      	mov	r2, r3
    1912:	4902      	ldr	r1, [pc, #8]	; (191c <log_msg_pool_init+0x10>)
    1914:	4802      	ldr	r0, [pc, #8]	; (1920 <log_msg_pool_init+0x14>)
    1916:	f005 fc6b 	bl	71f0 <k_mem_slab_init>
}
    191a:	bd08      	pop	{r3, pc}
    191c:	20002000 	.word	0x20002000
    1920:	200003e8 	.word	0x200003e8

00001924 <log_msg_no_space_handle>:

	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
    1924:	b510      	push	{r4, lr}
    1926:	b082      	sub	sp, #8
	union log_msg_chunk *msg = NULL;
    1928:	2300      	movs	r3, #0
    192a:	9301      	str	r3, [sp, #4]
    192c:	2001      	movs	r0, #1
    192e:	f7ff fdf9 	bl	1524 <z_impl_log_process>
    1932:	4604      	mov	r4, r0
	int err;

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			z_log_dropped();
    1934:	f7ff fc7c 	bl	1230 <z_log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
    1938:	2200      	movs	r2, #0
    193a:	2300      	movs	r3, #0
    193c:	a901      	add	r1, sp, #4
    193e:	4804      	ldr	r0, [pc, #16]	; (1950 <log_msg_no_space_handle+0x2c>)
    1940:	f002 fee6 	bl	4710 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
    1944:	b108      	cbz	r0, 194a <log_msg_no_space_handle+0x26>
    1946:	2c00      	cmp	r4, #0
    1948:	d1f0      	bne.n	192c <log_msg_no_space_handle+0x8>
	} else {
		z_log_dropped();
	}
	return msg;

}
    194a:	9801      	ldr	r0, [sp, #4]
    194c:	b002      	add	sp, #8
    194e:	bd10      	pop	{r4, pc}
    1950:	200003e8 	.word	0x200003e8

00001954 <log_msg_chunk_alloc>:
{
    1954:	b500      	push	{lr}
    1956:	b083      	sub	sp, #12
	union log_msg_chunk *msg = NULL;
    1958:	2300      	movs	r3, #0
    195a:	9301      	str	r3, [sp, #4]
		   block_on_alloc()
    195c:	f004 fb80 	bl	6060 <block_on_alloc>
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    1960:	b150      	cbz	r0, 1978 <log_msg_chunk_alloc+0x24>
    1962:	2200      	movs	r2, #0
    1964:	2300      	movs	r3, #0
    1966:	a901      	add	r1, sp, #4
    1968:	4807      	ldr	r0, [pc, #28]	; (1988 <log_msg_chunk_alloc+0x34>)
    196a:	f002 fed1 	bl	4710 <k_mem_slab_alloc>
	if (err != 0) {
    196e:	b930      	cbnz	r0, 197e <log_msg_chunk_alloc+0x2a>
}
    1970:	9801      	ldr	r0, [sp, #4]
    1972:	b003      	add	sp, #12
    1974:	f85d fb04 	ldr.w	pc, [sp], #4
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
    1978:	2200      	movs	r2, #0
    197a:	2300      	movs	r3, #0
    197c:	e7f3      	b.n	1966 <log_msg_chunk_alloc+0x12>
		msg = log_msg_no_space_handle();
    197e:	f7ff ffd1 	bl	1924 <log_msg_no_space_handle>
    1982:	9001      	str	r0, [sp, #4]
    1984:	e7f4      	b.n	1970 <log_msg_chunk_alloc+0x1c>
    1986:	bf00      	nop
    1988:	200003e8 	.word	0x200003e8

0000198c <msg_free>:
{
    198c:	b5f0      	push	{r4, r5, r6, r7, lr}
    198e:	b083      	sub	sp, #12
    1990:	9001      	str	r0, [sp, #4]
	uint32_t nargs = log_msg_nargs_get(msg);
    1992:	4604      	mov	r4, r0
    1994:	f004 fbe4 	bl	6160 <log_msg_nargs_get>
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    1998:	7a23      	ldrb	r3, [r4, #8]
	if (log_msg_is_std(msg) && nargs) {
    199a:	f013 0f01 	tst.w	r3, #1
    199e:	d101      	bne.n	19a4 <msg_free+0x18>
    19a0:	4606      	mov	r6, r0
    19a2:	bb50      	cbnz	r0, 19fa <msg_free+0x6e>
	if (msg->hdr.params.generic.ext == 1) {
    19a4:	9b01      	ldr	r3, [sp, #4]
    19a6:	7a1a      	ldrb	r2, [r3, #8]
    19a8:	f012 0f02 	tst.w	r2, #2
    19ac:	d128      	bne.n	1a00 <msg_free+0x74>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
    19ae:	a901      	add	r1, sp, #4
    19b0:	4815      	ldr	r0, [pc, #84]	; (1a08 <msg_free+0x7c>)
    19b2:	f005 fc2b 	bl	720c <k_mem_slab_free>
}
    19b6:	b003      	add	sp, #12
    19b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
					smask = z_log_get_s_mask(
    19ba:	9801      	ldr	r0, [sp, #4]
    19bc:	f004 fbe5 	bl	618a <log_msg_str_get>
    19c0:	4631      	mov	r1, r6
    19c2:	f004 fb2c 	bl	601e <z_log_get_s_mask>
					if (smask == 0U) {
    19c6:	4607      	mov	r7, r0
    19c8:	b988      	cbnz	r0, 19ee <msg_free+0x62>
    19ca:	e7eb      	b.n	19a4 <msg_free+0x18>
					log_free(buf);
    19cc:	4628      	mov	r0, r5
    19ce:	f7ff ff71 	bl	18b4 <log_free>
		for (i = 0U; i < nargs; i++) {
    19d2:	3401      	adds	r4, #1
    19d4:	42b4      	cmp	r4, r6
    19d6:	d2e5      	bcs.n	19a4 <msg_free+0x18>
			void *buf = (void *)log_msg_arg_get(msg, i);
    19d8:	4621      	mov	r1, r4
    19da:	9801      	ldr	r0, [sp, #4]
    19dc:	f004 fbc3 	bl	6166 <log_msg_arg_get>
    19e0:	4605      	mov	r5, r0
			if (log_is_strdup(buf)) {
    19e2:	f7ff fd07 	bl	13f4 <log_is_strdup>
    19e6:	2800      	cmp	r0, #0
    19e8:	d0f3      	beq.n	19d2 <msg_free+0x46>
				if (smask == 0U) {
    19ea:	2f00      	cmp	r7, #0
    19ec:	d0e5      	beq.n	19ba <msg_free+0x2e>
				if (smask & BIT(i)) {
    19ee:	fa27 f304 	lsr.w	r3, r7, r4
    19f2:	f013 0f01 	tst.w	r3, #1
    19f6:	d0ec      	beq.n	19d2 <msg_free+0x46>
    19f8:	e7e8      	b.n	19cc <msg_free+0x40>
		uint32_t smask = 0U;
    19fa:	2700      	movs	r7, #0
		for (i = 0U; i < nargs; i++) {
    19fc:	463c      	mov	r4, r7
    19fe:	e7e9      	b.n	19d4 <msg_free+0x48>
		cont_free(msg->payload.ext.next);
    1a00:	6958      	ldr	r0, [r3, #20]
    1a02:	f7ff ff73 	bl	18ec <cont_free>
    1a06:	e7d2      	b.n	19ae <msg_free+0x22>
    1a08:	200003e8 	.word	0x200003e8

00001a0c <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *output,
			   const char *fmt, ...)
{
    1a0c:	b40e      	push	{r1, r2, r3}
    1a0e:	b500      	push	{lr}
    1a10:	b082      	sub	sp, #8
    1a12:	4601      	mov	r1, r0
    1a14:	ab03      	add	r3, sp, #12
    1a16:	f853 2b04 	ldr.w	r2, [r3], #4
	va_list args;
	int length = 0;

	va_start(args, fmt);
    1a1a:	9301      	str	r3, [sp, #4]
	length = cbvprintf(out_func, (void *)output, fmt, args);
    1a1c:	4803      	ldr	r0, [pc, #12]	; (1a2c <print_formatted+0x20>)
    1a1e:	f7fe fe81 	bl	724 <cbvprintf>
	va_end(args);

	return length;
}
    1a22:	b002      	add	sp, #8
    1a24:	f85d eb04 	ldr.w	lr, [sp], #4
    1a28:	b003      	add	sp, #12
    1a2a:	4770      	bx	lr
    1a2c:	000065dd 	.word	0x000065dd

00001a30 <timestamp_print>:
	output->control_block->offset = 0;
}

static int timestamp_print(const struct log_output *output,
			   uint32_t flags, uint32_t timestamp)
{
    1a30:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a32:	b085      	sub	sp, #20
	bool format =
		(flags & LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP) |
		(flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG);


	if (!format) {
    1a34:	f011 0f44 	tst.w	r1, #68	; 0x44
    1a38:	d005      	beq.n	1a46 <timestamp_print+0x16>
		length = print_formatted(output, "[%08lu] ", timestamp);
	} else if (freq != 0U) {
    1a3a:	4b1a      	ldr	r3, [pc, #104]	; (1aa4 <timestamp_print+0x74>)
    1a3c:	681c      	ldr	r4, [r3, #0]
    1a3e:	b934      	cbnz	r4, 1a4e <timestamp_print+0x1e>
			length = print_formatted(output,
						 "[%02u:%02u:%02u.%03u,%03u] ",
						 hours, mins, seconds, ms, us);
		}
	} else {
		length = 0;
    1a40:	2000      	movs	r0, #0
	}

	return length;
}
    1a42:	b005      	add	sp, #20
    1a44:	bdf0      	pop	{r4, r5, r6, r7, pc}
		length = print_formatted(output, "[%08lu] ", timestamp);
    1a46:	4918      	ldr	r1, [pc, #96]	; (1aa8 <timestamp_print+0x78>)
    1a48:	f7ff ffe0 	bl	1a0c <print_formatted>
    1a4c:	e7f9      	b.n	1a42 <timestamp_print+0x12>
		timestamp /= timestamp_div;
    1a4e:	4b17      	ldr	r3, [pc, #92]	; (1aac <timestamp_print+0x7c>)
    1a50:	6819      	ldr	r1, [r3, #0]
    1a52:	fbb2 f1f1 	udiv	r1, r2, r1
		total_seconds = timestamp / freq;
    1a56:	fbb1 f5f4 	udiv	r5, r1, r4
		hours = seconds / 3600U;
    1a5a:	4a15      	ldr	r2, [pc, #84]	; (1ab0 <timestamp_print+0x80>)
    1a5c:	fba2 3205 	umull	r3, r2, r2, r5
    1a60:	0ad2      	lsrs	r2, r2, #11
		seconds -= hours * 3600U;
    1a62:	f44f 6661 	mov.w	r6, #3600	; 0xe10
    1a66:	fb06 5612 	mls	r6, r6, r2, r5
		mins = seconds / 60U;
    1a6a:	4b12      	ldr	r3, [pc, #72]	; (1ab4 <timestamp_print+0x84>)
    1a6c:	fba3 7306 	umull	r7, r3, r3, r6
    1a70:	095b      	lsrs	r3, r3, #5
		remainder = timestamp % freq;
    1a72:	fb04 1115 	mls	r1, r4, r5, r1
		ms = (remainder * 1000U) / freq;
    1a76:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    1a7a:	fb05 f101 	mul.w	r1, r5, r1
    1a7e:	fbb1 f7f4 	udiv	r7, r1, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
    1a82:	fb07 1114 	mls	r1, r7, r4, r1
    1a86:	fb05 f101 	mul.w	r1, r5, r1
    1a8a:	fbb1 f4f4 	udiv	r4, r1, r4
			length = print_formatted(output,
    1a8e:	9402      	str	r4, [sp, #8]
    1a90:	9701      	str	r7, [sp, #4]
    1a92:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
    1a96:	eba6 0181 	sub.w	r1, r6, r1, lsl #2
    1a9a:	9100      	str	r1, [sp, #0]
    1a9c:	4906      	ldr	r1, [pc, #24]	; (1ab8 <timestamp_print+0x88>)
    1a9e:	f7ff ffb5 	bl	1a0c <print_formatted>
    1aa2:	e7ce      	b.n	1a42 <timestamp_print+0x12>
    1aa4:	20000404 	.word	0x20000404
    1aa8:	00007bc8 	.word	0x00007bc8
    1aac:	20000408 	.word	0x20000408
    1ab0:	91a2b3c5 	.word	0x91a2b3c5
    1ab4:	88888889 	.word	0x88888889
    1ab8:	00007bd4 	.word	0x00007bd4

00001abc <color_print>:

static void color_print(const struct log_output *output,
			bool color, bool start, uint32_t level)
{
	if (color) {
    1abc:	b161      	cbz	r1, 1ad8 <color_print+0x1c>
{
    1abe:	b508      	push	{r3, lr}
		const char *log_color = start && (colors[level] != NULL) ?
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    1ac0:	b12a      	cbz	r2, 1ace <color_print+0x12>
		const char *log_color = start && (colors[level] != NULL) ?
    1ac2:	4a06      	ldr	r2, [pc, #24]	; (1adc <color_print+0x20>)
    1ac4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1ac8:	b912      	cbnz	r2, 1ad0 <color_print+0x14>
				colors[level] : LOG_COLOR_CODE_DEFAULT;
    1aca:	4a05      	ldr	r2, [pc, #20]	; (1ae0 <color_print+0x24>)
    1acc:	e000      	b.n	1ad0 <color_print+0x14>
    1ace:	4a04      	ldr	r2, [pc, #16]	; (1ae0 <color_print+0x24>)
		print_formatted(output, "%s", log_color);
    1ad0:	4904      	ldr	r1, [pc, #16]	; (1ae4 <color_print+0x28>)
    1ad2:	f7ff ff9b 	bl	1a0c <print_formatted>
	}
}
    1ad6:	bd08      	pop	{r3, pc}
    1ad8:	4770      	bx	lr
    1ada:	bf00      	nop
    1adc:	00007c50 	.word	0x00007c50
    1ae0:	00007bf0 	.word	0x00007bf0
    1ae4:	00007bf8 	.word	0x00007bf8

00001ae8 <newline_print>:
	if (IS_ENABLED(CONFIG_LOG_BACKEND_NET) &&
	    flags & LOG_OUTPUT_FLAG_FORMAT_SYSLOG) {
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
    1ae8:	f011 0f10 	tst.w	r1, #16
    1aec:	d10b      	bne.n	1b06 <newline_print+0x1e>
{
    1aee:	b508      	push	{r3, lr}
		return;
	}

	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
    1af0:	f011 0f20 	tst.w	r1, #32
    1af4:	d003      	beq.n	1afe <newline_print+0x16>
		print_formatted(ctx, "\n");
    1af6:	4904      	ldr	r1, [pc, #16]	; (1b08 <newline_print+0x20>)
    1af8:	f7ff ff88 	bl	1a0c <print_formatted>
	} else {
		print_formatted(ctx, "\r\n");
	}
}
    1afc:	bd08      	pop	{r3, pc}
		print_formatted(ctx, "\r\n");
    1afe:	4903      	ldr	r1, [pc, #12]	; (1b0c <newline_print+0x24>)
    1b00:	f7ff ff84 	bl	1a0c <print_formatted>
    1b04:	e7fa      	b.n	1afc <newline_print+0x14>
    1b06:	4770      	bx	lr
    1b08:	00007ae4 	.word	0x00007ae4
    1b0c:	00007bfc 	.word	0x00007bfc

00001b10 <hexdump_line_print>:
}

static void hexdump_line_print(const struct log_output *output,
			       const uint8_t *data, uint32_t length,
			       int prefix_offset, uint32_t flags)
{
    1b10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1b14:	4605      	mov	r5, r0
    1b16:	460f      	mov	r7, r1
    1b18:	4616      	mov	r6, r2
    1b1a:	4698      	mov	r8, r3
	newline_print(output, flags);
    1b1c:	9906      	ldr	r1, [sp, #24]
    1b1e:	f7ff ffe3 	bl	1ae8 <newline_print>

	for (int i = 0; i < prefix_offset; i++) {
    1b22:	2400      	movs	r4, #0
    1b24:	4544      	cmp	r4, r8
    1b26:	da05      	bge.n	1b34 <hexdump_line_print+0x24>
		print_formatted(output, " ");
    1b28:	4923      	ldr	r1, [pc, #140]	; (1bb8 <hexdump_line_print+0xa8>)
    1b2a:	4628      	mov	r0, r5
    1b2c:	f7ff ff6e 	bl	1a0c <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
    1b30:	3401      	adds	r4, #1
    1b32:	e7f7      	b.n	1b24 <hexdump_line_print+0x14>
	}

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    1b34:	2400      	movs	r4, #0
    1b36:	e009      	b.n	1b4c <hexdump_line_print+0x3c>
		if (i > 0 && !(i % 8)) {
			print_formatted(output, " ");
    1b38:	491f      	ldr	r1, [pc, #124]	; (1bb8 <hexdump_line_print+0xa8>)
    1b3a:	4628      	mov	r0, r5
    1b3c:	f7ff ff66 	bl	1a0c <print_formatted>
    1b40:	e00b      	b.n	1b5a <hexdump_line_print+0x4a>
		}

		if (i < length) {
			print_formatted(output, "%02x ", data[i]);
		} else {
			print_formatted(output, "   ");
    1b42:	491e      	ldr	r1, [pc, #120]	; (1bbc <hexdump_line_print+0xac>)
    1b44:	4628      	mov	r0, r5
    1b46:	f7ff ff61 	bl	1a0c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    1b4a:	3401      	adds	r4, #1
    1b4c:	2c0f      	cmp	r4, #15
    1b4e:	dc0c      	bgt.n	1b6a <hexdump_line_print+0x5a>
		if (i > 0 && !(i % 8)) {
    1b50:	2c00      	cmp	r4, #0
    1b52:	dd02      	ble.n	1b5a <hexdump_line_print+0x4a>
    1b54:	f014 0f07 	tst.w	r4, #7
    1b58:	d0ee      	beq.n	1b38 <hexdump_line_print+0x28>
		if (i < length) {
    1b5a:	42b4      	cmp	r4, r6
    1b5c:	d2f1      	bcs.n	1b42 <hexdump_line_print+0x32>
			print_formatted(output, "%02x ", data[i]);
    1b5e:	5d3a      	ldrb	r2, [r7, r4]
    1b60:	4917      	ldr	r1, [pc, #92]	; (1bc0 <hexdump_line_print+0xb0>)
    1b62:	4628      	mov	r0, r5
    1b64:	f7ff ff52 	bl	1a0c <print_formatted>
    1b68:	e7ef      	b.n	1b4a <hexdump_line_print+0x3a>
		}
	}

	print_formatted(output, "|");
    1b6a:	4916      	ldr	r1, [pc, #88]	; (1bc4 <hexdump_line_print+0xb4>)
    1b6c:	4628      	mov	r0, r5
    1b6e:	f7ff ff4d 	bl	1a0c <print_formatted>

	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    1b72:	2400      	movs	r4, #0
    1b74:	e009      	b.n	1b8a <hexdump_line_print+0x7a>
		if (i > 0 && !(i % 8)) {
			print_formatted(output, " ");
    1b76:	4910      	ldr	r1, [pc, #64]	; (1bb8 <hexdump_line_print+0xa8>)
    1b78:	4628      	mov	r0, r5
    1b7a:	f7ff ff47 	bl	1a0c <print_formatted>
    1b7e:	e00b      	b.n	1b98 <hexdump_line_print+0x88>
		}

		if (i < length) {
			char c = (char)data[i];

			print_formatted(output, "%c",
    1b80:	4911      	ldr	r1, [pc, #68]	; (1bc8 <hexdump_line_print+0xb8>)
    1b82:	4628      	mov	r0, r5
    1b84:	f7ff ff42 	bl	1a0c <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
    1b88:	3401      	adds	r4, #1
    1b8a:	2c0f      	cmp	r4, #15
    1b8c:	dc12      	bgt.n	1bb4 <hexdump_line_print+0xa4>
		if (i > 0 && !(i % 8)) {
    1b8e:	2c00      	cmp	r4, #0
    1b90:	dd02      	ble.n	1b98 <hexdump_line_print+0x88>
    1b92:	f014 0f07 	tst.w	r4, #7
    1b96:	d0ee      	beq.n	1b76 <hexdump_line_print+0x66>
		if (i < length) {
    1b98:	42b4      	cmp	r4, r6
    1b9a:	d206      	bcs.n	1baa <hexdump_line_print+0x9a>
			char c = (char)data[i];
    1b9c:	5d3a      	ldrb	r2, [r7, r4]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
    1b9e:	f1a2 0320 	sub.w	r3, r2, #32
			print_formatted(output, "%c",
    1ba2:	2b5e      	cmp	r3, #94	; 0x5e
    1ba4:	d9ec      	bls.n	1b80 <hexdump_line_print+0x70>
    1ba6:	222e      	movs	r2, #46	; 0x2e
    1ba8:	e7ea      	b.n	1b80 <hexdump_line_print+0x70>
			      isprint((int)c) ? c : '.');
		} else {
			print_formatted(output, " ");
    1baa:	4903      	ldr	r1, [pc, #12]	; (1bb8 <hexdump_line_print+0xa8>)
    1bac:	4628      	mov	r0, r5
    1bae:	f7ff ff2d 	bl	1a0c <print_formatted>
    1bb2:	e7e9      	b.n	1b88 <hexdump_line_print+0x78>
		}
	}
}
    1bb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1bb8:	00007c24 	.word	0x00007c24
    1bbc:	00007c08 	.word	0x00007c08
    1bc0:	00007c00 	.word	0x00007c00
    1bc4:	00007c0c 	.word	0x00007c0c
    1bc8:	00007c10 	.word	0x00007c10

00001bcc <ids_print>:
{
    1bcc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1bd0:	4680      	mov	r8, r0
    1bd2:	4616      	mov	r6, r2
    1bd4:	461d      	mov	r5, r3
    1bd6:	f9bd 7018 	ldrsh.w	r7, [sp, #24]
	if (level_on) {
    1bda:	b959      	cbnz	r1, 1bf4 <ids_print+0x28>
	int total = 0;
    1bdc:	2400      	movs	r4, #0
	if (source_id >= 0) {
    1bde:	2f00      	cmp	r7, #0
    1be0:	db1c      	blt.n	1c1c <ids_print+0x50>
		total += print_formatted(output,
    1be2:	b186      	cbz	r6, 1c06 <ids_print+0x3a>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
    1be4:	2301      	movs	r3, #1
    1be6:	9a07      	ldr	r2, [sp, #28]
    1be8:	4093      	lsls	r3, r2
				(func_on &&
    1bea:	f013 0f10 	tst.w	r3, #16
    1bee:	d118      	bne.n	1c22 <ids_print+0x56>
		total += print_formatted(output,
    1bf0:	4e0d      	ldr	r6, [pc, #52]	; (1c28 <ids_print+0x5c>)
    1bf2:	e009      	b.n	1c08 <ids_print+0x3c>
		total += print_formatted(output, "<%s> ", severity[level]);
    1bf4:	4b0d      	ldr	r3, [pc, #52]	; (1c2c <ids_print+0x60>)
    1bf6:	9a07      	ldr	r2, [sp, #28]
    1bf8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    1bfc:	490c      	ldr	r1, [pc, #48]	; (1c30 <ids_print+0x64>)
    1bfe:	f7ff ff05 	bl	1a0c <print_formatted>
    1c02:	4604      	mov	r4, r0
    1c04:	e7eb      	b.n	1bde <ids_print+0x12>
		total += print_formatted(output,
    1c06:	4e08      	ldr	r6, [pc, #32]	; (1c28 <ids_print+0x5c>)
    1c08:	4639      	mov	r1, r7
    1c0a:	4628      	mov	r0, r5
    1c0c:	f7ff fb5c 	bl	12c8 <log_source_name_get>
    1c10:	4602      	mov	r2, r0
    1c12:	4631      	mov	r1, r6
    1c14:	4640      	mov	r0, r8
    1c16:	f7ff fef9 	bl	1a0c <print_formatted>
    1c1a:	4404      	add	r4, r0
}
    1c1c:	4620      	mov	r0, r4
    1c1e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		total += print_formatted(output,
    1c22:	4e04      	ldr	r6, [pc, #16]	; (1c34 <ids_print+0x68>)
    1c24:	e7f0      	b.n	1c08 <ids_print+0x3c>
    1c26:	bf00      	nop
    1c28:	00007c14 	.word	0x00007c14
    1c2c:	00007c8c 	.word	0x00007c8c
    1c30:	00007c20 	.word	0x00007c20
    1c34:	00007c1c 	.word	0x00007c1c

00001c38 <hexdump_print>:

static void hexdump_print(struct log_msg *msg,
			  const struct log_output *output,
			  int prefix_offset, uint32_t flags)
{
    1c38:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1c3c:	b089      	sub	sp, #36	; 0x24
    1c3e:	4607      	mov	r7, r0
    1c40:	460e      	mov	r6, r1
    1c42:	4691      	mov	r9, r2
    1c44:	4698      	mov	r8, r3
	uint32_t offset = 0U;
	uint8_t buf[HEXDUMP_BYTES_IN_LINE];
	size_t length;

	print_formatted(output, "%s", log_msg_str_get(msg));
    1c46:	f004 faa0 	bl	618a <log_msg_str_get>
    1c4a:	4602      	mov	r2, r0
    1c4c:	490e      	ldr	r1, [pc, #56]	; (1c88 <hexdump_print+0x50>)
    1c4e:	4630      	mov	r0, r6
    1c50:	f7ff fedc 	bl	1a0c <print_formatted>
	uint32_t offset = 0U;
    1c54:	2400      	movs	r4, #0

	do {
		length = sizeof(buf);
    1c56:	2510      	movs	r5, #16
    1c58:	9503      	str	r5, [sp, #12]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
    1c5a:	4623      	mov	r3, r4
    1c5c:	aa03      	add	r2, sp, #12
    1c5e:	eb0d 0105 	add.w	r1, sp, r5
    1c62:	4638      	mov	r0, r7
    1c64:	f004 fafe 	bl	6264 <log_msg_hexdump_data_get>

		if (length) {
    1c68:	9a03      	ldr	r2, [sp, #12]
    1c6a:	b152      	cbz	r2, 1c82 <hexdump_print+0x4a>
			hexdump_line_print(output, buf, length,
    1c6c:	f8cd 8000 	str.w	r8, [sp]
    1c70:	464b      	mov	r3, r9
    1c72:	eb0d 0105 	add.w	r1, sp, r5
    1c76:	4630      	mov	r0, r6
    1c78:	f7ff ff4a 	bl	1b10 <hexdump_line_print>
					   prefix_offset, flags);
			offset += length;
    1c7c:	9d03      	ldr	r5, [sp, #12]
    1c7e:	442c      	add	r4, r5
		length = sizeof(buf);
    1c80:	e7e9      	b.n	1c56 <hexdump_print+0x1e>
		} else {
			break;
		}
	} while (true);
}
    1c82:	b009      	add	sp, #36	; 0x24
    1c84:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    1c88:	00007bf8 	.word	0x00007bf8

00001c8c <raw_string_print>:
}


static void raw_string_print(struct log_msg *msg,
			     const struct log_output *output)
{
    1c8c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1c8e:	b083      	sub	sp, #12
    1c90:	4606      	mov	r6, r0
    1c92:	460c      	mov	r4, r1
	__ASSERT_NO_MSG(output->size);

	size_t offset = 0;
	size_t length;
	bool eol = false;
    1c94:	2700      	movs	r7, #0
	size_t offset = 0;
    1c96:	463d      	mov	r5, r7
    1c98:	e00d      	b.n	1cb6 <raw_string_print+0x2a>
		/* Sting is stored in a hexdump message. */
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
		output->control_block->offset = length;

		if (length != 0) {
			eol = (output->buf[length - 1] == '\n');
    1c9a:	68a2      	ldr	r2, [r4, #8]
    1c9c:	4413      	add	r3, r2
    1c9e:	f813 7c01 	ldrb.w	r7, [r3, #-1]
    1ca2:	2f0a      	cmp	r7, #10
    1ca4:	bf14      	ite	ne
    1ca6:	2700      	movne	r7, #0
    1ca8:	2701      	moveq	r7, #1
		}

		log_output_flush(output);
    1caa:	4620      	mov	r0, r4
    1cac:	f004 fc89 	bl	65c2 <log_output_flush>
		offset += length;
    1cb0:	9b01      	ldr	r3, [sp, #4]
    1cb2:	441d      	add	r5, r3
	} while (length > 0);
    1cb4:	b173      	cbz	r3, 1cd4 <raw_string_print+0x48>
		length = output->size;
    1cb6:	68e3      	ldr	r3, [r4, #12]
    1cb8:	9301      	str	r3, [sp, #4]
		log_msg_hexdump_data_get(msg, output->buf, &length, offset);
    1cba:	462b      	mov	r3, r5
    1cbc:	aa01      	add	r2, sp, #4
    1cbe:	68a1      	ldr	r1, [r4, #8]
    1cc0:	4630      	mov	r0, r6
    1cc2:	f004 facf 	bl	6264 <log_msg_hexdump_data_get>
		output->control_block->offset = length;
    1cc6:	6863      	ldr	r3, [r4, #4]
    1cc8:	9a01      	ldr	r2, [sp, #4]
    1cca:	601a      	str	r2, [r3, #0]
		if (length != 0) {
    1ccc:	9b01      	ldr	r3, [sp, #4]
    1cce:	2b00      	cmp	r3, #0
    1cd0:	d0eb      	beq.n	1caa <raw_string_print+0x1e>
    1cd2:	e7e2      	b.n	1c9a <raw_string_print+0xe>

	if (eol) {
    1cd4:	b90f      	cbnz	r7, 1cda <raw_string_print+0x4e>
		print_formatted(output, "\r");
	}
}
    1cd6:	b003      	add	sp, #12
    1cd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		print_formatted(output, "\r");
    1cda:	4902      	ldr	r1, [pc, #8]	; (1ce4 <raw_string_print+0x58>)
    1cdc:	4620      	mov	r0, r4
    1cde:	f7ff fe95 	bl	1a0c <print_formatted>
}
    1ce2:	e7f8      	b.n	1cd6 <raw_string_print+0x4a>
    1ce4:	00007c28 	.word	0x00007c28

00001ce8 <log_output_dropped_process>:
	postfix_print(output, flags, level);
	log_output_flush(output);
}

void log_output_dropped_process(const struct log_output *output, uint32_t cnt)
{
    1ce8:	b570      	push	{r4, r5, r6, lr}
    1cea:	b082      	sub	sp, #8
    1cec:	4604      	mov	r4, r0
	char buf[5];
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = output->func;
    1cee:	6805      	ldr	r5, [r0, #0]

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
    1cf0:	f242 730f 	movw	r3, #9999	; 0x270f
    1cf4:	428b      	cmp	r3, r1
    1cf6:	bf28      	it	cs
    1cf8:	460b      	movcs	r3, r1
    1cfa:	4a0e      	ldr	r2, [pc, #56]	; (1d34 <log_output_dropped_process+0x4c>)
    1cfc:	2105      	movs	r1, #5
    1cfe:	4668      	mov	r0, sp
    1d00:	f003 ff6c 	bl	5bdc <snprintk>
    1d04:	4606      	mov	r6, r0

	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
		     output->control_block->ctx);
    1d06:	6863      	ldr	r3, [r4, #4]
	buffer_write(outf, (uint8_t *)prefix, sizeof(prefix) - 1,
    1d08:	685b      	ldr	r3, [r3, #4]
    1d0a:	220b      	movs	r2, #11
    1d0c:	490a      	ldr	r1, [pc, #40]	; (1d38 <log_output_dropped_process+0x50>)
    1d0e:	4628      	mov	r0, r5
    1d10:	f004 fab0 	bl	6274 <buffer_write>
	buffer_write(outf, buf, len, output->control_block->ctx);
    1d14:	6863      	ldr	r3, [r4, #4]
    1d16:	685b      	ldr	r3, [r3, #4]
    1d18:	4632      	mov	r2, r6
    1d1a:	4669      	mov	r1, sp
    1d1c:	4628      	mov	r0, r5
    1d1e:	f004 faa9 	bl	6274 <buffer_write>
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
		     output->control_block->ctx);
    1d22:	6863      	ldr	r3, [r4, #4]
	buffer_write(outf, (uint8_t *)postfix, sizeof(postfix) - 1,
    1d24:	685b      	ldr	r3, [r3, #4]
    1d26:	221b      	movs	r2, #27
    1d28:	4904      	ldr	r1, [pc, #16]	; (1d3c <log_output_dropped_process+0x54>)
    1d2a:	4628      	mov	r0, r5
    1d2c:	f004 faa2 	bl	6274 <buffer_write>
}
    1d30:	b002      	add	sp, #8
    1d32:	bd70      	pop	{r4, r5, r6, pc}
    1d34:	00007c2c 	.word	0x00007c2c
    1d38:	00007c80 	.word	0x00007c80
    1d3c:	00007c64 	.word	0x00007c64

00001d40 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(uint32_t frequency)
{
	timestamp_div = 1U;
    1d40:	4b07      	ldr	r3, [pc, #28]	; (1d60 <log_output_timestamp_freq_set+0x20>)
    1d42:	2201      	movs	r2, #1
    1d44:	601a      	str	r2, [r3, #0]
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
    1d46:	4b07      	ldr	r3, [pc, #28]	; (1d64 <log_output_timestamp_freq_set+0x24>)
    1d48:	4298      	cmp	r0, r3
    1d4a:	d905      	bls.n	1d58 <log_output_timestamp_freq_set+0x18>
		frequency /= 2U;
    1d4c:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
    1d4e:	4a04      	ldr	r2, [pc, #16]	; (1d60 <log_output_timestamp_freq_set+0x20>)
    1d50:	6813      	ldr	r3, [r2, #0]
    1d52:	005b      	lsls	r3, r3, #1
    1d54:	6013      	str	r3, [r2, #0]
    1d56:	e7f6      	b.n	1d46 <log_output_timestamp_freq_set+0x6>
	}

	freq = frequency;
    1d58:	4b03      	ldr	r3, [pc, #12]	; (1d68 <log_output_timestamp_freq_set+0x28>)
    1d5a:	6018      	str	r0, [r3, #0]
}
    1d5c:	4770      	bx	lr
    1d5e:	bf00      	nop
    1d60:	20000408 	.word	0x20000408
    1d64:	000f4240 	.word	0x000f4240
    1d68:	20000404 	.word	0x20000404

00001d6c <char_out>:
static const char LOG_HEX_SEP[10] = "##ZLOGV1##";

static const struct device *uart_dev;

static int char_out(uint8_t *data, size_t length, void *ctx)
{
    1d6c:	b570      	push	{r4, r5, r6, lr}
    1d6e:	4606      	mov	r6, r0
    1d70:	460d      	mov	r5, r1
	ARG_UNUSED(ctx);

	for (size_t i = 0; i < length; i++) {
    1d72:	2400      	movs	r4, #0
    1d74:	42ac      	cmp	r4, r5
    1d76:	d207      	bcs.n	1d88 <char_out+0x1c>
		/* lower 8-bit */
		x = data[i] & 0x0FU;
		(void)hex2char(x, &c);
		uart_poll_out(uart_dev, c);
#else
		uart_poll_out(uart_dev, data[i]);
    1d78:	4b04      	ldr	r3, [pc, #16]	; (1d8c <char_out+0x20>)
    1d7a:	6818      	ldr	r0, [r3, #0]
    1d7c:	5d31      	ldrb	r1, [r6, r4]
				      unsigned char out_char);

static inline void z_impl_uart_poll_out(const struct device *dev,
						unsigned char out_char)
{
	const struct uart_driver_api *api =
    1d7e:	6883      	ldr	r3, [r0, #8]
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    1d80:	685b      	ldr	r3, [r3, #4]
    1d82:	4798      	blx	r3
	for (size_t i = 0; i < length; i++) {
    1d84:	3401      	adds	r4, #1
    1d86:	e7f5      	b.n	1d74 <char_out+0x8>
#endif
	}

	return length;
}
    1d88:	4628      	mov	r0, r5
    1d8a:	bd70      	pop	{r4, r5, r6, pc}
    1d8c:	20000420 	.word	0x20000420

00001d90 <log_backend_uart_init>:
		log_output_msg2_process(&log_output_uart, &msg->log, flags);
	}
}

static void log_backend_uart_init(struct log_backend const *const backend)
{
    1d90:	b508      	push	{r3, lr}
    1d92:	4803      	ldr	r0, [pc, #12]	; (1da0 <log_backend_uart_init+0x10>)
    1d94:	f002 fae2 	bl	435c <z_impl_device_get_binding>
	uart_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    1d98:	4b02      	ldr	r3, [pc, #8]	; (1da4 <log_backend_uart_init+0x14>)
    1d9a:	6018      	str	r0, [r3, #0]
		 */
		for (int i = 0; i < sizeof(LOG_HEX_SEP); i++) {
			uart_poll_out(uart_dev, LOG_HEX_SEP[i]);
		}
	}
}
    1d9c:	bd08      	pop	{r3, pc}
    1d9e:	bf00      	nop
    1da0:	00007ca0 	.word	0x00007ca0
    1da4:	20000420 	.word	0x20000420

00001da8 <panic>:

static void panic(struct log_backend const *const backend)
{
    1da8:	b508      	push	{r3, lr}
 * @param output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const output)
{
	log_output_flush(output);
    1daa:	4802      	ldr	r0, [pc, #8]	; (1db4 <panic+0xc>)
    1dac:	f004 fc09 	bl	65c2 <log_output_flush>
	log_backend_std_panic(&log_output_uart);
}
    1db0:	bd08      	pop	{r3, pc}
    1db2:	bf00      	nop
    1db4:	00007cd8 	.word	0x00007cd8

00001db8 <dropped>:

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
    1db8:	b508      	push	{r3, lr}
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const output, uint32_t cnt)
{
	log_output_dropped_process(output, cnt);
    1dba:	4802      	ldr	r0, [pc, #8]	; (1dc4 <dropped+0xc>)
    1dbc:	f7ff ff94 	bl	1ce8 <log_output_dropped_process>
	if (IS_ENABLED(CONFIG_LOG_BACKEND_UART_OUTPUT_DICTIONARY)) {
		log_dict_output_dropped_process(&log_output_uart, cnt);
	} else {
		log_backend_std_dropped(&log_output_uart, cnt);
	}
}
    1dc0:	bd08      	pop	{r3, pc}
    1dc2:	bf00      	nop
    1dc4:	00007cd8 	.word	0x00007cd8

00001dc8 <put>:
{
    1dc8:	b510      	push	{r4, lr}
    1dca:	460c      	mov	r4, r1
	log_msg_get(msg);
    1dcc:	4608      	mov	r0, r1
    1dce:	f004 f9ba 	bl	6146 <log_msg_get>
	log_output_msg_process(output, msg, flags);
    1dd2:	220f      	movs	r2, #15
    1dd4:	4621      	mov	r1, r4
    1dd6:	4803      	ldr	r0, [pc, #12]	; (1de4 <put+0x1c>)
    1dd8:	f004 fc1c 	bl	6614 <log_output_msg_process>
	log_msg_put(msg);
    1ddc:	4620      	mov	r0, r4
    1dde:	f004 f9d6 	bl	618e <log_msg_put>
}
    1de2:	bd10      	pop	{r4, pc}
    1de4:	00007cd8 	.word	0x00007cd8

00001de8 <log_backend_rtt_init>:
{
	if (CONFIG_LOG_BACKEND_RTT_BUFFER > 0) {
		log_backend_rtt_cfg();
	}

	host_present = true;
    1de8:	4b01      	ldr	r3, [pc, #4]	; (1df0 <log_backend_rtt_init+0x8>)
    1dea:	2201      	movs	r2, #1
    1dec:	701a      	strb	r2, [r3, #0]
	line_pos = line_buf;
}
    1dee:	4770      	bx	lr
    1df0:	20000a73 	.word	0x20000a73

00001df4 <on_failed_write>:
{
    1df4:	b508      	push	{r3, lr}
	if (retry_cnt == 0) {
    1df6:	b918      	cbnz	r0, 1e00 <on_failed_write+0xc>
		host_present = false;
    1df8:	4b08      	ldr	r3, [pc, #32]	; (1e1c <on_failed_write+0x28>)
    1dfa:	2200      	movs	r2, #0
    1dfc:	701a      	strb	r2, [r3, #0]
}
    1dfe:	bd08      	pop	{r3, pc}
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    1e00:	4b07      	ldr	r3, [pc, #28]	; (1e20 <on_failed_write+0x2c>)
    1e02:	781b      	ldrb	r3, [r3, #0]
	} else if (is_sync_mode()) {
    1e04:	b123      	cbz	r3, 1e10 <on_failed_write+0x1c>
	z_impl_k_busy_wait(usec_to_wait);
    1e06:	f241 3088 	movw	r0, #5000	; 0x1388
    1e0a:	f005 fcb3 	bl	7774 <z_impl_k_busy_wait>
}
    1e0e:	e7f6      	b.n	1dfe <on_failed_write+0xa>
	return z_impl_k_sleep(timeout);
    1e10:	20a4      	movs	r0, #164	; 0xa4
    1e12:	2100      	movs	r1, #0
    1e14:	f003 fbca 	bl	55ac <z_impl_k_sleep>
}
    1e18:	e7f1      	b.n	1dfe <on_failed_write+0xa>
    1e1a:	bf00      	nop
    1e1c:	20000a73 	.word	0x20000a73
    1e20:	20000a74 	.word	0x20000a74

00001e24 <on_write>:
{
    1e24:	b538      	push	{r3, r4, r5, lr}
    1e26:	4604      	mov	r4, r0
	host_present = true;
    1e28:	4b0a      	ldr	r3, [pc, #40]	; (1e54 <on_write+0x30>)
    1e2a:	2201      	movs	r2, #1
    1e2c:	701a      	strb	r2, [r3, #0]
	return panic_mode;
    1e2e:	4b0a      	ldr	r3, [pc, #40]	; (1e58 <on_write+0x34>)
    1e30:	781b      	ldrb	r3, [r3, #0]
	if (is_panic_mode()) {
    1e32:	b903      	cbnz	r3, 1e36 <on_write+0x12>
}
    1e34:	bd38      	pop	{r3, r4, r5, pc}
		while (SEGGER_RTT_HasDataUp(CONFIG_LOG_BACKEND_RTT_BUFFER) &&
    1e36:	2000      	movs	r0, #0
    1e38:	f002 fa4c 	bl	42d4 <SEGGER_RTT_HasDataUp>
    1e3c:	2800      	cmp	r0, #0
    1e3e:	d0f9      	beq.n	1e34 <on_write+0x10>
    1e40:	4b04      	ldr	r3, [pc, #16]	; (1e54 <on_write+0x30>)
    1e42:	781b      	ldrb	r3, [r3, #0]
    1e44:	2b00      	cmp	r3, #0
    1e46:	d0f5      	beq.n	1e34 <on_write+0x10>
			on_failed_write(retry_cnt--);
    1e48:	1e65      	subs	r5, r4, #1
    1e4a:	4620      	mov	r0, r4
    1e4c:	f7ff ffd2 	bl	1df4 <on_failed_write>
    1e50:	462c      	mov	r4, r5
    1e52:	e7f0      	b.n	1e36 <on_write+0x12>
    1e54:	20000a73 	.word	0x20000a73
    1e58:	20000a74 	.word	0x20000a74

00001e5c <data_out_block_mode>:
{
    1e5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1e60:	4606      	mov	r6, r0
    1e62:	460d      	mov	r5, r1
	int retry_cnt = IS_ENABLED(CONFIG_LOG_BACKEND_RTT_MODE_BLOCK) ?
    1e64:	2704      	movs	r7, #4
    1e66:	e00d      	b.n	1e84 <data_out_block_mode+0x28>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    1e68:	462a      	mov	r2, r5
    1e6a:	4631      	mov	r1, r6
    1e6c:	2000      	movs	r0, #0
    1e6e:	f002 f9cd 	bl	420c <SEGGER_RTT_WriteSkipNoLock>
    1e72:	4604      	mov	r4, r0
    1e74:	e01c      	b.n	1eb0 <data_out_block_mode+0x54>
			on_write(retry_cnt);
    1e76:	4638      	mov	r0, r7
    1e78:	f7ff ffd4 	bl	1e24 <on_write>
	} while ((ret == 0) && host_present);
    1e7c:	bb1c      	cbnz	r4, 1ec6 <data_out_block_mode+0x6a>
    1e7e:	4b16      	ldr	r3, [pc, #88]	; (1ed8 <data_out_block_mode+0x7c>)
    1e80:	781b      	ldrb	r3, [r3, #0]
    1e82:	b303      	cbz	r3, 1ec6 <data_out_block_mode+0x6a>
	return IS_ENABLED(CONFIG_LOG_IMMEDIATE) || panic_mode;
    1e84:	4b15      	ldr	r3, [pc, #84]	; (1edc <data_out_block_mode+0x80>)
    1e86:	781b      	ldrb	r3, [r3, #0]
		if (!is_sync_mode()) {
    1e88:	2b00      	cmp	r3, #0
    1e8a:	d1ed      	bne.n	1e68 <data_out_block_mode+0xc>
	return z_impl_k_mutex_lock(mutex, timeout);
    1e8c:	f8df 8050 	ldr.w	r8, [pc, #80]	; 1ee0 <data_out_block_mode+0x84>
    1e90:	f04f 32ff 	mov.w	r2, #4294967295
    1e94:	f04f 33ff 	mov.w	r3, #4294967295
    1e98:	4640      	mov	r0, r8
    1e9a:	f002 fd73 	bl	4984 <z_impl_k_mutex_lock>
			ret = SEGGER_RTT_WriteSkipNoLock(CONFIG_LOG_BACKEND_RTT_BUFFER,
    1e9e:	462a      	mov	r2, r5
    1ea0:	4631      	mov	r1, r6
    1ea2:	2000      	movs	r0, #0
    1ea4:	f002 f9b2 	bl	420c <SEGGER_RTT_WriteSkipNoLock>
    1ea8:	4604      	mov	r4, r0
	return z_impl_k_mutex_unlock(mutex);
    1eaa:	4640      	mov	r0, r8
    1eac:	f002 fdf4 	bl	4a98 <z_impl_k_mutex_unlock>
		if (ret) {
    1eb0:	2c00      	cmp	r4, #0
    1eb2:	d1e0      	bne.n	1e76 <data_out_block_mode+0x1a>
		} else if (host_present) {
    1eb4:	4b08      	ldr	r3, [pc, #32]	; (1ed8 <data_out_block_mode+0x7c>)
    1eb6:	781b      	ldrb	r3, [r3, #0]
    1eb8:	2b00      	cmp	r3, #0
    1eba:	d0df      	beq.n	1e7c <data_out_block_mode+0x20>
			retry_cnt--;
    1ebc:	3f01      	subs	r7, #1
			on_failed_write(retry_cnt);
    1ebe:	4638      	mov	r0, r7
    1ec0:	f7ff ff98 	bl	1df4 <on_failed_write>
    1ec4:	e7da      	b.n	1e7c <data_out_block_mode+0x20>
	return ((ret == 0) && host_present) ? 0 : length;
    1ec6:	b914      	cbnz	r4, 1ece <data_out_block_mode+0x72>
    1ec8:	4b03      	ldr	r3, [pc, #12]	; (1ed8 <data_out_block_mode+0x7c>)
    1eca:	781b      	ldrb	r3, [r3, #0]
    1ecc:	b903      	cbnz	r3, 1ed0 <data_out_block_mode+0x74>
    1ece:	462c      	mov	r4, r5
}
    1ed0:	4620      	mov	r0, r4
    1ed2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1ed6:	bf00      	nop
    1ed8:	20000a73 	.word	0x20000a73
    1edc:	20000a74 	.word	0x20000a74
    1ee0:	20000030 	.word	0x20000030

00001ee4 <panic>:

static void panic(struct log_backend const *const backend)
{
    1ee4:	b508      	push	{r3, lr}
	panic_mode = true;
    1ee6:	4b03      	ldr	r3, [pc, #12]	; (1ef4 <panic+0x10>)
    1ee8:	2201      	movs	r2, #1
    1eea:	701a      	strb	r2, [r3, #0]
	log_output_flush(output);
    1eec:	4802      	ldr	r0, [pc, #8]	; (1ef8 <panic+0x14>)
    1eee:	f004 fb68 	bl	65c2 <log_output_flush>
	log_backend_std_panic(&log_output_rtt);
}
    1ef2:	bd08      	pop	{r3, pc}
    1ef4:	20000a74 	.word	0x20000a74
    1ef8:	00007d14 	.word	0x00007d14

00001efc <dropped>:

static void dropped(const struct log_backend *const backend, uint32_t cnt)
{
    1efc:	b508      	push	{r3, lr}
	log_output_dropped_process(output, cnt);
    1efe:	4802      	ldr	r0, [pc, #8]	; (1f08 <dropped+0xc>)
    1f00:	f7ff fef2 	bl	1ce8 <log_output_dropped_process>
	ARG_UNUSED(backend);

	log_backend_std_dropped(&log_output_rtt, cnt);
}
    1f04:	bd08      	pop	{r3, pc}
    1f06:	bf00      	nop
    1f08:	00007d14 	.word	0x00007d14

00001f0c <put>:
{
    1f0c:	b510      	push	{r4, lr}
    1f0e:	460c      	mov	r4, r1
	log_msg_get(msg);
    1f10:	4608      	mov	r0, r1
    1f12:	f004 f918 	bl	6146 <log_msg_get>
	log_output_msg_process(output, msg, flags);
    1f16:	220f      	movs	r2, #15
    1f18:	4621      	mov	r1, r4
    1f1a:	4803      	ldr	r0, [pc, #12]	; (1f28 <put+0x1c>)
    1f1c:	f004 fb7a 	bl	6614 <log_output_msg_process>
	log_msg_put(msg);
    1f20:	4620      	mov	r0, r4
    1f22:	f004 f934 	bl	618e <log_msg_put>
}
    1f26:	bd10      	pop	{r4, pc}
    1f28:	00007d14 	.word	0x00007d14

00001f2c <pm_system_resume>:
	 * and it may schedule another thread.
	 *
	 * Call pm_idle_exit_notification_disable() if this
	 * notification is not required.
	 */
	if (!post_ops_done) {
    1f2c:	4b1b      	ldr	r3, [pc, #108]	; (1f9c <pm_system_resume+0x70>)
    1f2e:	681b      	ldr	r3, [r3, #0]
    1f30:	2b00      	cmp	r3, #0
    1f32:	d132      	bne.n	1f9a <pm_system_resume+0x6e>
{
    1f34:	b530      	push	{r4, r5, lr}
    1f36:	b085      	sub	sp, #20
		post_ops_done = 1;
    1f38:	4b18      	ldr	r3, [pc, #96]	; (1f9c <pm_system_resume+0x70>)
    1f3a:	2201      	movs	r2, #1
    1f3c:	601a      	str	r2, [r3, #0]
		exit_pos_ops(z_power_state);
    1f3e:	4b18      	ldr	r3, [pc, #96]	; (1fa0 <pm_system_resume+0x74>)
    1f40:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    1f44:	ab04      	add	r3, sp, #16
    1f46:	e903 0007 	stmdb	r3, {r0, r1, r2}
	if (pm_power_state_exit_post_ops != NULL) {
    1f4a:	4b16      	ldr	r3, [pc, #88]	; (1fa4 <pm_system_resume+0x78>)
    1f4c:	b163      	cbz	r3, 1f68 <pm_system_resume+0x3c>
		pm_power_state_exit_post_ops(info);
    1f4e:	f004 fdd7 	bl	6b00 <pm_power_state_exit_post_ops>
	__asm__ volatile(
    1f52:	f04f 0320 	mov.w	r3, #32
    1f56:	f3ef 8511 	mrs	r5, BASEPRI
    1f5a:	f383 8811 	msr	BASEPRI, r3
    1f5e:	f3bf 8f6f 	isb	sy
    1f62:	4b11      	ldr	r3, [pc, #68]	; (1fa8 <pm_system_resume+0x7c>)
    1f64:	681c      	ldr	r4, [r3, #0]
    1f66:	e00a      	b.n	1f7e <pm_system_resume+0x52>
	__asm__ volatile(
    1f68:	2300      	movs	r3, #0
    1f6a:	f383 8811 	msr	BASEPRI, r3
    1f6e:	f3bf 8f6f 	isb	sy
}
    1f72:	e7ee      	b.n	1f52 <pm_system_resume+0x26>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    1f74:	4623      	mov	r3, r4
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
    1f76:	b10c      	cbz	r4, 1f7c <pm_system_resume+0x50>
	return node->next;
    1f78:	6823      	ldr	r3, [r4, #0]
    1f7a:	b143      	cbz	r3, 1f8e <pm_system_resume+0x62>
{
    1f7c:	461c      	mov	r4, r3
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    1f7e:	b134      	cbz	r4, 1f8e <pm_system_resume+0x62>
			callback = notifier->state_exit;
    1f80:	68a3      	ldr	r3, [r4, #8]
		if (callback) {
    1f82:	2b00      	cmp	r3, #0
    1f84:	d0f6      	beq.n	1f74 <pm_system_resume+0x48>
			callback(z_power_state.state);
    1f86:	4a06      	ldr	r2, [pc, #24]	; (1fa0 <pm_system_resume+0x74>)
    1f88:	7810      	ldrb	r0, [r2, #0]
    1f8a:	4798      	blx	r3
    1f8c:	e7f2      	b.n	1f74 <pm_system_resume+0x48>
	__asm__ volatile(
    1f8e:	f385 8811 	msr	BASEPRI, r5
    1f92:	f3bf 8f6f 	isb	sy
		pm_state_notify(false);
	}
}
    1f96:	b005      	add	sp, #20
    1f98:	bd30      	pop	{r4, r5, pc}
    1f9a:	4770      	bx	lr
    1f9c:	20000008 	.word	0x20000008
    1fa0:	20000450 	.word	0x20000450
    1fa4:	00006b01 	.word	0x00006b01
    1fa8:	20000448 	.word	0x20000448

00001fac <pm_system_suspend>:
	return PM_STATE_ACTIVE;
}
#endif

enum pm_state pm_system_suspend(int32_t ticks)
{
    1fac:	b570      	push	{r4, r5, r6, lr}
    1fae:	b088      	sub	sp, #32
    1fb0:	4606      	mov	r6, r0
	SYS_PORT_TRACING_FUNC_ENTER(pm, system_suspend, ticks);
	z_power_state = pm_policy_next_state(ticks);
    1fb2:	4c2a      	ldr	r4, [pc, #168]	; (205c <pm_system_suspend+0xb0>)
    1fb4:	466d      	mov	r5, sp
    1fb6:	4601      	mov	r1, r0
    1fb8:	4628      	mov	r0, r5
    1fba:	f004 fb6a 	bl	6692 <pm_policy_next_state>
    1fbe:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
    1fc2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	if (z_power_state.state == PM_STATE_ACTIVE) {
    1fc6:	7820      	ldrb	r0, [r4, #0]
    1fc8:	2800      	cmp	r0, #0
    1fca:	d045      	beq.n	2058 <pm_system_suspend+0xac>
		LOG_DBG("No PM operations done.");
		SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks, z_power_state.state);
		return z_power_state.state;
	}
	post_ops_done = 0;
    1fcc:	4b24      	ldr	r3, [pc, #144]	; (2060 <pm_system_suspend+0xb4>)
    1fce:	2200      	movs	r2, #0
    1fd0:	601a      	str	r2, [r3, #0]

	if (ticks != K_TICKS_FOREVER) {
    1fd2:	f1b6 3fff 	cmp.w	r6, #4294967295
    1fd6:	d10c      	bne.n	1ff2 <pm_system_suspend+0x46>
	 * state. We don't want to be scheduled out yet, first we need
	 * to send a notification about leaving the idle state. So,
	 * we lock the scheduler here and unlock just after we have
	 * sent the notification in pm_system_resume().
	 */
	k_sched_lock();
    1fd8:	f002 ffd4 	bl	4f84 <k_sched_lock>
	__asm__ volatile(
    1fdc:	f04f 0320 	mov.w	r3, #32
    1fe0:	f3ef 8511 	mrs	r5, BASEPRI
    1fe4:	f383 8811 	msr	BASEPRI, r3
    1fe8:	f3bf 8f6f 	isb	sy
	return list->head;
    1fec:	4b1d      	ldr	r3, [pc, #116]	; (2064 <pm_system_suspend+0xb8>)
    1fee:	681c      	ldr	r4, [r3, #0]
    1ff0:	e016      	b.n	2020 <pm_system_suspend+0x74>
		     k_us_to_ticks_ceil32(z_power_state.exit_latency_us), true);
    1ff2:	68a3      	ldr	r3, [r4, #8]
		} else {
			return t * ((uint64_t)to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    1ff4:	0c59      	lsrs	r1, r3, #17
    1ff6:	03d8      	lsls	r0, r3, #15
    1ff8:	4c1b      	ldr	r4, [pc, #108]	; (2068 <pm_system_suspend+0xbc>)
    1ffa:	4a1c      	ldr	r2, [pc, #112]	; (206c <pm_system_suspend+0xc0>)
    1ffc:	2300      	movs	r3, #0
    1ffe:	1900      	adds	r0, r0, r4
    2000:	f04f 0400 	mov.w	r4, #0
    2004:	eb44 0101 	adc.w	r1, r4, r1
    2008:	f7fe f868 	bl	dc <__aeabi_uldivmod>
		z_set_timeout_expiry(ticks -
    200c:	2101      	movs	r1, #1
    200e:	1a30      	subs	r0, r6, r0
    2010:	f005 fb81 	bl	7716 <z_set_timeout_expiry>
    2014:	e7e0      	b.n	1fd8 <pm_system_suspend+0x2c>
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2016:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
    2018:	b10c      	cbz	r4, 201e <pm_system_suspend+0x72>
	return node->next;
    201a:	6823      	ldr	r3, [r4, #0]
    201c:	b143      	cbz	r3, 2030 <pm_system_suspend+0x84>
{
    201e:	461c      	mov	r4, r3
	SYS_SLIST_FOR_EACH_CONTAINER(&pm_notifiers, notifier, _node) {
    2020:	b134      	cbz	r4, 2030 <pm_system_suspend+0x84>
			callback = notifier->state_entry;
    2022:	6863      	ldr	r3, [r4, #4]
		if (callback) {
    2024:	2b00      	cmp	r3, #0
    2026:	d0f6      	beq.n	2016 <pm_system_suspend+0x6a>
			callback(z_power_state.state);
    2028:	4a0c      	ldr	r2, [pc, #48]	; (205c <pm_system_suspend+0xb0>)
    202a:	7810      	ldrb	r0, [r2, #0]
    202c:	4798      	blx	r3
    202e:	e7f2      	b.n	2016 <pm_system_suspend+0x6a>
	__asm__ volatile(
    2030:	f385 8811 	msr	BASEPRI, r5
    2034:	f3bf 8f6f 	isb	sy
	pm_debug_start_timer();
	/* Enter power state */
	pm_state_notify(true);
	pm_state_set(z_power_state);
    2038:	4b08      	ldr	r3, [pc, #32]	; (205c <pm_system_suspend+0xb0>)
    203a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
    203e:	ab08      	add	r3, sp, #32
    2040:	e903 0007 	stmdb	r3, {r0, r1, r2}
	if (pm_power_state_set != NULL) {
    2044:	4b0a      	ldr	r3, [pc, #40]	; (2070 <pm_system_suspend+0xc4>)
    2046:	b10b      	cbz	r3, 204c <pm_system_suspend+0xa0>
		pm_power_state_set(info);
    2048:	f004 fd47 	bl	6ada <pm_power_state_set>
		/* Turn on peripherals and restore device states as necessary */
		pm_resume_devices();
	}
#endif
	pm_log_debug_info(z_power_state.state);
	pm_system_resume();
    204c:	f7ff ff6e 	bl	1f2c <pm_system_resume>
	k_sched_unlock();
    2050:	f003 f848 	bl	50e4 <k_sched_unlock>
	SYS_PORT_TRACING_FUNC_EXIT(pm, system_suspend, ticks, z_power_state.state);
	return z_power_state.state;
    2054:	4b01      	ldr	r3, [pc, #4]	; (205c <pm_system_suspend+0xb0>)
    2056:	7818      	ldrb	r0, [r3, #0]
}
    2058:	b008      	add	sp, #32
    205a:	bd70      	pop	{r4, r5, r6, pc}
    205c:	20000450 	.word	0x20000450
    2060:	20000008 	.word	0x20000008
    2064:	20000448 	.word	0x20000448
    2068:	000f423f 	.word	0x000f423f
    206c:	000f4240 	.word	0x000f4240
    2070:	00006adb 	.word	0x00006adb

00002074 <console_out>:
 *
 * @return The character passed as input.
 */

static int console_out(int c)
{
    2074:	b510      	push	{r4, lr}
    2076:	4604      	mov	r4, r0
		return c;
	}

#endif  /* CONFIG_UART_CONSOLE_DEBUG_SERVER_HOOKS */

	if ('\n' == c) {
    2078:	280a      	cmp	r0, #10
    207a:	d007      	beq.n	208c <console_out+0x18>
		uart_poll_out(uart_console_dev, '\r');
	}
	uart_poll_out(uart_console_dev, c);
    207c:	4b07      	ldr	r3, [pc, #28]	; (209c <console_out+0x28>)
    207e:	6818      	ldr	r0, [r3, #0]
    2080:	b2e1      	uxtb	r1, r4
	const struct uart_driver_api *api =
    2082:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
    2084:	685b      	ldr	r3, [r3, #4]
    2086:	4798      	blx	r3

	return c;
}
    2088:	4620      	mov	r0, r4
    208a:	bd10      	pop	{r4, pc}
		uart_poll_out(uart_console_dev, '\r');
    208c:	4b03      	ldr	r3, [pc, #12]	; (209c <console_out+0x28>)
    208e:	6818      	ldr	r0, [r3, #0]
	const struct uart_driver_api *api =
    2090:	6883      	ldr	r3, [r0, #8]
	api->poll_out(dev, out_char);
    2092:	685b      	ldr	r3, [r3, #4]
    2094:	210d      	movs	r1, #13
    2096:	4798      	blx	r3
		return;
	}
#endif
	compiler_barrier();
	z_impl_uart_poll_out(dev, out_char);
}
    2098:	e7f0      	b.n	207c <console_out+0x8>
    209a:	bf00      	nop
    209c:	2000045c 	.word	0x2000045c

000020a0 <uart_console_hook_install>:
 *
 * @return N/A
 */

static void uart_console_hook_install(void)
{
    20a0:	b510      	push	{r4, lr}
	__stdout_hook_install(console_out);
    20a2:	4c04      	ldr	r4, [pc, #16]	; (20b4 <uart_console_hook_install+0x14>)
    20a4:	4620      	mov	r0, r4
    20a6:	f001 f973 	bl	3390 <__stdout_hook_install>
	__printk_hook_install(console_out);
    20aa:	4620      	mov	r0, r4
    20ac:	f7fe fa72 	bl	594 <__printk_hook_install>
}
    20b0:	bd10      	pop	{r4, pc}
    20b2:	bf00      	nop
    20b4:	00002075 	.word	0x00002075

000020b8 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    20b8:	b508      	push	{r3, lr}
    20ba:	4804      	ldr	r0, [pc, #16]	; (20cc <uart_console_init+0x14>)
    20bc:	f002 f94e 	bl	435c <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    20c0:	4b03      	ldr	r3, [pc, #12]	; (20d0 <uart_console_init+0x18>)
    20c2:	6018      	str	r0, [r3, #0]

	uart_console_hook_install();
    20c4:	f7ff ffec 	bl	20a0 <uart_console_hook_install>

	return 0;
}
    20c8:	2000      	movs	r0, #0
    20ca:	bd08      	pop	{r3, pc}
    20cc:	00007ca0 	.word	0x00007ca0
    20d0:	2000045c 	.word	0x2000045c

000020d4 <get_hf_flags>:
static uint32_t *get_hf_flags(void)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;

	return &data->subsys[CLOCK_CONTROL_NRF_TYPE_HFCLK].flags;
}
    20d4:	4800      	ldr	r0, [pc, #0]	; (20d8 <get_hf_flags+0x4>)
    20d6:	4770      	bx	lr
    20d8:	200004b4 	.word	0x200004b4

000020dc <get_subsys>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    20dc:	4b03      	ldr	r3, [pc, #12]	; (20ec <get_subsys+0x10>)
    20de:	1ac0      	subs	r0, r0, r3
    20e0:	1080      	asrs	r0, r0, #2

	return (clock_control_subsys_t)offset;
}
    20e2:	4b03      	ldr	r3, [pc, #12]	; (20f0 <get_subsys+0x14>)
    20e4:	fb03 f000 	mul.w	r0, r3, r0
    20e8:	4770      	bx	lr
    20ea:	bf00      	nop
    20ec:	20000474 	.word	0x20000474
    20f0:	b6db6db7 	.word	0xb6db6db7

000020f4 <onoff_stop>:

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    20f4:	b538      	push	{r3, r4, r5, lr}
    20f6:	4605      	mov	r5, r0
    20f8:	460c      	mov	r4, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    20fa:	f7ff ffef 	bl	20dc <get_subsys>
    20fe:	4601      	mov	r1, r0
    2100:	2240      	movs	r2, #64	; 0x40
    2102:	4803      	ldr	r0, [pc, #12]	; (2110 <onoff_stop+0x1c>)
    2104:	f004 fb43 	bl	678e <stop>
    2108:	4601      	mov	r1, r0
	notify(mgr, res);
    210a:	4628      	mov	r0, r5
    210c:	47a0      	blx	r4
}
    210e:	bd38      	pop	{r3, r4, r5, pc}
    2110:	0000782c 	.word	0x0000782c

00002114 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    2114:	b530      	push	{r4, r5, lr}
    2116:	b083      	sub	sp, #12
    2118:	4605      	mov	r5, r0
    211a:	460c      	mov	r4, r1
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    211c:	f7ff ffde 	bl	20dc <get_subsys>
    2120:	4601      	mov	r1, r0
    2122:	2340      	movs	r3, #64	; 0x40
    2124:	9300      	str	r3, [sp, #0]
    2126:	4623      	mov	r3, r4
    2128:	4a05      	ldr	r2, [pc, #20]	; (2140 <onoff_start+0x2c>)
    212a:	4806      	ldr	r0, [pc, #24]	; (2144 <onoff_start+0x30>)
    212c:	f004 fb49 	bl	67c2 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    2130:	1e01      	subs	r1, r0, #0
    2132:	db01      	blt.n	2138 <onoff_start+0x24>
		notify(mgr, err);
	}
}
    2134:	b003      	add	sp, #12
    2136:	bd30      	pop	{r4, r5, pc}
		notify(mgr, err);
    2138:	4628      	mov	r0, r5
    213a:	47a0      	blx	r4
}
    213c:	e7fa      	b.n	2134 <onoff_start+0x20>
    213e:	bf00      	nop
    2140:	0000680b 	.word	0x0000680b
    2144:	0000782c 	.word	0x0000782c

00002148 <clock_event_handler>:
		__ASSERT_NO_MSG(false);
	}
}

static void clock_event_handler(nrfx_clock_evt_type_t event)
{
    2148:	b508      	push	{r3, lr}
	const struct device *dev = CLOCK_DEVICE;

	switch (event) {
    214a:	b110      	cbz	r0, 2152 <clock_event_handler+0xa>
    214c:	2801      	cmp	r0, #1
    214e:	d00d      	beq.n	216c <clock_event_handler+0x24>
		break;
	default:
		__ASSERT_NO_MSG(0);
		break;
	}
}
    2150:	bd08      	pop	{r3, pc}
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    2152:	2100      	movs	r1, #0
    2154:	4808      	ldr	r0, [pc, #32]	; (2178 <clock_event_handler+0x30>)
    2156:	f004 faa1 	bl	669c <get_sub_data>
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    215a:	6883      	ldr	r3, [r0, #8]
    215c:	f013 0f07 	tst.w	r3, #7
    2160:	d1f6      	bne.n	2150 <clock_event_handler+0x8>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
    2162:	2100      	movs	r1, #0
    2164:	4804      	ldr	r0, [pc, #16]	; (2178 <clock_event_handler+0x30>)
    2166:	f004 fb00 	bl	676a <clkstarted_handle>
    216a:	e7f1      	b.n	2150 <clock_event_handler+0x8>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    216c:	2101      	movs	r1, #1
    216e:	4802      	ldr	r0, [pc, #8]	; (2178 <clock_event_handler+0x30>)
    2170:	f004 fafb 	bl	676a <clkstarted_handle>
}
    2174:	e7ec      	b.n	2150 <clock_event_handler+0x8>
    2176:	bf00      	nop
    2178:	0000782c 	.word	0x0000782c

0000217c <generic_hfclk_start>:
{
    217c:	b510      	push	{r4, lr}
	__asm__ volatile(
    217e:	f04f 0320 	mov.w	r3, #32
    2182:	f3ef 8411 	mrs	r4, BASEPRI
    2186:	f383 8811 	msr	BASEPRI, r3
    218a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    218e:	4a13      	ldr	r2, [pc, #76]	; (21dc <generic_hfclk_start+0x60>)
    2190:	6813      	ldr	r3, [r2, #0]
    2192:	f043 0302 	orr.w	r3, r3, #2
    2196:	6013      	str	r3, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    2198:	f013 0f01 	tst.w	r3, #1
    219c:	d108      	bne.n	21b0 <generic_hfclk_start+0x34>
	bool already_started = false;
    219e:	2300      	movs	r3, #0
	__asm__ volatile(
    21a0:	f384 8811 	msr	BASEPRI, r4
    21a4:	f3bf 8f6f 	isb	sy
	if (already_started) {
    21a8:	b99b      	cbnz	r3, 21d2 <generic_hfclk_start+0x56>
	hfclk_start();
    21aa:	f004 fb36 	bl	681a <hfclk_start>
}
    21ae:	bd10      	pop	{r4, pc}
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    21b0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    21b4:	f8d3 240c 	ldr.w	r2, [r3, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    21b8:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    21bc:	f012 0f01 	tst.w	r2, #1
    21c0:	d101      	bne.n	21c6 <generic_hfclk_start+0x4a>
	bool already_started = false;
    21c2:	2300      	movs	r3, #0
    21c4:	e7ec      	b.n	21a0 <generic_hfclk_start+0x24>
			set_on_state(get_hf_flags());
    21c6:	f7ff ff85 	bl	20d4 <get_hf_flags>
    21ca:	f004 fabb 	bl	6744 <set_on_state>
			already_started = true;
    21ce:	2301      	movs	r3, #1
    21d0:	e7e6      	b.n	21a0 <generic_hfclk_start+0x24>
		clkstarted_handle(CLOCK_DEVICE,
    21d2:	2100      	movs	r1, #0
    21d4:	4802      	ldr	r0, [pc, #8]	; (21e0 <generic_hfclk_start+0x64>)
    21d6:	f004 fac8 	bl	676a <clkstarted_handle>
		return;
    21da:	e7e8      	b.n	21ae <generic_hfclk_start+0x32>
    21dc:	200004c4 	.word	0x200004c4
    21e0:	0000782c 	.word	0x0000782c

000021e4 <generic_hfclk_stop>:
{
    21e4:	b508      	push	{r3, lr}
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    21e6:	4b0a      	ldr	r3, [pc, #40]	; (2210 <generic_hfclk_stop+0x2c>)
    21e8:	f3bf 8f5b 	dmb	ish
    21ec:	e853 2f00 	ldrex	r2, [r3]
    21f0:	f022 0102 	bic.w	r1, r2, #2
    21f4:	e843 1000 	strex	r0, r1, [r3]
    21f8:	2800      	cmp	r0, #0
    21fa:	d1f7      	bne.n	21ec <generic_hfclk_stop+0x8>
    21fc:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    2200:	f012 0f01 	tst.w	r2, #1
    2204:	d000      	beq.n	2208 <generic_hfclk_stop+0x24>
}
    2206:	bd08      	pop	{r3, pc}
	hfclk_stop();
    2208:	f004 fb0c 	bl	6824 <hfclk_stop>
    220c:	e7fb      	b.n	2206 <generic_hfclk_stop+0x22>
    220e:	bf00      	nop
    2210:	200004c4 	.word	0x200004c4

00002214 <api_blocking_start>:
{
    2214:	b500      	push	{lr}
    2216:	b085      	sub	sp, #20
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    2218:	f8cd d000 	str.w	sp, [sp]
    221c:	f8cd d004 	str.w	sp, [sp, #4]
    2220:	2300      	movs	r3, #0
    2222:	9302      	str	r3, [sp, #8]
    2224:	2301      	movs	r3, #1
    2226:	9303      	str	r3, [sp, #12]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    2228:	466b      	mov	r3, sp
    222a:	4a07      	ldr	r2, [pc, #28]	; (2248 <api_blocking_start+0x34>)
    222c:	f004 fae5 	bl	67fa <api_start>
	if (err < 0) {
    2230:	2800      	cmp	r0, #0
    2232:	db05      	blt.n	2240 <api_blocking_start+0x2c>
	return z_impl_k_sem_take(sem, timeout);
    2234:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    2238:	2300      	movs	r3, #0
    223a:	4668      	mov	r0, sp
    223c:	f002 fc94 	bl	4b68 <z_impl_k_sem_take>
}
    2240:	b005      	add	sp, #20
    2242:	f85d fb04 	ldr.w	pc, [sp], #4
    2246:	bf00      	nop
    2248:	00006839 	.word	0x00006839

0000224c <lfclk_start>:
{
    224c:	b508      	push	{r3, lr}
	if (!once) {
    224e:	4b07      	ldr	r3, [pc, #28]	; (226c <lfclk_start+0x20>)
    2250:	781b      	ldrb	r3, [r3, #0]
    2252:	b11b      	cbz	r3, 225c <lfclk_start+0x10>
}
#endif // defined(CLOCK_FEATURE_HFCLK_DIVIDE_PRESENT) || NRF_CLOCK_HAS_HFCLK_192M

NRFX_STATIC_INLINE void nrfx_clock_lfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    2254:	2000      	movs	r0, #0
    2256:	f001 fddf 	bl	3e18 <nrfx_clock_start>
}
    225a:	bd08      	pop	{r3, pc}
	z_impl_k_busy_wait(usec_to_wait);
    225c:	f44f 70a5 	mov.w	r0, #330	; 0x14a
    2260:	f005 fa88 	bl	7774 <z_impl_k_busy_wait>
		once = true;
    2264:	4b01      	ldr	r3, [pc, #4]	; (226c <lfclk_start+0x20>)
    2266:	2201      	movs	r2, #1
    2268:	701a      	strb	r2, [r3, #0]
    226a:	e7f3      	b.n	2254 <lfclk_start+0x8>
    226c:	20000a75 	.word	0x20000a75

00002270 <clk_init>:
#endif /* NRF_CLOCK_HAS_HFCLKAUDIO */
#endif
}

static int clk_init(const struct device *dev)
{
    2270:	b570      	push	{r4, r5, r6, lr}
    2272:	4606      	mov	r6, r0
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    2274:	2200      	movs	r2, #0
    2276:	2101      	movs	r1, #1
    2278:	4610      	mov	r0, r2
    227a:	f000 fa49 	bl	2710 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    227e:	2000      	movs	r0, #0
    2280:	f000 fa28 	bl	26d4 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    2284:	4811      	ldr	r0, [pc, #68]	; (22cc <clk_init+0x5c>)
    2286:	f001 fdb3 	bl	3df0 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    228a:	4b11      	ldr	r3, [pc, #68]	; (22d0 <clk_init+0x60>)
    228c:	4298      	cmp	r0, r3
    228e:	d11a      	bne.n	22c6 <clk_init+0x56>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    2290:	f004 ff70 	bl	7174 <nrfx_clock_enable>

	for (enum clock_control_nrf_type i = 0;
    2294:	2400      	movs	r4, #0
    2296:	e003      	b.n	22a0 <clk_init+0x30>
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    2298:	2301      	movs	r3, #1
    229a:	60ab      	str	r3, [r5, #8]
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
    229c:	441c      	add	r4, r3
    229e:	b2e4      	uxtb	r4, r4
	for (enum clock_control_nrf_type i = 0;
    22a0:	2c01      	cmp	r4, #1
    22a2:	d80e      	bhi.n	22c2 <clk_init+0x52>
						get_sub_data(dev, i);
    22a4:	4621      	mov	r1, r4
    22a6:	4630      	mov	r0, r6
    22a8:	f004 f9f8 	bl	669c <get_sub_data>
    22ac:	4605      	mov	r5, r0
		err = onoff_manager_init(get_onoff_manager(dev, i),
    22ae:	4621      	mov	r1, r4
    22b0:	4630      	mov	r0, r6
    22b2:	f004 fa00 	bl	66b6 <get_onoff_manager>
    22b6:	4907      	ldr	r1, [pc, #28]	; (22d4 <clk_init+0x64>)
    22b8:	f003 fd79 	bl	5dae <onoff_manager_init>
		if (err < 0) {
    22bc:	2800      	cmp	r0, #0
    22be:	daeb      	bge.n	2298 <clk_init+0x28>
    22c0:	e000      	b.n	22c4 <clk_init+0x54>
	}

	return 0;
    22c2:	2000      	movs	r0, #0
}
    22c4:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    22c6:	f06f 0004 	mvn.w	r0, #4
    22ca:	e7fb      	b.n	22c4 <clk_init+0x54>
    22cc:	00002149 	.word	0x00002149
    22d0:	0bad0000 	.word	0x0bad0000
    22d4:	00007d80 	.word	0x00007d80

000022d8 <lfclk_spinwait>:
{
    22d8:	b570      	push	{r4, r5, r6, lr}
    22da:	4605      	mov	r5, r0
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    22dc:	2801      	cmp	r0, #1
    22de:	d107      	bne.n	22f0 <lfclk_spinwait+0x18>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    22e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    22e4:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    22e8:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    22ec:	2b01      	cmp	r3, #1
    22ee:	d058      	beq.n	23a2 <lfclk_spinwait+0xca>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    22f0:	f004 ffca 	bl	7288 <k_is_in_isr>
    22f4:	b928      	cbnz	r0, 2302 <lfclk_spinwait+0x2a>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    22f6:	4b2e      	ldr	r3, [pc, #184]	; (23b0 <lfclk_spinwait+0xd8>)
    22f8:	781b      	ldrb	r3, [r3, #0]
    22fa:	2b00      	cmp	r3, #0
    22fc:	d041      	beq.n	2382 <lfclk_spinwait+0xaa>
    22fe:	2300      	movs	r3, #0
    2300:	e000      	b.n	2304 <lfclk_spinwait+0x2c>
    2302:	2301      	movs	r3, #1
	int key = isr_mode ? irq_lock() : 0;
    2304:	461c      	mov	r4, r3
    2306:	2b00      	cmp	r3, #0
    2308:	d03d      	beq.n	2386 <lfclk_spinwait+0xae>
	__asm__ volatile(
    230a:	f04f 0320 	mov.w	r3, #32
    230e:	f3ef 8611 	mrs	r6, BASEPRI
    2312:	f383 8811 	msr	BASEPRI, r3
    2316:	f3bf 8f6f 	isb	sy
	if (!isr_mode) {
    231a:	b924      	cbnz	r4, 2326 <lfclk_spinwait+0x4e>
    p_reg->INTENCLR = mask;
    231c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2320:	2202      	movs	r2, #2
    2322:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    2326:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    232a:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    232e:	f003 0303 	and.w	r3, r3, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    2332:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
    2336:	f412 3f80 	tst.w	r2, #65536	; 0x10000
    233a:	d12b      	bne.n	2394 <lfclk_spinwait+0xbc>
    return false;
    233c:	2200      	movs	r2, #0
	while (!(nrfx_clock_is_running(d, (void *)&type)
    233e:	b11a      	cbz	r2, 2348 <lfclk_spinwait+0x70>
    2340:	2b01      	cmp	r3, #1
    2342:	d029      	beq.n	2398 <lfclk_spinwait+0xc0>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    2344:	2d01      	cmp	r5, #1
    2346:	d027      	beq.n	2398 <lfclk_spinwait+0xc0>
			if (isr_mode || !IS_ENABLED(CONFIG_MULTITHREADING)) {
    2348:	b1fc      	cbz	r4, 238a <lfclk_spinwait+0xb2>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    234a:	4630      	mov	r0, r6
    234c:	f000 fa70 	bl	2830 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    2350:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2354:	f8d3 3518 	ldr.w	r3, [r3, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    2358:	2b00      	cmp	r3, #0
    235a:	d1e4      	bne.n	2326 <lfclk_spinwait+0x4e>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    235c:	4b15      	ldr	r3, [pc, #84]	; (23b4 <lfclk_spinwait+0xdc>)
    235e:	681b      	ldr	r3, [r3, #0]
		    && nrf_clock_event_check(NRF_CLOCK,
    2360:	2b00      	cmp	r3, #0
    2362:	d0e0      	beq.n	2326 <lfclk_spinwait+0x4e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2364:	4b13      	ldr	r3, [pc, #76]	; (23b4 <lfclk_spinwait+0xdc>)
    2366:	2200      	movs	r2, #0
    2368:	601a      	str	r2, [r3, #0]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    236a:	681b      	ldr	r3, [r3, #0]
    p_reg->LFCLKSRC = (uint32_t)(source);
    236c:	2301      	movs	r3, #1
    236e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    2372:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    2376:	4a10      	ldr	r2, [pc, #64]	; (23b8 <lfclk_spinwait+0xe0>)
    2378:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    237c:	4a0f      	ldr	r2, [pc, #60]	; (23bc <lfclk_spinwait+0xe4>)
    237e:	6013      	str	r3, [r2, #0]
}
    2380:	e7d1      	b.n	2326 <lfclk_spinwait+0x4e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    2382:	2301      	movs	r3, #1
    2384:	e7be      	b.n	2304 <lfclk_spinwait+0x2c>
	int key = isr_mode ? irq_lock() : 0;
    2386:	2600      	movs	r6, #0
    2388:	e7c7      	b.n	231a <lfclk_spinwait+0x42>
	return z_impl_k_sleep(timeout);
    238a:	2021      	movs	r0, #33	; 0x21
    238c:	2100      	movs	r1, #0
    238e:	f003 f90d 	bl	55ac <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    2392:	e7dd      	b.n	2350 <lfclk_spinwait+0x78>
                return true;
    2394:	2201      	movs	r2, #1
    2396:	e7d2      	b.n	233e <lfclk_spinwait+0x66>
	if (isr_mode) {
    2398:	b124      	cbz	r4, 23a4 <lfclk_spinwait+0xcc>
	__asm__ volatile(
    239a:	f386 8811 	msr	BASEPRI, r6
    239e:	f3bf 8f6f 	isb	sy
}
    23a2:	bd70      	pop	{r4, r5, r6, pc}
    p_reg->INTENSET = mask;
    23a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    23a8:	2202      	movs	r2, #2
    23aa:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    23ae:	e7f8      	b.n	23a2 <lfclk_spinwait+0xca>
    23b0:	20000a78 	.word	0x20000a78
    23b4:	40000104 	.word	0x40000104
    23b8:	e000e100 	.word	0xe000e100
    23bc:	40000008 	.word	0x40000008

000023c0 <z_nrf_clock_control_lf_on>:
{
    23c0:	b510      	push	{r4, lr}
    23c2:	4604      	mov	r4, r0
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    23c4:	4b10      	ldr	r3, [pc, #64]	; (2408 <z_nrf_clock_control_lf_on+0x48>)
    23c6:	2101      	movs	r1, #1
    23c8:	f3bf 8f5b 	dmb	ish
    23cc:	e853 2f00 	ldrex	r2, [r3]
    23d0:	e843 1000 	strex	r0, r1, [r3]
    23d4:	2800      	cmp	r0, #0
    23d6:	d1f9      	bne.n	23cc <z_nrf_clock_control_lf_on+0xc>
    23d8:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
    23dc:	b11a      	cbz	r2, 23e6 <z_nrf_clock_control_lf_on+0x26>
	switch (start_mode) {
    23de:	1e63      	subs	r3, r4, #1
    23e0:	2b01      	cmp	r3, #1
    23e2:	d90c      	bls.n	23fe <z_nrf_clock_control_lf_on+0x3e>
}
    23e4:	bd10      	pop	{r4, pc}
				get_onoff_manager(CLOCK_DEVICE,
    23e6:	4809      	ldr	r0, [pc, #36]	; (240c <z_nrf_clock_control_lf_on+0x4c>)
    23e8:	f004 f965 	bl	66b6 <get_onoff_manager>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    23ec:	4908      	ldr	r1, [pc, #32]	; (2410 <z_nrf_clock_control_lf_on+0x50>)
    23ee:	2300      	movs	r3, #0
    23f0:	604b      	str	r3, [r1, #4]
    23f2:	60cb      	str	r3, [r1, #12]
    23f4:	2301      	movs	r3, #1
    23f6:	608b      	str	r3, [r1, #8]
		err = onoff_request(mgr, &cli);
    23f8:	f003 fcf5 	bl	5de6 <onoff_request>
    23fc:	e7ef      	b.n	23de <z_nrf_clock_control_lf_on+0x1e>
		lfclk_spinwait(start_mode);
    23fe:	4620      	mov	r0, r4
    2400:	f7ff ff6a 	bl	22d8 <lfclk_spinwait>
		break;
    2404:	e7ee      	b.n	23e4 <z_nrf_clock_control_lf_on+0x24>
    2406:	bf00      	nop
    2408:	200004c8 	.word	0x200004c8
    240c:	0000782c 	.word	0x0000782c
    2410:	20000464 	.word	0x20000464

00002414 <set_comparator>:
	return (a - b) & COUNTER_MAX;
}

static void set_comparator(int32_t chan, uint32_t cyc)
{
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    2414:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
    2418:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    241c:	4b01      	ldr	r3, [pc, #4]	; (2424 <set_comparator+0x10>)
    241e:	f843 1020 	str.w	r1, [r3, r0, lsl #2]
}
    2422:	4770      	bx	lr
    2424:	40011000 	.word	0x40011000

00002428 <get_comparator>:
}

NRF_STATIC_INLINE  uint32_t nrf_rtc_cc_get(NRF_RTC_Type const * p_reg, uint32_t ch)
{
    return p_reg->CC[ch];
    2428:	f500 70a8 	add.w	r0, r0, #336	; 0x150
    242c:	4b01      	ldr	r3, [pc, #4]	; (2434 <get_comparator+0xc>)
    242e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

static uint32_t get_comparator(int32_t chan)
{
	return nrf_rtc_cc_get(RTC, chan);
}
    2432:	4770      	bx	lr
    2434:	40011000 	.word	0x40011000

00002438 <event_enable>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
}

static void event_enable(int32_t chan)
{
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2438:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    243c:	4083      	lsls	r3, r0
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    243e:	4a02      	ldr	r2, [pc, #8]	; (2448 <event_enable+0x10>)
    2440:	f8c2 3344 	str.w	r3, [r2, #836]	; 0x344
}
    2444:	4770      	bx	lr
    2446:	bf00      	nop
    2448:	40011000 	.word	0x40011000

0000244c <event_disable>:

static void event_disable(int32_t chan)
{
	nrf_rtc_event_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    244c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    2450:	4083      	lsls	r3, r0
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    2452:	4a02      	ldr	r2, [pc, #8]	; (245c <event_disable+0x10>)
    2454:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
}
    2458:	4770      	bx	lr
    245a:	bf00      	nop
    245c:	40011000 	.word	0x40011000

00002460 <counter>:
     return p_reg->COUNTER;
    2460:	4b01      	ldr	r3, [pc, #4]	; (2468 <counter+0x8>)
    2462:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

static uint32_t counter(void)
{
	return nrf_rtc_counter_get(RTC);
}
    2466:	4770      	bx	lr
    2468:	40011000 	.word	0x40011000

0000246c <rtc_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc_nrf_isr(const void *arg)
{
    246c:	b570      	push	{r4, r5, r6, lr}
	ARG_UNUSED(arg);

	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    246e:	2400      	movs	r4, #0
    2470:	2c00      	cmp	r4, #0
    2472:	dd00      	ble.n	2476 <rtc_nrf_isr+0xa>
				handler(chan, cc_val,
					cc_data[chan].user_context);
			}
		}
	}
}
    2474:	bd70      	pop	{r4, r5, r6, pc}
		if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan)) &&
    2476:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    247a:	40a3      	lsls	r3, r4
    return p_reg->INTENSET & mask;
    247c:	4a19      	ldr	r2, [pc, #100]	; (24e4 <rtc_nrf_isr+0x78>)
    247e:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
    2482:	4213      	tst	r3, r2
    2484:	d009      	beq.n	249a <rtc_nrf_isr+0x2e>
		    nrf_rtc_event_check(RTC, RTC_CHANNEL_EVENT_ADDR(chan))) {
    2486:	f104 0350 	add.w	r3, r4, #80	; 0x50
    248a:	009b      	lsls	r3, r3, #2
    248c:	b29b      	uxth	r3, r3
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    248e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    2492:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
    2496:	681b      	ldr	r3, [r3, #0]
		if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan)) &&
    2498:	b90b      	cbnz	r3, 249e <rtc_nrf_isr+0x32>
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    249a:	3401      	adds	r4, #1
    249c:	e7e8      	b.n	2470 <rtc_nrf_isr+0x4>
			event_clear(chan);
    249e:	4620      	mov	r0, r4
    24a0:	f004 f9d5 	bl	684e <event_clear>
			event_disable(chan);
    24a4:	4620      	mov	r0, r4
    24a6:	f7ff ffd1 	bl	244c <event_disable>
			cc_val = get_comparator(chan);
    24aa:	4620      	mov	r0, r4
    24ac:	f7ff ffbc 	bl	2428 <get_comparator>
    24b0:	4605      	mov	r5, r0
			now = counter();
    24b2:	f7ff ffd5 	bl	2460 <counter>
    24b6:	4606      	mov	r6, r0
			if (counter_sub(now, cc_val) > COUNTER_HALF_SPAN) {
    24b8:	4629      	mov	r1, r5
    24ba:	f004 f9c4 	bl	6846 <counter_sub>
    24be:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    24c2:	d800      	bhi.n	24c6 <rtc_nrf_isr+0x5a>
			cc_val = get_comparator(chan);
    24c4:	462e      	mov	r6, r5
			handler = cc_data[chan].callback;
    24c6:	4b08      	ldr	r3, [pc, #32]	; (24e8 <rtc_nrf_isr+0x7c>)
    24c8:	f853 5034 	ldr.w	r5, [r3, r4, lsl #3]
			cc_data[chan].callback = NULL;
    24cc:	2200      	movs	r2, #0
    24ce:	f843 2034 	str.w	r2, [r3, r4, lsl #3]
			if (handler) {
    24d2:	2d00      	cmp	r5, #0
    24d4:	d0e1      	beq.n	249a <rtc_nrf_isr+0x2e>
				handler(chan, cc_val,
    24d6:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
    24da:	685a      	ldr	r2, [r3, #4]
    24dc:	4631      	mov	r1, r6
    24de:	4620      	mov	r0, r4
    24e0:	47a8      	blx	r5
    24e2:	e7da      	b.n	249a <rtc_nrf_isr+0x2e>
    24e4:	40011000 	.word	0x40011000
    24e8:	200004d0 	.word	0x200004d0

000024ec <compare_set>:
{
    24ec:	b538      	push	{r3, r4, r5, lr}
	cc_data[chan].callback = handler;
    24ee:	4c04      	ldr	r4, [pc, #16]	; (2500 <compare_set+0x14>)
    24f0:	f844 2030 	str.w	r2, [r4, r0, lsl #3]
	cc_data[chan].user_context = user_data;
    24f4:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
    24f8:	6063      	str	r3, [r4, #4]
	set_absolute_alarm(chan, cc_value);
    24fa:	f004 f9b4 	bl	6866 <set_absolute_alarm>
}
    24fe:	bd38      	pop	{r3, r4, r5, pc}
    2500:	200004d0 	.word	0x200004d0

00002504 <sys_clock_timeout_handler>:
{
    2504:	b538      	push	{r3, r4, r5, lr}
    2506:	4608      	mov	r0, r1
	uint32_t dticks = counter_sub(cc_value, last_count) / CYC_PER_TICK;
    2508:	4d04      	ldr	r5, [pc, #16]	; (251c <sys_clock_timeout_handler+0x18>)
    250a:	682c      	ldr	r4, [r5, #0]
    250c:	4621      	mov	r1, r4
    250e:	f004 f99a 	bl	6846 <counter_sub>
	last_count += dticks * CYC_PER_TICK;
    2512:	4404      	add	r4, r0
    2514:	602c      	str	r4, [r5, #0]
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    2516:	f003 f9d1 	bl	58bc <sys_clock_announce>
}
    251a:	bd38      	pop	{r3, r4, r5, pc}
    251c:	200004dc 	.word	0x200004dc

00002520 <sys_clock_driver_init>:

	atomic_or(&alloc_mask, BIT(chan));
}

int sys_clock_driver_init(const struct device *dev)
{
    2520:	b508      	push	{r3, lr}
    p_reg->PRESCALER = val;
    2522:	2300      	movs	r3, #0
    2524:	4a12      	ldr	r2, [pc, #72]	; (2570 <sys_clock_driver_init+0x50>)
    2526:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
			CLOCK_CONTROL_NRF_LF_START_AVAILABLE :
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    252a:	2b00      	cmp	r3, #0
    252c:	dd18      	ble.n	2560 <sys_clock_driver_init+0x40>
    252e:	4b11      	ldr	r3, [pc, #68]	; (2574 <sys_clock_driver_init+0x54>)
    2530:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    2534:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
	}

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    2538:	2200      	movs	r2, #0
    253a:	2101      	movs	r1, #1
    253c:	2011      	movs	r0, #17
    253e:	f000 f8e7 	bl	2710 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    2542:	2011      	movs	r0, #17
    2544:	f000 f8c6 	bl	26d4 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    2548:	2301      	movs	r3, #1
    254a:	4a0b      	ldr	r2, [pc, #44]	; (2578 <sys_clock_driver_init+0x58>)
    254c:	6013      	str	r3, [r2, #0]
    254e:	3a08      	subs	r2, #8
    2550:	6013      	str	r3, [r2, #0]

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    2552:	4a0a      	ldr	r2, [pc, #40]	; (257c <sys_clock_driver_init+0x5c>)
    2554:	6013      	str	r3, [r2, #0]
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		compare_set(0, counter() + CYC_PER_TICK,
			    sys_clock_timeout_handler, NULL);
	}

	z_nrf_clock_control_lf_on(mode);
    2556:	2002      	movs	r0, #2
    2558:	f7ff ff32 	bl	23c0 <z_nrf_clock_control_lf_on>

	return 0;
}
    255c:	2000      	movs	r0, #0
    255e:	bd08      	pop	{r3, pc}
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2560:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    2564:	409a      	lsls	r2, r3
    p_reg->INTENSET = mask;
    2566:	4902      	ldr	r1, [pc, #8]	; (2570 <sys_clock_driver_init+0x50>)
    2568:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
    256c:	3301      	adds	r3, #1
    256e:	e7dc      	b.n	252a <sys_clock_driver_init+0xa>
    2570:	40011000 	.word	0x40011000
    2574:	e000e100 	.word	0xe000e100
    2578:	40011008 	.word	0x40011008
    257c:	200004d8 	.word	0x200004d8

00002580 <sys_clock_set_timeout>:

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
    2580:	b538      	push	{r3, r4, r5, lr}

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    2582:	f1b0 3fff 	cmp.w	r0, #4294967295
    2586:	d007      	beq.n	2598 <sys_clock_set_timeout+0x18>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    2588:	1e44      	subs	r4, r0, #1
    258a:	2c00      	cmp	r4, #0
    258c:	dd07      	ble.n	259e <sys_clock_set_timeout+0x1e>
    258e:	4b10      	ldr	r3, [pc, #64]	; (25d0 <sys_clock_set_timeout+0x50>)
    2590:	429c      	cmp	r4, r3
    2592:	dd05      	ble.n	25a0 <sys_clock_set_timeout+0x20>
    2594:	4c0f      	ldr	r4, [pc, #60]	; (25d4 <sys_clock_set_timeout+0x54>)
    2596:	e003      	b.n	25a0 <sys_clock_set_timeout+0x20>
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    2598:	f500 0000 	add.w	r0, r0, #8388608	; 0x800000
    259c:	e7f4      	b.n	2588 <sys_clock_set_timeout+0x8>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    259e:	2400      	movs	r4, #0

	uint32_t unannounced = counter_sub(counter(), last_count);
    25a0:	f7ff ff5e 	bl	2460 <counter>
    25a4:	4b0c      	ldr	r3, [pc, #48]	; (25d8 <sys_clock_set_timeout+0x58>)
    25a6:	681d      	ldr	r5, [r3, #0]
    25a8:	4629      	mov	r1, r5
    25aa:	f004 f94c 	bl	6846 <counter_sub>
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
    25ae:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    25b2:	d300      	bcc.n	25b6 <sys_clock_set_timeout+0x36>
		ticks = 0;
    25b4:	2400      	movs	r4, #0
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    25b6:	1821      	adds	r1, r4, r0
    25b8:	3101      	adds	r1, #1
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;

	/* Due to elapsed time the calculation above might produce a
	 * duration that laps the counter.  Don't let it.
	 */
	if (cyc > MAX_CYCLES) {
    25ba:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
    25be:	d300      	bcc.n	25c2 <sys_clock_set_timeout+0x42>
		cyc = MAX_CYCLES;
    25c0:	4904      	ldr	r1, [pc, #16]	; (25d4 <sys_clock_set_timeout+0x54>)
	}

	cyc += last_count;
	compare_set(0, cyc, sys_clock_timeout_handler, NULL);
    25c2:	2300      	movs	r3, #0
    25c4:	4a05      	ldr	r2, [pc, #20]	; (25dc <sys_clock_set_timeout+0x5c>)
    25c6:	4429      	add	r1, r5
    25c8:	4618      	mov	r0, r3
    25ca:	f7ff ff8f 	bl	24ec <compare_set>
}
    25ce:	bd38      	pop	{r3, r4, r5, pc}
    25d0:	007ffffe 	.word	0x007ffffe
    25d4:	007fffff 	.word	0x007fffff
    25d8:	200004dc 	.word	0x200004dc
    25dc:	00002505 	.word	0x00002505

000025e0 <sys_clock_elapsed>:

uint32_t sys_clock_elapsed(void)
{
    25e0:	b508      	push	{r3, lr}
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	return counter_sub(counter(), last_count) / CYC_PER_TICK;
    25e2:	f7ff ff3d 	bl	2460 <counter>
    25e6:	4b02      	ldr	r3, [pc, #8]	; (25f0 <sys_clock_elapsed+0x10>)
    25e8:	6819      	ldr	r1, [r3, #0]
    25ea:	f004 f92c 	bl	6846 <counter_sub>
}
    25ee:	bd08      	pop	{r3, pc}
    25f0:	200004dc 	.word	0x200004dc

000025f4 <sys_clock_cycle_get_32>:

uint32_t sys_clock_cycle_get_32(void)
{
    25f4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
    25f6:	f04f 0320 	mov.w	r3, #32
    25fa:	f3ef 8511 	mrs	r5, BASEPRI
    25fe:	f383 8811 	msr	BASEPRI, r3
    2602:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = counter_sub(counter(), last_count) + last_count;
    2606:	f7ff ff2b 	bl	2460 <counter>
    260a:	4b05      	ldr	r3, [pc, #20]	; (2620 <sys_clock_cycle_get_32+0x2c>)
    260c:	681c      	ldr	r4, [r3, #0]
    260e:	4621      	mov	r1, r4
    2610:	f004 f919 	bl	6846 <counter_sub>
    2614:	4420      	add	r0, r4
	__asm__ volatile(
    2616:	f385 8811 	msr	BASEPRI, r5
    261a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    261e:	bd38      	pop	{r3, r4, r5, pc}
    2620:	200004dc 	.word	0x200004dc

00002624 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    2624:	4a0a      	ldr	r2, [pc, #40]	; (2650 <arch_swap+0x2c>)
    2626:	6893      	ldr	r3, [r2, #8]
    2628:	f8c3 00a8 	str.w	r0, [r3, #168]	; 0xa8
	_current->arch.swap_return_value = _k_neg_eagain;
    262c:	4909      	ldr	r1, [pc, #36]	; (2654 <arch_swap+0x30>)
    262e:	6809      	ldr	r1, [r1, #0]
    2630:	f8c3 10ac 	str.w	r1, [r3, #172]	; 0xac

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    2634:	4908      	ldr	r1, [pc, #32]	; (2658 <arch_swap+0x34>)
    2636:	684b      	ldr	r3, [r1, #4]
    2638:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    263c:	604b      	str	r3, [r1, #4]
    263e:	2300      	movs	r3, #0
    2640:	f383 8811 	msr	BASEPRI, r3
    2644:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    2648:	6893      	ldr	r3, [r2, #8]
}
    264a:	f8d3 00ac 	ldr.w	r0, [r3, #172]	; 0xac
    264e:	4770      	bx	lr
    2650:	20000a24 	.word	0x20000a24
    2654:	000082d0 	.word	0x000082d0
    2658:	e000ed00 	.word	0xe000ed00

0000265c <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_INSTRUMENT_THREAD_SWITCHING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    265c:	4913      	ldr	r1, [pc, #76]	; (26ac <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
    265e:	688a      	ldr	r2, [r1, #8]
    /* Store LSB of LR (EXC_RETURN) to the thread's 'mode' word. */
    strb lr, [r2, #_thread_offset_to_mode_exc_return]
#endif

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    2660:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
    2664:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    2666:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    266a:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    266e:	2020      	movs	r0, #32
    msr BASEPRI, r0
    2670:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    2674:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    2678:	4f0d      	ldr	r7, [pc, #52]	; (26b0 <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    267a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    267e:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
    2680:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    2682:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    2684:	f8d2 00a8 	ldr.w	r0, [r2, #168]	; 0xa8
    movs r3, #0
    2688:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    268a:	f8c2 30a8 	str.w	r3, [r2, #168]	; 0xa8
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    268e:	f380 8811 	msr	BASEPRI, r0
    isb
#endif

#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
    /* Re-program dynamic memory map */
    push {r2,lr}
    2692:	b504      	push	{r2, lr}
    mov r0, r2 /* _current thread */
    2694:	4610      	mov	r0, r2
    bl z_arm_configure_dynamic_mpu_regions
    2696:	f000 fda1 	bl	31dc <z_arm_configure_dynamic_mpu_regions>
    pop {r2,lr}
    269a:	e8bd 4004 	ldmia.w	sp!, {r2, lr}
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    269e:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
    26a2:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    26a6:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (z_arm_{exc,int}_exit, or z_arm_svc)
     */
    bx lr
    26aa:	4770      	bx	lr
    ldr r1, =_kernel
    26ac:	20000a24 	.word	0x20000a24
    ldr v4, =_SCS_ICSR
    26b0:	e000ed04 	.word	0xe000ed04

000026b4 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    26b4:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    26b8:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    26ba:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    26be:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    26c2:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    26c4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    26c8:	2902      	cmp	r1, #2
    beq _oops
    26ca:	d0ff      	beq.n	26cc <_oops>

000026cc <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    26cc:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    26ce:	f004 f916 	bl	68fe <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    26d2:	bd01      	pop	{r0, pc}

000026d4 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    26d4:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    26d6:	2b00      	cmp	r3, #0
    26d8:	db08      	blt.n	26ec <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    26da:	f000 001f 	and.w	r0, r0, #31
    26de:	095b      	lsrs	r3, r3, #5
    26e0:	2201      	movs	r2, #1
    26e2:	fa02 f000 	lsl.w	r0, r2, r0
    26e6:	4a02      	ldr	r2, [pc, #8]	; (26f0 <arch_irq_enable+0x1c>)
    26e8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    26ec:	4770      	bx	lr
    26ee:	bf00      	nop
    26f0:	e000e100 	.word	0xe000e100

000026f4 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    26f4:	0942      	lsrs	r2, r0, #5
    26f6:	4b05      	ldr	r3, [pc, #20]	; (270c <arch_irq_is_enabled+0x18>)
    26f8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    26fc:	f000 001f 	and.w	r0, r0, #31
    2700:	2301      	movs	r3, #1
    2702:	fa03 f000 	lsl.w	r0, r3, r0
}
    2706:	4010      	ands	r0, r2
    2708:	4770      	bx	lr
    270a:	bf00      	nop
    270c:	e000e100 	.word	0xe000e100

00002710 <z_arm_irq_priority_set>:
	 * via flags
	 */
	if (IS_ENABLED(CONFIG_ZERO_LATENCY_IRQS) && (flags & IRQ_ZERO_LATENCY)) {
		prio = _EXC_ZERO_LATENCY_IRQS_PRIO;
	} else {
		prio += _IRQ_PRIO_OFFSET;
    2710:	3101      	adds	r1, #1
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    2712:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    2714:	2b00      	cmp	r3, #0
    2716:	db08      	blt.n	272a <z_arm_irq_priority_set+0x1a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    2718:	0149      	lsls	r1, r1, #5
    271a:	b2c9      	uxtb	r1, r1
    271c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    2720:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    2724:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    2728:	4770      	bx	lr
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    272a:	f000 000f 	and.w	r0, r0, #15
    272e:	0149      	lsls	r1, r1, #5
    2730:	b2c9      	uxtb	r1, r1
    2732:	4b01      	ldr	r3, [pc, #4]	; (2738 <z_arm_irq_priority_set+0x28>)
    2734:	5419      	strb	r1, [r3, r0]
}
    2736:	4770      	bx	lr
    2738:	e000ed14 	.word	0xe000ed14

0000273c <arch_new_thread>:
 * of the ESF.
 */
void arch_new_thread(struct k_thread *thread, k_thread_stack_t *stack,
		     char *stack_ptr, k_thread_entry_t entry,
		     void *p1, void *p2, void *p3)
{
    273c:	b410      	push	{r4}
		thread->stack_info.size -= FP_GUARD_EXTRA_SIZE;
	}
#endif /* FP_GUARD_EXTRA_SIZE */
#endif /* CONFIG_MPU_STACK_GUARD */

	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    273e:	f1a2 0420 	sub.w	r4, r2, #32
		iframe->pc = (uint32_t)arch_user_mode_enter;
	} else {
		iframe->pc = (uint32_t)z_thread_entry;
	}
#else
	iframe->pc = (uint32_t)z_thread_entry;
    2742:	490d      	ldr	r1, [pc, #52]	; (2778 <arch_new_thread+0x3c>)
#endif

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
    2744:	f021 0101 	bic.w	r1, r1, #1
    2748:	f842 1c08 	str.w	r1, [r2, #-8]
#endif
	iframe->a1 = (uint32_t)entry;
    274c:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    2750:	9b01      	ldr	r3, [sp, #4]
    2752:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
    2756:	9b02      	ldr	r3, [sp, #8]
    2758:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    275c:	9b03      	ldr	r3, [sp, #12]
    275e:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    2762:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    2766:	f842 3c04 	str.w	r3, [r2, #-4]
#if defined(CONFIG_COMPILER_ISA_THUMB2)
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
    276a:	6504      	str	r4, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
    276c:	2300      	movs	r3, #0
    276e:	f8c0 30a8 	str.w	r3, [r0, #168]	; 0xa8
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    2772:	bc10      	pop	{r4}
    2774:	4770      	bx	lr
    2776:	bf00      	nop
    2778:	00005e9f 	.word	0x00005e9f

0000277c <z_check_thread_stack_fail>:
 *         thread stack corruption, otherwise return 0.
 */
uint32_t z_check_thread_stack_fail(const uint32_t fault_addr, const uint32_t psp)
{
#if defined(CONFIG_MULTITHREADING)
	const struct k_thread *thread = _current;
    277c:	4b16      	ldr	r3, [pc, #88]	; (27d8 <z_check_thread_stack_fail+0x5c>)
    277e:	689a      	ldr	r2, [r3, #8]

	if (thread == NULL) {
    2780:	b1da      	cbz	r2, 27ba <z_check_thread_stack_fail+0x3e>
			return thread->stack_info.start;
		}
	}
#else /* CONFIG_USERSPACE */
#if defined(CONFIG_MULTITHREADING)
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    2782:	f110 0f16 	cmn.w	r0, #22
    2786:	d01a      	beq.n	27be <z_check_thread_stack_fail+0x42>
{
    2788:	b410      	push	{r4}
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    278a:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
    278e:	f1a3 0420 	sub.w	r4, r3, #32
    2792:	4284      	cmp	r4, r0
    2794:	d805      	bhi.n	27a2 <z_check_thread_stack_fail+0x26>
    2796:	4283      	cmp	r3, r0
    2798:	d908      	bls.n	27ac <z_check_thread_stack_fail+0x30>
    279a:	428b      	cmp	r3, r1
    279c:	d808      	bhi.n	27b0 <z_check_thread_stack_fail+0x34>
    279e:	2100      	movs	r1, #0
    27a0:	e000      	b.n	27a4 <z_check_thread_stack_fail+0x28>
    27a2:	2100      	movs	r1, #0
    27a4:	b931      	cbnz	r1, 27b4 <z_check_thread_stack_fail+0x38>
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
    27a6:	2000      	movs	r0, #0
}
    27a8:	bc10      	pop	{r4}
    27aa:	4770      	bx	lr
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    27ac:	2100      	movs	r1, #0
    27ae:	e7f9      	b.n	27a4 <z_check_thread_stack_fail+0x28>
    27b0:	2101      	movs	r1, #1
    27b2:	e7f7      	b.n	27a4 <z_check_thread_stack_fail+0x28>
		return thread->stack_info.start;
    27b4:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
    27b8:	e7f6      	b.n	27a8 <z_check_thread_stack_fail+0x2c>
		return 0;
    27ba:	2000      	movs	r0, #0
    27bc:	4770      	bx	lr
	if (IS_MPU_GUARD_VIOLATION(thread->stack_info.start - guard_len,
    27be:	f8d2 3098 	ldr.w	r3, [r2, #152]	; 0x98
    27c2:	428b      	cmp	r3, r1
    27c4:	bf94      	ite	ls
    27c6:	2100      	movls	r1, #0
    27c8:	2101      	movhi	r1, #1
    27ca:	b909      	cbnz	r1, 27d0 <z_check_thread_stack_fail+0x54>
	return 0;
    27cc:	2000      	movs	r0, #0
}
    27ce:	4770      	bx	lr
		return thread->stack_info.start;
    27d0:	f8d2 0098 	ldr.w	r0, [r2, #152]	; 0x98
    27d4:	4770      	bx	lr
    27d6:	bf00      	nop
    27d8:	20000a24 	.word	0x20000a24

000027dc <arch_switch_to_main_thread>:
#endif /* CONFIG_FPU */
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    27dc:	b508      	push	{r3, lr}
    27de:	460d      	mov	r5, r1
    27e0:	4614      	mov	r4, r2
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    27e2:	4b08      	ldr	r3, [pc, #32]	; (2804 <arch_switch_to_main_thread+0x28>)
    27e4:	6098      	str	r0, [r3, #8]
#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_USERSPACE)
	/*
	 * If stack protection is enabled, make sure to set it
	 * before jumping to thread entry function
	 */
	z_arm_configure_dynamic_mpu_regions(main_thread);
    27e6:	f000 fcf9 	bl	31dc <z_arm_configure_dynamic_mpu_regions>

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    27ea:	4620      	mov	r0, r4
    27ec:	f385 8809 	msr	PSP, r5
    27f0:	2100      	movs	r1, #0
    27f2:	b663      	cpsie	if
    27f4:	f381 8811 	msr	BASEPRI, r1
    27f8:	f3bf 8f6f 	isb	sy
    27fc:	2200      	movs	r2, #0
    27fe:	2300      	movs	r3, #0
    2800:	f003 fb4d 	bl	5e9e <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    2804:	20000a24 	.word	0x20000a24

00002808 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    2808:	4901      	ldr	r1, [pc, #4]	; (2810 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    280a:	2210      	movs	r2, #16
	str	r2, [r1]
    280c:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    280e:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    2810:	e000ed10 	.word	0xe000ed10

00002814 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    2814:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    2816:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    2818:	f380 8811 	msr	BASEPRI, r0
	isb
    281c:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    2820:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    2824:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    2826:	b662      	cpsie	i
	isb
    2828:	f3bf 8f6f 	isb	sy

	bx	lr
    282c:	4770      	bx	lr
    282e:	bf00      	nop

00002830 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    2830:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    2832:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    2834:	f381 8811 	msr	BASEPRI, r1

	wfe
    2838:	bf20      	wfe

	msr	BASEPRI, r0
    283a:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    283e:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    2840:	4770      	bx	lr
    2842:	bf00      	nop

00002844 <esf_dump>:
#include <kernel.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

static void esf_dump(const z_arch_esf_t *esf)
{
    2844:	b570      	push	{r4, r5, r6, lr}
    2846:	b082      	sub	sp, #8
    2848:	4604      	mov	r4, r0
    284a:	4d1f      	ldr	r5, [pc, #124]	; (28c8 <esf_dump+0x84>)
    284c:	4b1f      	ldr	r3, [pc, #124]	; (28cc <esf_dump+0x88>)
    284e:	1aed      	subs	r5, r5, r3
    2850:	08ed      	lsrs	r5, r5, #3
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
    2852:	2601      	movs	r6, #1
    2854:	f04f 0300 	mov.w	r3, #0
    2858:	f366 0302 	bfi	r3, r6, #0, #3
    285c:	f36f 03c5 	bfc	r3, #3, #3
    2860:	f365 138f 	bfi	r3, r5, #6, #10
    2864:	f8ad 3000 	strh.w	r3, [sp]
    2868:	6883      	ldr	r3, [r0, #8]
    286a:	6842      	ldr	r2, [r0, #4]
    286c:	6801      	ldr	r1, [r0, #0]
    286e:	4818      	ldr	r0, [pc, #96]	; (28d0 <esf_dump+0x8c>)
    2870:	f7fe fecc 	bl	160c <log_3>
		esf->basic.a1, esf->basic.a2, esf->basic.a3);
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
    2874:	f04f 0300 	mov.w	r3, #0
    2878:	f366 0302 	bfi	r3, r6, #0, #3
    287c:	f36f 03c5 	bfc	r3, #3, #3
    2880:	f365 138f 	bfi	r3, r5, #6, #10
    2884:	f8ad 3000 	strh.w	r3, [sp]
    2888:	6963      	ldr	r3, [r4, #20]
    288a:	6922      	ldr	r2, [r4, #16]
    288c:	68e1      	ldr	r1, [r4, #12]
    288e:	4811      	ldr	r0, [pc, #68]	; (28d4 <esf_dump+0x90>)
    2890:	f7fe febc 	bl	160c <log_3>
		esf->basic.a4, esf->basic.ip, esf->basic.lr);
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
    2894:	f04f 0200 	mov.w	r2, #0
    2898:	f366 0202 	bfi	r2, r6, #0, #3
    289c:	f36f 02c5 	bfc	r2, #3, #3
    28a0:	f365 128f 	bfi	r2, r5, #6, #10
    28a4:	69e1      	ldr	r1, [r4, #28]
    28a6:	480c      	ldr	r0, [pc, #48]	; (28d8 <esf_dump+0x94>)
    28a8:	f7fe feee 	bl	1688 <log_1>
	}

	LOG_ERR("EXC_RETURN: 0x%0x", esf->extra_info.exc_return);

#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
    28ac:	f04f 0200 	mov.w	r2, #0
    28b0:	f366 0202 	bfi	r2, r6, #0, #3
    28b4:	f36f 02c5 	bfc	r2, #3, #3
    28b8:	f365 128f 	bfi	r2, r5, #6, #10
    28bc:	69a1      	ldr	r1, [r4, #24]
    28be:	4807      	ldr	r0, [pc, #28]	; (28dc <esf_dump+0x98>)
    28c0:	f7fe fee2 	bl	1688 <log_1>
		esf->basic.pc);
}
    28c4:	b002      	add	sp, #8
    28c6:	bd70      	pop	{r4, r5, r6, pc}
    28c8:	000079e4 	.word	0x000079e4
    28cc:	000079c4 	.word	0x000079c4
    28d0:	00007d98 	.word	0x00007d98
    28d4:	00007dc8 	.word	0x00007dc8
    28d8:	00007df8 	.word	0x00007df8
    28dc:	00007e08 	.word	0x00007e08

000028e0 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    28e0:	bf30      	wfi
    b z_SysNmiOnReset
    28e2:	f7ff bffd 	b.w	28e0 <z_SysNmiOnReset>
    28e6:	bf00      	nop

000028e8 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    28e8:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    28ea:	4b0b      	ldr	r3, [pc, #44]	; (2918 <z_arm_prep_c+0x30>)
    28ec:	4a0b      	ldr	r2, [pc, #44]	; (291c <z_arm_prep_c+0x34>)
    28ee:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    28f2:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    28f4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    28f8:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    28fc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    2900:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    2904:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    2908:	f001 fe8a 	bl	4620 <z_bss_zero>
	z_data_copy();
    290c:	f002 feca 	bl	56a4 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    2910:	f000 fc26 	bl	3160 <z_arm_interrupt_init>
	z_cstart();
    2914:	f001 feaa 	bl	466c <z_cstart>
    2918:	e000ed00 	.word	0xe000ed00
    291c:	00000000 	.word	0x00000000

00002920 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    2920:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    2922:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    2924:	4a0b      	ldr	r2, [pc, #44]	; (2954 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    2926:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
    2928:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    292a:	bf1e      	ittt	ne
	movne	r1, #0
    292c:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    292e:	6211      	strne	r1, [r2, #32]
		blne	z_pm_save_idle_exit
    2930:	f004 fce3 	blne	72fa <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    2934:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    2936:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    293a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    293e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    2942:	4905      	ldr	r1, [pc, #20]	; (2958 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    2944:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    2946:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    2948:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    294a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    294e:	4903      	ldr	r1, [pc, #12]	; (295c <_isr_wrapper+0x3c>)
	bx r1
    2950:	4708      	bx	r1
    2952:	0000      	.short	0x0000
	ldr r2, =_kernel
    2954:	20000a24 	.word	0x20000a24
	ldr r1, =_sw_isr_table
    2958:	0000788c 	.word	0x0000788c
	ldr r1, =z_arm_int_exit
    295c:	000030d1 	.word	0x000030d1

00002960 <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
    2960:	2000      	movs	r0, #0
    msr CONTROL, r0
    2962:	f380 8814 	msr	CONTROL, r0
    isb
    2966:	f3bf 8f6f 	isb	sy
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    296a:	f004 ff31 	bl	77d0 <z_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
    296e:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
    2970:	490d      	ldr	r1, [pc, #52]	; (29a8 <__start+0x48>)
    str r0, [r1]
    2972:	6008      	str	r0, [r1, #0]
    dsb
    2974:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    2978:	480c      	ldr	r0, [pc, #48]	; (29ac <__start+0x4c>)
    msr msp, r0
    297a:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
    297e:	f000 fbc5 	bl	310c <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    2982:	2020      	movs	r0, #32
    msr BASEPRI, r0
    2984:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    2988:	4809      	ldr	r0, [pc, #36]	; (29b0 <__start+0x50>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    298a:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
    298e:	1840      	adds	r0, r0, r1
    msr PSP, r0
    2990:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    2994:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    2998:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    299a:	4308      	orrs	r0, r1
    msr CONTROL, r0
    299c:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    29a0:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    29a4:	f7ff ffa0 	bl	28e8 <z_arm_prep_c>
    ldr r1, =_SCS_MPU_CTRL
    29a8:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    29ac:	200011a0 	.word	0x200011a0
    ldr r0, =z_interrupt_stacks
    29b0:	20001320 	.word	0x20001320

000029b4 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    29b4:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    29b8:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    29bc:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    29be:	4672      	mov	r2, lr
	bl z_arm_fault
    29c0:	f000 fb1c 	bl	2ffc <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    29c4:	bd01      	pop	{r0, pc}
    29c6:	bf00      	nop

000029c8 <usage_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t usage_fault(const z_arch_esf_t *esf)
{
    29c8:	b508      	push	{r3, lr}
    29ca:	4b4e      	ldr	r3, [pc, #312]	; (2b04 <usage_fault+0x13c>)
    29cc:	4a4e      	ldr	r2, [pc, #312]	; (2b08 <usage_fault+0x140>)
    29ce:	1a9b      	subs	r3, r3, r2
    29d0:	08db      	lsrs	r3, r3, #3
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");
    29d2:	f04f 0100 	mov.w	r1, #0
    29d6:	2201      	movs	r2, #1
    29d8:	f362 0102 	bfi	r1, r2, #0, #3
    29dc:	f36f 01c5 	bfc	r1, #3, #3
    29e0:	f363 118f 	bfi	r1, r3, #6, #10
    29e4:	4849      	ldr	r0, [pc, #292]	; (2b0c <usage_fault+0x144>)
    29e6:	f7fe fec1 	bl	176c <log_0>

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    29ea:	4b49      	ldr	r3, [pc, #292]	; (2b10 <usage_fault+0x148>)
    29ec:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29ee:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    29f2:	d121      	bne.n	2a38 <usage_fault+0x70>
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    29f4:	4b46      	ldr	r3, [pc, #280]	; (2b10 <usage_fault+0x148>)
    29f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    29f8:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
    29fc:	d12d      	bne.n	2a5a <usage_fault+0x92>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    29fe:	4b44      	ldr	r3, [pc, #272]	; (2b10 <usage_fault+0x148>)
    2a00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2a02:	f413 2f00 	tst.w	r3, #524288	; 0x80000
    2a06:	d139      	bne.n	2a7c <usage_fault+0xb4>
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    2a08:	4b41      	ldr	r3, [pc, #260]	; (2b10 <usage_fault+0x148>)
    2a0a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2a0c:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    2a10:	d145      	bne.n	2a9e <usage_fault+0xd6>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    2a12:	4b3f      	ldr	r3, [pc, #252]	; (2b10 <usage_fault+0x148>)
    2a14:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2a16:	f413 3f00 	tst.w	r3, #131072	; 0x20000
    2a1a:	d151      	bne.n	2ac0 <usage_fault+0xf8>
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    2a1c:	4b3c      	ldr	r3, [pc, #240]	; (2b10 <usage_fault+0x148>)
    2a1e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2a20:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    2a24:	d15d      	bne.n	2ae2 <usage_fault+0x11a>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    2a26:	4a3a      	ldr	r2, [pc, #232]	; (2b10 <usage_fault+0x148>)
    2a28:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2a2a:	ea6f 4303 	mvn.w	r3, r3, lsl #16
    2a2e:	ea6f 4313 	mvn.w	r3, r3, lsr #16
    2a32:	6293      	str	r3, [r2, #40]	; 0x28

	return reason;
}
    2a34:	2000      	movs	r0, #0
    2a36:	bd08      	pop	{r3, pc}
    2a38:	4b32      	ldr	r3, [pc, #200]	; (2b04 <usage_fault+0x13c>)
    2a3a:	4a33      	ldr	r2, [pc, #204]	; (2b08 <usage_fault+0x140>)
    2a3c:	1a9b      	subs	r3, r3, r2
    2a3e:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Division by zero");
    2a40:	f04f 0100 	mov.w	r1, #0
    2a44:	2201      	movs	r2, #1
    2a46:	f362 0102 	bfi	r1, r2, #0, #3
    2a4a:	f36f 01c5 	bfc	r1, #3, #3
    2a4e:	f363 118f 	bfi	r1, r3, #6, #10
    2a52:	4830      	ldr	r0, [pc, #192]	; (2b14 <usage_fault+0x14c>)
    2a54:	f7fe fe8a 	bl	176c <log_0>
    2a58:	e7cc      	b.n	29f4 <usage_fault+0x2c>
    2a5a:	4b2a      	ldr	r3, [pc, #168]	; (2b04 <usage_fault+0x13c>)
    2a5c:	4a2a      	ldr	r2, [pc, #168]	; (2b08 <usage_fault+0x140>)
    2a5e:	1a9b      	subs	r3, r3, r2
    2a60:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Unaligned memory access");
    2a62:	f04f 0100 	mov.w	r1, #0
    2a66:	2201      	movs	r2, #1
    2a68:	f362 0102 	bfi	r1, r2, #0, #3
    2a6c:	f36f 01c5 	bfc	r1, #3, #3
    2a70:	f363 118f 	bfi	r1, r3, #6, #10
    2a74:	4828      	ldr	r0, [pc, #160]	; (2b18 <usage_fault+0x150>)
    2a76:	f7fe fe79 	bl	176c <log_0>
    2a7a:	e7c0      	b.n	29fe <usage_fault+0x36>
    2a7c:	4b21      	ldr	r3, [pc, #132]	; (2b04 <usage_fault+0x13c>)
    2a7e:	4a22      	ldr	r2, [pc, #136]	; (2b08 <usage_fault+0x140>)
    2a80:	1a9b      	subs	r3, r3, r2
    2a82:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  No coprocessor instructions");
    2a84:	f04f 0100 	mov.w	r1, #0
    2a88:	2201      	movs	r2, #1
    2a8a:	f362 0102 	bfi	r1, r2, #0, #3
    2a8e:	f36f 01c5 	bfc	r1, #3, #3
    2a92:	f363 118f 	bfi	r1, r3, #6, #10
    2a96:	4821      	ldr	r0, [pc, #132]	; (2b1c <usage_fault+0x154>)
    2a98:	f7fe fe68 	bl	176c <log_0>
    2a9c:	e7b4      	b.n	2a08 <usage_fault+0x40>
    2a9e:	4b19      	ldr	r3, [pc, #100]	; (2b04 <usage_fault+0x13c>)
    2aa0:	4a19      	ldr	r2, [pc, #100]	; (2b08 <usage_fault+0x140>)
    2aa2:	1a9b      	subs	r3, r3, r2
    2aa4:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
    2aa6:	f04f 0100 	mov.w	r1, #0
    2aaa:	2201      	movs	r2, #1
    2aac:	f362 0102 	bfi	r1, r2, #0, #3
    2ab0:	f36f 01c5 	bfc	r1, #3, #3
    2ab4:	f363 118f 	bfi	r1, r3, #6, #10
    2ab8:	4819      	ldr	r0, [pc, #100]	; (2b20 <usage_fault+0x158>)
    2aba:	f7fe fe57 	bl	176c <log_0>
    2abe:	e7a8      	b.n	2a12 <usage_fault+0x4a>
    2ac0:	4b10      	ldr	r3, [pc, #64]	; (2b04 <usage_fault+0x13c>)
    2ac2:	4a11      	ldr	r2, [pc, #68]	; (2b08 <usage_fault+0x140>)
    2ac4:	1a9b      	subs	r3, r3, r2
    2ac6:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Illegal use of the EPSR");
    2ac8:	f04f 0100 	mov.w	r1, #0
    2acc:	2201      	movs	r2, #1
    2ace:	f362 0102 	bfi	r1, r2, #0, #3
    2ad2:	f36f 01c5 	bfc	r1, #3, #3
    2ad6:	f363 118f 	bfi	r1, r3, #6, #10
    2ada:	4812      	ldr	r0, [pc, #72]	; (2b24 <usage_fault+0x15c>)
    2adc:	f7fe fe46 	bl	176c <log_0>
    2ae0:	e79c      	b.n	2a1c <usage_fault+0x54>
    2ae2:	4b08      	ldr	r3, [pc, #32]	; (2b04 <usage_fault+0x13c>)
    2ae4:	4a08      	ldr	r2, [pc, #32]	; (2b08 <usage_fault+0x140>)
    2ae6:	1a9b      	subs	r3, r3, r2
    2ae8:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
    2aea:	f04f 0100 	mov.w	r1, #0
    2aee:	2201      	movs	r2, #1
    2af0:	f362 0102 	bfi	r1, r2, #0, #3
    2af4:	f36f 01c5 	bfc	r1, #3, #3
    2af8:	f363 118f 	bfi	r1, r3, #6, #10
    2afc:	480a      	ldr	r0, [pc, #40]	; (2b28 <usage_fault+0x160>)
    2afe:	f7fe fe35 	bl	176c <log_0>
    2b02:	e790      	b.n	2a26 <usage_fault+0x5e>
    2b04:	000079e4 	.word	0x000079e4
    2b08:	000079c4 	.word	0x000079c4
    2b0c:	00007e38 	.word	0x00007e38
    2b10:	e000ed00 	.word	0xe000ed00
    2b14:	00007e50 	.word	0x00007e50
    2b18:	00007e64 	.word	0x00007e64
    2b1c:	00007e80 	.word	0x00007e80
    2b20:	00007ea0 	.word	0x00007ea0
    2b24:	00007ec8 	.word	0x00007ec8
    2b28:	00007ee4 	.word	0x00007ee4

00002b2c <debug_monitor>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void debug_monitor(z_arch_esf_t *esf, bool *recoverable)
{
    2b2c:	b508      	push	{r3, lr}
	*recoverable = false;
    2b2e:	2200      	movs	r2, #0
    2b30:	700a      	strb	r2, [r1, #0]
    2b32:	4b08      	ldr	r3, [pc, #32]	; (2b54 <debug_monitor+0x28>)
    2b34:	4908      	ldr	r1, [pc, #32]	; (2b58 <debug_monitor+0x2c>)
    2b36:	1a5b      	subs	r3, r3, r1
    2b38:	08db      	lsrs	r3, r3, #3

	PR_FAULT_INFO(
    2b3a:	f04f 0100 	mov.w	r1, #0
    2b3e:	2001      	movs	r0, #1
    2b40:	f360 0102 	bfi	r1, r0, #0, #3
    2b44:	f362 01c5 	bfi	r1, r2, #3, #3
    2b48:	f363 118f 	bfi	r1, r3, #6, #10
    2b4c:	4803      	ldr	r0, [pc, #12]	; (2b5c <debug_monitor+0x30>)
    2b4e:	f7fe fe0d 	bl	176c <log_0>

		*recoverable = memory_fault_recoverable(esf, false);
	}

#endif
}
    2b52:	bd08      	pop	{r3, pc}
    2b54:	000079e4 	.word	0x000079e4
    2b58:	000079c4 	.word	0x000079c4
    2b5c:	00007f10 	.word	0x00007f10

00002b60 <bus_fault>:
{
    2b60:	b570      	push	{r4, r5, r6, lr}
    2b62:	4605      	mov	r5, r0
    2b64:	460e      	mov	r6, r1
    2b66:	4614      	mov	r4, r2
    2b68:	4b5e      	ldr	r3, [pc, #376]	; (2ce4 <bus_fault+0x184>)
    2b6a:	4a5f      	ldr	r2, [pc, #380]	; (2ce8 <bus_fault+0x188>)
    2b6c:	1a9b      	subs	r3, r3, r2
    2b6e:	08db      	lsrs	r3, r3, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
    2b70:	f04f 0100 	mov.w	r1, #0
    2b74:	2201      	movs	r2, #1
    2b76:	f362 0102 	bfi	r1, r2, #0, #3
    2b7a:	f36f 01c5 	bfc	r1, #3, #3
    2b7e:	f363 118f 	bfi	r1, r3, #6, #10
    2b82:	485a      	ldr	r0, [pc, #360]	; (2cec <bus_fault+0x18c>)
    2b84:	f7fe fdf2 	bl	176c <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    2b88:	4b59      	ldr	r3, [pc, #356]	; (2cf0 <bus_fault+0x190>)
    2b8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b8c:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    2b90:	d124      	bne.n	2bdc <bus_fault+0x7c>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    2b92:	4b57      	ldr	r3, [pc, #348]	; (2cf0 <bus_fault+0x190>)
    2b94:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2b96:	f413 6f00 	tst.w	r3, #2048	; 0x800
    2b9a:	d130      	bne.n	2bfe <bus_fault+0x9e>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    2b9c:	4b54      	ldr	r3, [pc, #336]	; (2cf0 <bus_fault+0x190>)
    2b9e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2ba0:	f413 7f00 	tst.w	r3, #512	; 0x200
    2ba4:	d13c      	bne.n	2c20 <bus_fault+0xc0>
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    2ba6:	4b52      	ldr	r3, [pc, #328]	; (2cf0 <bus_fault+0x190>)
    2ba8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2baa:	f413 6f80 	tst.w	r3, #1024	; 0x400
    2bae:	d165      	bne.n	2c7c <bus_fault+0x11c>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    2bb0:	4b4f      	ldr	r3, [pc, #316]	; (2cf0 <bus_fault+0x190>)
    2bb2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2bb4:	f413 7f80 	tst.w	r3, #256	; 0x100
    2bb8:	d171      	bne.n	2c9e <bus_fault+0x13e>
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    2bba:	4b4d      	ldr	r3, [pc, #308]	; (2cf0 <bus_fault+0x190>)
    2bbc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2bbe:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    2bc2:	d17d      	bne.n	2cc0 <bus_fault+0x160>
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    2bc4:	4a4a      	ldr	r2, [pc, #296]	; (2cf0 <bus_fault+0x190>)
    2bc6:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2bc8:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
    2bcc:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    2bce:	2101      	movs	r1, #1
    2bd0:	4628      	mov	r0, r5
    2bd2:	f003 fea0 	bl	6916 <memory_fault_recoverable>
    2bd6:	7020      	strb	r0, [r4, #0]
}
    2bd8:	2000      	movs	r0, #0
    2bda:	bd70      	pop	{r4, r5, r6, pc}
    2bdc:	4b41      	ldr	r3, [pc, #260]	; (2ce4 <bus_fault+0x184>)
    2bde:	4a42      	ldr	r2, [pc, #264]	; (2ce8 <bus_fault+0x188>)
    2be0:	1a9b      	subs	r3, r3, r2
    2be2:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Stacking error");
    2be4:	f04f 0100 	mov.w	r1, #0
    2be8:	2201      	movs	r2, #1
    2bea:	f362 0102 	bfi	r1, r2, #0, #3
    2bee:	f36f 01c5 	bfc	r1, #3, #3
    2bf2:	f363 118f 	bfi	r1, r3, #6, #10
    2bf6:	483f      	ldr	r0, [pc, #252]	; (2cf4 <bus_fault+0x194>)
    2bf8:	f7fe fdb8 	bl	176c <log_0>
    2bfc:	e7c9      	b.n	2b92 <bus_fault+0x32>
    2bfe:	4b39      	ldr	r3, [pc, #228]	; (2ce4 <bus_fault+0x184>)
    2c00:	4a39      	ldr	r2, [pc, #228]	; (2ce8 <bus_fault+0x188>)
    2c02:	1a9b      	subs	r3, r3, r2
    2c04:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Unstacking error");
    2c06:	f04f 0100 	mov.w	r1, #0
    2c0a:	2201      	movs	r2, #1
    2c0c:	f362 0102 	bfi	r1, r2, #0, #3
    2c10:	f36f 01c5 	bfc	r1, #3, #3
    2c14:	f363 118f 	bfi	r1, r3, #6, #10
    2c18:	4837      	ldr	r0, [pc, #220]	; (2cf8 <bus_fault+0x198>)
    2c1a:	f7fe fda7 	bl	176c <log_0>
    2c1e:	e7bd      	b.n	2b9c <bus_fault+0x3c>
    2c20:	4b30      	ldr	r3, [pc, #192]	; (2ce4 <bus_fault+0x184>)
    2c22:	4a31      	ldr	r2, [pc, #196]	; (2ce8 <bus_fault+0x188>)
    2c24:	1a9b      	subs	r3, r3, r2
    2c26:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Precise data bus error");
    2c28:	f04f 0100 	mov.w	r1, #0
    2c2c:	2201      	movs	r2, #1
    2c2e:	f362 0102 	bfi	r1, r2, #0, #3
    2c32:	f36f 01c5 	bfc	r1, #3, #3
    2c36:	f363 118f 	bfi	r1, r3, #6, #10
    2c3a:	4830      	ldr	r0, [pc, #192]	; (2cfc <bus_fault+0x19c>)
    2c3c:	f7fe fd96 	bl	176c <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
    2c40:	4b2b      	ldr	r3, [pc, #172]	; (2cf0 <bus_fault+0x190>)
    2c42:	6b99      	ldr	r1, [r3, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    2c44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2c46:	f413 4f00 	tst.w	r3, #32768	; 0x8000
    2c4a:	d0ac      	beq.n	2ba6 <bus_fault+0x46>
    2c4c:	4b25      	ldr	r3, [pc, #148]	; (2ce4 <bus_fault+0x184>)
    2c4e:	4a26      	ldr	r2, [pc, #152]	; (2ce8 <bus_fault+0x188>)
    2c50:	1a9b      	subs	r3, r3, r2
    2c52:	08db      	lsrs	r3, r3, #3
			PR_EXC("  BFAR Address: 0x%x", bfar);
    2c54:	f04f 0200 	mov.w	r2, #0
    2c58:	2001      	movs	r0, #1
    2c5a:	f360 0202 	bfi	r2, r0, #0, #3
    2c5e:	f36f 02c5 	bfc	r2, #3, #3
    2c62:	f363 128f 	bfi	r2, r3, #6, #10
    2c66:	4826      	ldr	r0, [pc, #152]	; (2d00 <bus_fault+0x1a0>)
    2c68:	f7fe fd0e 	bl	1688 <log_1>
			if (from_hard_fault != 0) {
    2c6c:	2e00      	cmp	r6, #0
    2c6e:	d09a      	beq.n	2ba6 <bus_fault+0x46>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    2c70:	4a1f      	ldr	r2, [pc, #124]	; (2cf0 <bus_fault+0x190>)
    2c72:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2c74:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
    2c78:	6293      	str	r3, [r2, #40]	; 0x28
    2c7a:	e794      	b.n	2ba6 <bus_fault+0x46>
    2c7c:	4b19      	ldr	r3, [pc, #100]	; (2ce4 <bus_fault+0x184>)
    2c7e:	4a1a      	ldr	r2, [pc, #104]	; (2ce8 <bus_fault+0x188>)
    2c80:	1a9b      	subs	r3, r3, r2
    2c82:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Imprecise data bus error");
    2c84:	f04f 0100 	mov.w	r1, #0
    2c88:	2201      	movs	r2, #1
    2c8a:	f362 0102 	bfi	r1, r2, #0, #3
    2c8e:	f36f 01c5 	bfc	r1, #3, #3
    2c92:	f363 118f 	bfi	r1, r3, #6, #10
    2c96:	481b      	ldr	r0, [pc, #108]	; (2d04 <bus_fault+0x1a4>)
    2c98:	f7fe fd68 	bl	176c <log_0>
    2c9c:	e788      	b.n	2bb0 <bus_fault+0x50>
    2c9e:	4b11      	ldr	r3, [pc, #68]	; (2ce4 <bus_fault+0x184>)
    2ca0:	4a11      	ldr	r2, [pc, #68]	; (2ce8 <bus_fault+0x188>)
    2ca2:	1a9b      	subs	r3, r3, r2
    2ca4:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Instruction bus error");
    2ca6:	f04f 0100 	mov.w	r1, #0
    2caa:	2201      	movs	r2, #1
    2cac:	f362 0102 	bfi	r1, r2, #0, #3
    2cb0:	f36f 01c5 	bfc	r1, #3, #3
    2cb4:	f363 118f 	bfi	r1, r3, #6, #10
    2cb8:	4813      	ldr	r0, [pc, #76]	; (2d08 <bus_fault+0x1a8>)
    2cba:	f7fe fd57 	bl	176c <log_0>
    2cbe:	e781      	b.n	2bc4 <bus_fault+0x64>
    2cc0:	4b08      	ldr	r3, [pc, #32]	; (2ce4 <bus_fault+0x184>)
    2cc2:	4a09      	ldr	r2, [pc, #36]	; (2ce8 <bus_fault+0x188>)
    2cc4:	1a9b      	subs	r3, r3, r2
    2cc6:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Floating-point lazy state preservation error");
    2cc8:	f04f 0100 	mov.w	r1, #0
    2ccc:	2201      	movs	r2, #1
    2cce:	f362 0102 	bfi	r1, r2, #0, #3
    2cd2:	f36f 01c5 	bfc	r1, #3, #3
    2cd6:	f363 118f 	bfi	r1, r3, #6, #10
    2cda:	480c      	ldr	r0, [pc, #48]	; (2d0c <bus_fault+0x1ac>)
    2cdc:	f7fe fd46 	bl	176c <log_0>
    2ce0:	e770      	b.n	2bc4 <bus_fault+0x64>
    2ce2:	bf00      	nop
    2ce4:	000079e4 	.word	0x000079e4
    2ce8:	000079c4 	.word	0x000079c4
    2cec:	00007f34 	.word	0x00007f34
    2cf0:	e000ed00 	.word	0xe000ed00
    2cf4:	00007f4c 	.word	0x00007f4c
    2cf8:	00007f60 	.word	0x00007f60
    2cfc:	00007f74 	.word	0x00007f74
    2d00:	00007f90 	.word	0x00007f90
    2d04:	00007fa8 	.word	0x00007fa8
    2d08:	00007fc4 	.word	0x00007fc4
    2d0c:	00007fdc 	.word	0x00007fdc

00002d10 <mem_manage_fault>:
{
    2d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2d12:	4605      	mov	r5, r0
    2d14:	460c      	mov	r4, r1
    2d16:	4616      	mov	r6, r2
    2d18:	4b64      	ldr	r3, [pc, #400]	; (2eac <mem_manage_fault+0x19c>)
    2d1a:	4a65      	ldr	r2, [pc, #404]	; (2eb0 <mem_manage_fault+0x1a0>)
    2d1c:	1a9b      	subs	r3, r3, r2
    2d1e:	08db      	lsrs	r3, r3, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
    2d20:	f04f 0100 	mov.w	r1, #0
    2d24:	2201      	movs	r2, #1
    2d26:	f362 0102 	bfi	r1, r2, #0, #3
    2d2a:	f36f 01c5 	bfc	r1, #3, #3
    2d2e:	f363 118f 	bfi	r1, r3, #6, #10
    2d32:	4860      	ldr	r0, [pc, #384]	; (2eb4 <mem_manage_fault+0x1a4>)
    2d34:	f7fe fd1a 	bl	176c <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    2d38:	4b5f      	ldr	r3, [pc, #380]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d3a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d3c:	f013 0f10 	tst.w	r3, #16
    2d40:	d132      	bne.n	2da8 <mem_manage_fault+0x98>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    2d42:	4b5d      	ldr	r3, [pc, #372]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d44:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d46:	f013 0f08 	tst.w	r3, #8
    2d4a:	d13e      	bne.n	2dca <mem_manage_fault+0xba>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    2d4c:	4b5a      	ldr	r3, [pc, #360]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d4e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d50:	f013 0f02 	tst.w	r3, #2
    2d54:	d14a      	bne.n	2dec <mem_manage_fault+0xdc>
	uint32_t mmfar = -EINVAL;
    2d56:	f06f 0715 	mvn.w	r7, #21
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    2d5a:	4b57      	ldr	r3, [pc, #348]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d5c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d5e:	f013 0f01 	tst.w	r3, #1
    2d62:	d175      	bne.n	2e50 <mem_manage_fault+0x140>
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    2d64:	4b54      	ldr	r3, [pc, #336]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d66:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d68:	f013 0f20 	tst.w	r3, #32
    2d6c:	f040 8081 	bne.w	2e72 <mem_manage_fault+0x162>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    2d70:	4b51      	ldr	r3, [pc, #324]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2d74:	f013 0f10 	tst.w	r3, #16
    2d78:	d104      	bne.n	2d84 <mem_manage_fault+0x74>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    2d7a:	4b4f      	ldr	r3, [pc, #316]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d7c:	6a9c      	ldr	r4, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    2d7e:	f014 0402 	ands.w	r4, r4, #2
    2d82:	d005      	beq.n	2d90 <mem_manage_fault+0x80>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    2d84:	4b4c      	ldr	r3, [pc, #304]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d86:	685c      	ldr	r4, [r3, #4]
    2d88:	f414 6400 	ands.w	r4, r4, #2048	; 0x800
    2d8c:	f040 8082 	bne.w	2e94 <mem_manage_fault+0x184>
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    2d90:	4a49      	ldr	r2, [pc, #292]	; (2eb8 <mem_manage_fault+0x1a8>)
    2d92:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2d94:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
    2d98:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    2d9a:	2101      	movs	r1, #1
    2d9c:	4628      	mov	r0, r5
    2d9e:	f003 fdba 	bl	6916 <memory_fault_recoverable>
    2da2:	7030      	strb	r0, [r6, #0]
}
    2da4:	4620      	mov	r0, r4
    2da6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2da8:	4b40      	ldr	r3, [pc, #256]	; (2eac <mem_manage_fault+0x19c>)
    2daa:	4a41      	ldr	r2, [pc, #260]	; (2eb0 <mem_manage_fault+0x1a0>)
    2dac:	1a9b      	subs	r3, r3, r2
    2dae:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Stacking error (context area might be"
    2db0:	f04f 0100 	mov.w	r1, #0
    2db4:	2201      	movs	r2, #1
    2db6:	f362 0102 	bfi	r1, r2, #0, #3
    2dba:	f36f 01c5 	bfc	r1, #3, #3
    2dbe:	f363 118f 	bfi	r1, r3, #6, #10
    2dc2:	483e      	ldr	r0, [pc, #248]	; (2ebc <mem_manage_fault+0x1ac>)
    2dc4:	f7fe fcd2 	bl	176c <log_0>
    2dc8:	e7bb      	b.n	2d42 <mem_manage_fault+0x32>
    2dca:	4b38      	ldr	r3, [pc, #224]	; (2eac <mem_manage_fault+0x19c>)
    2dcc:	4a38      	ldr	r2, [pc, #224]	; (2eb0 <mem_manage_fault+0x1a0>)
    2dce:	1a9b      	subs	r3, r3, r2
    2dd0:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Unstacking error");
    2dd2:	f04f 0100 	mov.w	r1, #0
    2dd6:	2201      	movs	r2, #1
    2dd8:	f362 0102 	bfi	r1, r2, #0, #3
    2ddc:	f36f 01c5 	bfc	r1, #3, #3
    2de0:	f363 118f 	bfi	r1, r3, #6, #10
    2de4:	4836      	ldr	r0, [pc, #216]	; (2ec0 <mem_manage_fault+0x1b0>)
    2de6:	f7fe fcc1 	bl	176c <log_0>
    2dea:	e7af      	b.n	2d4c <mem_manage_fault+0x3c>
    2dec:	4b2f      	ldr	r3, [pc, #188]	; (2eac <mem_manage_fault+0x19c>)
    2dee:	4a30      	ldr	r2, [pc, #192]	; (2eb0 <mem_manage_fault+0x1a0>)
    2df0:	1a9b      	subs	r3, r3, r2
    2df2:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Data Access Violation");
    2df4:	f04f 0100 	mov.w	r1, #0
    2df8:	2201      	movs	r2, #1
    2dfa:	f362 0102 	bfi	r1, r2, #0, #3
    2dfe:	f36f 01c5 	bfc	r1, #3, #3
    2e02:	f363 118f 	bfi	r1, r3, #6, #10
    2e06:	482f      	ldr	r0, [pc, #188]	; (2ec4 <mem_manage_fault+0x1b4>)
    2e08:	f7fe fcb0 	bl	176c <log_0>
		uint32_t temp = SCB->MMFAR;
    2e0c:	4b2a      	ldr	r3, [pc, #168]	; (2eb8 <mem_manage_fault+0x1a8>)
    2e0e:	6b5f      	ldr	r7, [r3, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    2e10:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    2e12:	f013 0f80 	tst.w	r3, #128	; 0x80
    2e16:	d102      	bne.n	2e1e <mem_manage_fault+0x10e>
	uint32_t mmfar = -EINVAL;
    2e18:	f06f 0715 	mvn.w	r7, #21
    2e1c:	e79d      	b.n	2d5a <mem_manage_fault+0x4a>
    2e1e:	4b23      	ldr	r3, [pc, #140]	; (2eac <mem_manage_fault+0x19c>)
    2e20:	4a23      	ldr	r2, [pc, #140]	; (2eb0 <mem_manage_fault+0x1a0>)
    2e22:	1a9b      	subs	r3, r3, r2
    2e24:	08db      	lsrs	r3, r3, #3
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
    2e26:	f04f 0200 	mov.w	r2, #0
    2e2a:	2101      	movs	r1, #1
    2e2c:	f361 0202 	bfi	r2, r1, #0, #3
    2e30:	f36f 02c5 	bfc	r2, #3, #3
    2e34:	f363 128f 	bfi	r2, r3, #6, #10
    2e38:	4639      	mov	r1, r7
    2e3a:	4823      	ldr	r0, [pc, #140]	; (2ec8 <mem_manage_fault+0x1b8>)
    2e3c:	f7fe fc24 	bl	1688 <log_1>
			if (from_hard_fault != 0) {
    2e40:	2c00      	cmp	r4, #0
    2e42:	d08a      	beq.n	2d5a <mem_manage_fault+0x4a>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    2e44:	4a1c      	ldr	r2, [pc, #112]	; (2eb8 <mem_manage_fault+0x1a8>)
    2e46:	6a93      	ldr	r3, [r2, #40]	; 0x28
    2e48:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    2e4c:	6293      	str	r3, [r2, #40]	; 0x28
    2e4e:	e784      	b.n	2d5a <mem_manage_fault+0x4a>
    2e50:	4b16      	ldr	r3, [pc, #88]	; (2eac <mem_manage_fault+0x19c>)
    2e52:	4a17      	ldr	r2, [pc, #92]	; (2eb0 <mem_manage_fault+0x1a0>)
    2e54:	1a9b      	subs	r3, r3, r2
    2e56:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO("  Instruction Access Violation");
    2e58:	f04f 0100 	mov.w	r1, #0
    2e5c:	2201      	movs	r2, #1
    2e5e:	f362 0102 	bfi	r1, r2, #0, #3
    2e62:	f36f 01c5 	bfc	r1, #3, #3
    2e66:	f363 118f 	bfi	r1, r3, #6, #10
    2e6a:	4818      	ldr	r0, [pc, #96]	; (2ecc <mem_manage_fault+0x1bc>)
    2e6c:	f7fe fc7e 	bl	176c <log_0>
    2e70:	e778      	b.n	2d64 <mem_manage_fault+0x54>
    2e72:	4b0e      	ldr	r3, [pc, #56]	; (2eac <mem_manage_fault+0x19c>)
    2e74:	4a0e      	ldr	r2, [pc, #56]	; (2eb0 <mem_manage_fault+0x1a0>)
    2e76:	1a9b      	subs	r3, r3, r2
    2e78:	08db      	lsrs	r3, r3, #3
		PR_FAULT_INFO(
    2e7a:	f04f 0100 	mov.w	r1, #0
    2e7e:	2201      	movs	r2, #1
    2e80:	f362 0102 	bfi	r1, r2, #0, #3
    2e84:	f36f 01c5 	bfc	r1, #3, #3
    2e88:	f363 118f 	bfi	r1, r3, #6, #10
    2e8c:	4810      	ldr	r0, [pc, #64]	; (2ed0 <mem_manage_fault+0x1c0>)
    2e8e:	f7fe fc6d 	bl	176c <log_0>
    2e92:	e76d      	b.n	2d70 <mem_manage_fault+0x60>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    2e94:	4629      	mov	r1, r5
    2e96:	4638      	mov	r0, r7
    2e98:	f7ff fc70 	bl	277c <z_check_thread_stack_fail>
			if (min_stack_ptr) {
    2e9c:	4604      	mov	r4, r0
    2e9e:	2800      	cmp	r0, #0
    2ea0:	f43f af76 	beq.w	2d90 <mem_manage_fault+0x80>
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    2ea4:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
    2ea8:	2402      	movs	r4, #2
    2eaa:	e771      	b.n	2d90 <mem_manage_fault+0x80>
    2eac:	000079e4 	.word	0x000079e4
    2eb0:	000079c4 	.word	0x000079c4
    2eb4:	0000800c 	.word	0x0000800c
    2eb8:	e000ed00 	.word	0xe000ed00
    2ebc:	00008024 	.word	0x00008024
    2ec0:	00007f60 	.word	0x00007f60
    2ec4:	00008058 	.word	0x00008058
    2ec8:	00008070 	.word	0x00008070
    2ecc:	00008088 	.word	0x00008088
    2ed0:	00007fdc 	.word	0x00007fdc

00002ed4 <hard_fault>:
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t hard_fault(z_arch_esf_t *esf, bool *recoverable)
{
    2ed4:	b570      	push	{r4, r5, r6, lr}
    2ed6:	4605      	mov	r5, r0
    2ed8:	460c      	mov	r4, r1
    2eda:	4b2d      	ldr	r3, [pc, #180]	; (2f90 <hard_fault+0xbc>)
    2edc:	4a2d      	ldr	r2, [pc, #180]	; (2f94 <hard_fault+0xc0>)
    2ede:	1a9b      	subs	r3, r3, r2
    2ee0:	08db      	lsrs	r3, r3, #3
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** HARD FAULT *****");
    2ee2:	f04f 0100 	mov.w	r1, #0
    2ee6:	2201      	movs	r2, #1
    2ee8:	f362 0102 	bfi	r1, r2, #0, #3
    2eec:	f36f 01c5 	bfc	r1, #3, #3
    2ef0:	f363 118f 	bfi	r1, r3, #6, #10
    2ef4:	4828      	ldr	r0, [pc, #160]	; (2f98 <hard_fault+0xc4>)
    2ef6:	f7fe fc39 	bl	176c <log_0>
	}
#undef _SVC_OPCODE

	*recoverable = memory_fault_recoverable(esf, true);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	*recoverable = false;
    2efa:	2300      	movs	r3, #0
    2efc:	7023      	strb	r3, [r4, #0]

	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    2efe:	4b27      	ldr	r3, [pc, #156]	; (2f9c <hard_fault+0xc8>)
    2f00:	6ade      	ldr	r6, [r3, #44]	; 0x2c
    2f02:	f016 0602 	ands.w	r6, r6, #2
    2f06:	d105      	bne.n	2f14 <hard_fault+0x40>
		PR_EXC("  Bus fault on vector table read");
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    2f08:	4b24      	ldr	r3, [pc, #144]	; (2f9c <hard_fault+0xc8>)
    2f0a:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    2f0c:	f010 4080 	ands.w	r0, r0, #1073741824	; 0x40000000
    2f10:	d112      	bne.n	2f38 <hard_fault+0x64>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	return reason;
}
    2f12:	bd70      	pop	{r4, r5, r6, pc}
    2f14:	4b1e      	ldr	r3, [pc, #120]	; (2f90 <hard_fault+0xbc>)
    2f16:	4a1f      	ldr	r2, [pc, #124]	; (2f94 <hard_fault+0xc0>)
    2f18:	1a9b      	subs	r3, r3, r2
    2f1a:	08db      	lsrs	r3, r3, #3
		PR_EXC("  Bus fault on vector table read");
    2f1c:	f04f 0100 	mov.w	r1, #0
    2f20:	2201      	movs	r2, #1
    2f22:	f362 0102 	bfi	r1, r2, #0, #3
    2f26:	f36f 01c5 	bfc	r1, #3, #3
    2f2a:	f363 118f 	bfi	r1, r3, #6, #10
    2f2e:	481c      	ldr	r0, [pc, #112]	; (2fa0 <hard_fault+0xcc>)
    2f30:	f7fe fc1c 	bl	176c <log_0>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2f34:	2000      	movs	r0, #0
    2f36:	e7ec      	b.n	2f12 <hard_fault+0x3e>
    2f38:	4b15      	ldr	r3, [pc, #84]	; (2f90 <hard_fault+0xbc>)
    2f3a:	4a16      	ldr	r2, [pc, #88]	; (2f94 <hard_fault+0xc0>)
    2f3c:	1a9b      	subs	r3, r3, r2
    2f3e:	08db      	lsrs	r3, r3, #3
		PR_EXC("  Fault escalation (see below)");
    2f40:	f04f 0100 	mov.w	r1, #0
    2f44:	2201      	movs	r2, #1
    2f46:	f362 0102 	bfi	r1, r2, #0, #3
    2f4a:	f36f 01c5 	bfc	r1, #3, #3
    2f4e:	f363 118f 	bfi	r1, r3, #6, #10
    2f52:	4814      	ldr	r0, [pc, #80]	; (2fa4 <hard_fault+0xd0>)
    2f54:	f7fe fc0a 	bl	176c <log_0>
		if (SCB_MMFSR != 0) {
    2f58:	4b13      	ldr	r3, [pc, #76]	; (2fa8 <hard_fault+0xd4>)
    2f5a:	781b      	ldrb	r3, [r3, #0]
    2f5c:	b943      	cbnz	r3, 2f70 <hard_fault+0x9c>
		} else if (SCB_BFSR != 0) {
    2f5e:	4b13      	ldr	r3, [pc, #76]	; (2fac <hard_fault+0xd8>)
    2f60:	781b      	ldrb	r3, [r3, #0]
    2f62:	b95b      	cbnz	r3, 2f7c <hard_fault+0xa8>
		} else if (SCB_UFSR != 0) {
    2f64:	4b12      	ldr	r3, [pc, #72]	; (2fb0 <hard_fault+0xdc>)
    2f66:	881b      	ldrh	r3, [r3, #0]
    2f68:	b29b      	uxth	r3, r3
    2f6a:	b96b      	cbnz	r3, 2f88 <hard_fault+0xb4>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    2f6c:	4630      	mov	r0, r6
	return reason;
    2f6e:	e7d0      	b.n	2f12 <hard_fault+0x3e>
			reason = mem_manage_fault(esf, 1, recoverable);
    2f70:	4622      	mov	r2, r4
    2f72:	2101      	movs	r1, #1
    2f74:	4628      	mov	r0, r5
    2f76:	f7ff fecb 	bl	2d10 <mem_manage_fault>
    2f7a:	e7ca      	b.n	2f12 <hard_fault+0x3e>
			reason = bus_fault(esf, 1, recoverable);
    2f7c:	4622      	mov	r2, r4
    2f7e:	2101      	movs	r1, #1
    2f80:	4628      	mov	r0, r5
    2f82:	f7ff fded 	bl	2b60 <bus_fault>
    2f86:	e7c4      	b.n	2f12 <hard_fault+0x3e>
			reason = usage_fault(esf);
    2f88:	4628      	mov	r0, r5
    2f8a:	f7ff fd1d 	bl	29c8 <usage_fault>
    2f8e:	e7c0      	b.n	2f12 <hard_fault+0x3e>
    2f90:	000079e4 	.word	0x000079e4
    2f94:	000079c4 	.word	0x000079c4
    2f98:	000080a8 	.word	0x000080a8
    2f9c:	e000ed00 	.word	0xe000ed00
    2fa0:	000080c0 	.word	0x000080c0
    2fa4:	000080e4 	.word	0x000080e4
    2fa8:	e000ed28 	.word	0xe000ed28
    2fac:	e000ed29 	.word	0xe000ed29
    2fb0:	e000ed2a 	.word	0xe000ed2a

00002fb4 <reserved_exception>:
 * See z_arm_fault_dump() for example.
 *
 * @return N/A
 */
static void reserved_exception(const z_arch_esf_t *esf, int fault)
{
    2fb4:	b508      	push	{r3, lr}
    2fb6:	460a      	mov	r2, r1
    2fb8:	480b      	ldr	r0, [pc, #44]	; (2fe8 <reserved_exception+0x34>)
    2fba:	4b0c      	ldr	r3, [pc, #48]	; (2fec <reserved_exception+0x38>)
    2fbc:	1ac0      	subs	r0, r0, r3
    2fbe:	08c0      	lsrs	r0, r0, #3
	ARG_UNUSED(esf);

	PR_FAULT_INFO("***** %s %d) *****",
    2fc0:	f04f 0300 	mov.w	r3, #0
    2fc4:	2101      	movs	r1, #1
    2fc6:	f361 0302 	bfi	r3, r1, #0, #3
    2fca:	f36f 03c5 	bfc	r3, #3, #3
    2fce:	f360 138f 	bfi	r3, r0, #6, #10
    2fd2:	2a0f      	cmp	r2, #15
    2fd4:	dc05      	bgt.n	2fe2 <reserved_exception+0x2e>
    2fd6:	4906      	ldr	r1, [pc, #24]	; (2ff0 <reserved_exception+0x3c>)
    2fd8:	3a10      	subs	r2, #16
    2fda:	4806      	ldr	r0, [pc, #24]	; (2ff4 <reserved_exception+0x40>)
    2fdc:	f7fe fb8a 	bl	16f4 <log_2>
	       fault < 16 ? "Reserved Exception (" : "Spurious interrupt (IRQ ",
	       fault - 16);
}
    2fe0:	bd08      	pop	{r3, pc}
	PR_FAULT_INFO("***** %s %d) *****",
    2fe2:	4905      	ldr	r1, [pc, #20]	; (2ff8 <reserved_exception+0x44>)
    2fe4:	e7f8      	b.n	2fd8 <reserved_exception+0x24>
    2fe6:	bf00      	nop
    2fe8:	000079e4 	.word	0x000079e4
    2fec:	000079c4 	.word	0x000079c4
    2ff0:	00008104 	.word	0x00008104
    2ff4:	00008138 	.word	0x00008138
    2ff8:	0000811c 	.word	0x0000811c

00002ffc <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    2ffc:	b570      	push	{r4, r5, r6, lr}
    2ffe:	b08a      	sub	sp, #40	; 0x28
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    3000:	4b2b      	ldr	r3, [pc, #172]	; (30b0 <z_arm_fault+0xb4>)
    3002:	685d      	ldr	r5, [r3, #4]
    3004:	f3c5 0508 	ubfx	r5, r5, #0, #9
    3008:	2300      	movs	r3, #0
    300a:	f383 8811 	msr	BASEPRI, r3
    300e:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    3012:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
    3016:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
    301a:	d12a      	bne.n	3072 <z_arm_fault+0x76>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    301c:	f002 030c 	and.w	r3, r2, #12
    3020:	2b08      	cmp	r3, #8
    3022:	d010      	beq.n	3046 <z_arm_fault+0x4a>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    3024:	f012 0f08 	tst.w	r2, #8
    3028:	d020      	beq.n	306c <z_arm_fault+0x70>
			ptr_esf =  (z_arch_esf_t *)psp;
    302a:	460c      	mov	r4, r1
	*nested_exc = false;
    302c:	2600      	movs	r6, #0

#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
    302e:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    3032:	4629      	mov	r1, r5
    3034:	4620      	mov	r0, r4
    3036:	f003 fc70 	bl	691a <fault_handle>
    303a:	4605      	mov	r5, r0
	if (recoverable) {
    303c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3040:	b1d3      	cbz	r3, 3078 <z_arm_fault+0x7c>
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
	}

	z_arm_fatal_error(reason, &esf_copy);
}
    3042:	b00a      	add	sp, #40	; 0x28
    3044:	bd70      	pop	{r4, r5, r6, pc}
    3046:	4b1b      	ldr	r3, [pc, #108]	; (30b4 <z_arm_fault+0xb8>)
    3048:	4a1b      	ldr	r2, [pc, #108]	; (30b8 <z_arm_fault+0xbc>)
    304a:	1a9b      	subs	r3, r3, r2
    304c:	08db      	lsrs	r3, r3, #3
		PR_EXC("SPSEL in thread mode does not indicate PSP");
    304e:	f04f 0100 	mov.w	r1, #0
    3052:	2201      	movs	r2, #1
    3054:	f362 0102 	bfi	r1, r2, #0, #3
    3058:	f36f 01c5 	bfc	r1, #3, #3
    305c:	f363 118f 	bfi	r1, r3, #6, #10
    3060:	4816      	ldr	r0, [pc, #88]	; (30bc <z_arm_fault+0xc0>)
    3062:	f7fe fb83 	bl	176c <log_0>
	*nested_exc = false;
    3066:	2600      	movs	r6, #0
		return NULL;
    3068:	4634      	mov	r4, r6
    306a:	e7e0      	b.n	302e <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    306c:	4604      	mov	r4, r0
			*nested_exc = true;
    306e:	2601      	movs	r6, #1
    3070:	e7dd      	b.n	302e <z_arm_fault+0x32>
	*nested_exc = false;
    3072:	2600      	movs	r6, #0
		return NULL;
    3074:	4634      	mov	r4, r6
    3076:	e7da      	b.n	302e <z_arm_fault+0x32>
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    3078:	2220      	movs	r2, #32
    307a:	4621      	mov	r1, r4
    307c:	a801      	add	r0, sp, #4
    307e:	f003 fce8 	bl	6a52 <memcpy>
	if (nested_exc) {
    3082:	b14e      	cbz	r6, 3098 <z_arm_fault+0x9c>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    3084:	9b08      	ldr	r3, [sp, #32]
    3086:	f3c3 0208 	ubfx	r2, r3, #0, #9
    308a:	b95a      	cbnz	r2, 30a4 <z_arm_fault+0xa8>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    308c:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    3090:	ea6f 2343 	mvn.w	r3, r3, lsl #9
    3094:	9308      	str	r3, [sp, #32]
    3096:	e005      	b.n	30a4 <z_arm_fault+0xa8>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    3098:	9b08      	ldr	r3, [sp, #32]
    309a:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    309e:	f023 0301 	bic.w	r3, r3, #1
    30a2:	9308      	str	r3, [sp, #32]
	z_arm_fatal_error(reason, &esf_copy);
    30a4:	a901      	add	r1, sp, #4
    30a6:	4628      	mov	r0, r5
    30a8:	f003 fc1d 	bl	68e6 <z_arm_fatal_error>
    30ac:	e7c9      	b.n	3042 <z_arm_fault+0x46>
    30ae:	bf00      	nop
    30b0:	e000ed00 	.word	0xe000ed00
    30b4:	000079e4 	.word	0x000079e4
    30b8:	000079c4 	.word	0x000079c4
    30bc:	0000814c 	.word	0x0000814c

000030c0 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    30c0:	4a02      	ldr	r2, [pc, #8]	; (30cc <z_arm_fault_init+0xc>)
    30c2:	6953      	ldr	r3, [r2, #20]
    30c4:	f043 0310 	orr.w	r3, r3, #16
    30c8:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    30ca:	4770      	bx	lr
    30cc:	e000ed00 	.word	0xe000ed00

000030d0 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    30d0:	4b04      	ldr	r3, [pc, #16]	; (30e4 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    30d2:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    30d4:	6a58      	ldr	r0, [r3, #36]	; 0x24
	cmp r0, r1
    30d6:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    30d8:	d003      	beq.n	30e2 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    30da:	4903      	ldr	r1, [pc, #12]	; (30e8 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    30dc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    30e0:	600a      	str	r2, [r1, #0]

000030e2 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    30e2:	4770      	bx	lr
	ldr r3, =_kernel
    30e4:	20000a24 	.word	0x20000a24
	ldr r1, =_SCS_ICSR
    30e8:	e000ed04 	.word	0xe000ed04

000030ec <z_arm_clear_arm_mpu_config>:
void z_arm_clear_arm_mpu_config(void)
{
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
    30ec:	4b06      	ldr	r3, [pc, #24]	; (3108 <z_arm_clear_arm_mpu_config+0x1c>)
    30ee:	6818      	ldr	r0, [r3, #0]
	int num_regions =
    30f0:	f3c0 2007 	ubfx	r0, r0, #8, #8

	for (i = 0; i < num_regions; i++) {
    30f4:	2300      	movs	r3, #0
    30f6:	4283      	cmp	r3, r0
    30f8:	da05      	bge.n	3106 <z_arm_clear_arm_mpu_config+0x1a>
/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
    30fa:	4a03      	ldr	r2, [pc, #12]	; (3108 <z_arm_clear_arm_mpu_config+0x1c>)
    30fc:	6093      	str	r3, [r2, #8]
  MPU->RASR = 0U;
    30fe:	2100      	movs	r1, #0
    3100:	6111      	str	r1, [r2, #16]
    3102:	3301      	adds	r3, #1
    3104:	e7f7      	b.n	30f6 <z_arm_clear_arm_mpu_config+0xa>
		ARM_MPU_ClrRegion(i);
	}
}
    3106:	4770      	bx	lr
    3108:	e000ed90 	.word	0xe000ed90

0000310c <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
    310c:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    310e:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
    3110:	2400      	movs	r4, #0
    3112:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
    3116:	f7ff ffe9 	bl	30ec <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    311a:	4623      	mov	r3, r4
    311c:	e008      	b.n	3130 <z_arm_init_arch_hw_at_boot+0x24>
		NVIC->ICER[i] = 0xFFFFFFFF;
    311e:	f103 0120 	add.w	r1, r3, #32
    3122:	4a0e      	ldr	r2, [pc, #56]	; (315c <z_arm_init_arch_hw_at_boot+0x50>)
    3124:	f04f 30ff 	mov.w	r0, #4294967295
    3128:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    312c:	3301      	adds	r3, #1
    312e:	b2db      	uxtb	r3, r3
    3130:	2b07      	cmp	r3, #7
    3132:	d9f4      	bls.n	311e <z_arm_init_arch_hw_at_boot+0x12>
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    3134:	2300      	movs	r3, #0
    3136:	e008      	b.n	314a <z_arm_init_arch_hw_at_boot+0x3e>
		NVIC->ICPR[i] = 0xFFFFFFFF;
    3138:	f103 0160 	add.w	r1, r3, #96	; 0x60
    313c:	4a07      	ldr	r2, [pc, #28]	; (315c <z_arm_init_arch_hw_at_boot+0x50>)
    313e:	f04f 30ff 	mov.w	r0, #4294967295
    3142:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    3146:	3301      	adds	r3, #1
    3148:	b2db      	uxtb	r3, r3
    314a:	2b07      	cmp	r3, #7
    314c:	d9f4      	bls.n	3138 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
    314e:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
    3150:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3154:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
    3158:	bd10      	pop	{r4, pc}
    315a:	bf00      	nop
    315c:	e000e100 	.word	0xe000e100

00003160 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    3160:	2200      	movs	r2, #0

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    3162:	e006      	b.n	3172 <z_arm_interrupt_init+0x12>
    3164:	f002 010f 	and.w	r1, r2, #15
    3168:	4b09      	ldr	r3, [pc, #36]	; (3190 <z_arm_interrupt_init+0x30>)
    316a:	440b      	add	r3, r1
    316c:	2120      	movs	r1, #32
    316e:	7619      	strb	r1, [r3, #24]
    3170:	3201      	adds	r2, #1
    3172:	2a26      	cmp	r2, #38	; 0x26
    3174:	dc0a      	bgt.n	318c <z_arm_interrupt_init+0x2c>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
    3176:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
    3178:	2b00      	cmp	r3, #0
    317a:	dbf3      	blt.n	3164 <z_arm_interrupt_init+0x4>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    317c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    3180:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    3184:	2120      	movs	r1, #32
    3186:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
    318a:	e7f1      	b.n	3170 <z_arm_interrupt_init+0x10>
	}
}
    318c:	4770      	bx	lr
    318e:	bf00      	nop
    3190:	e000ecfc 	.word	0xe000ecfc

00003194 <z_impl_k_thread_abort>:
#include <kswap.h>
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    3194:	b508      	push	{r3, lr}
	if (_current == thread) {
    3196:	4b08      	ldr	r3, [pc, #32]	; (31b8 <z_impl_k_thread_abort+0x24>)
    3198:	689b      	ldr	r3, [r3, #8]
    319a:	4283      	cmp	r3, r0
    319c:	d002      	beq.n	31a4 <z_impl_k_thread_abort+0x10>
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
		}
	}

	z_thread_abort(thread);
    319e:	f002 fa47 	bl	5630 <z_thread_abort>
}
    31a2:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    31a4:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    31a8:	2b00      	cmp	r3, #0
    31aa:	d0f8      	beq.n	319e <z_impl_k_thread_abort+0xa>
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    31ac:	4a03      	ldr	r2, [pc, #12]	; (31bc <z_impl_k_thread_abort+0x28>)
    31ae:	6853      	ldr	r3, [r2, #4]
    31b0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    31b4:	6053      	str	r3, [r2, #4]
    31b6:	e7f2      	b.n	319e <z_impl_k_thread_abort+0xa>
    31b8:	20000a24 	.word	0x20000a24
    31bc:	e000ed00 	.word	0xe000ed00

000031c0 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    31c0:	b508      	push	{r3, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    31c2:	4b03      	ldr	r3, [pc, #12]	; (31d0 <z_arm_configure_static_mpu_regions+0x10>)
    31c4:	4a03      	ldr	r2, [pc, #12]	; (31d4 <z_arm_configure_static_mpu_regions+0x14>)
    31c6:	2101      	movs	r1, #1
    31c8:	4803      	ldr	r0, [pc, #12]	; (31d8 <z_arm_configure_static_mpu_regions+0x18>)
    31ca:	f003 fbfb 	bl	69c4 <arm_core_mpu_configure_static_mpu_regions>
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    31ce:	bd08      	pop	{r3, pc}
    31d0:	20010000 	.word	0x20010000
    31d4:	20000000 	.word	0x20000000
    31d8:	0000817c 	.word	0x0000817c

000031dc <z_arm_configure_dynamic_mpu_regions>:
 *
 * This function is not inherently thread-safe, but the memory domain
 * spinlock needs to be held anyway.
 */
void z_arm_configure_dynamic_mpu_regions(struct k_thread *thread)
{
    31dc:	b508      	push	{r3, lr}
#endif /* CONFIG_USERSPACE */
	{
		/* A supervisor thread only has the normal thread stack to
		 * protect with a stack guard.
		 */
		guard_start = thread->stack_info.start - guard_size;
    31de:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
    31e2:	3b20      	subs	r3, #32
	}

	__ASSERT(region_num < _MAX_DYNAMIC_MPU_REGIONS_NUM,
		"Out-of-bounds error for dynamic region map.");

	dynamic_regions[region_num].start = guard_start;
    31e4:	4804      	ldr	r0, [pc, #16]	; (31f8 <z_arm_configure_dynamic_mpu_regions+0x1c>)
    31e6:	6003      	str	r3, [r0, #0]
	dynamic_regions[region_num].size = guard_size;
    31e8:	2320      	movs	r3, #32
    31ea:	6043      	str	r3, [r0, #4]
	dynamic_regions[region_num].attr = K_MEM_PARTITION_P_RO_U_NA;
    31ec:	4b03      	ldr	r3, [pc, #12]	; (31fc <z_arm_configure_dynamic_mpu_regions+0x20>)
    31ee:	6083      	str	r3, [r0, #8]

	region_num++;
#endif /* CONFIG_MPU_STACK_GUARD */

	/* Configure the dynamic MPU regions */
	arm_core_mpu_configure_dynamic_mpu_regions(dynamic_regions,
    31f0:	2101      	movs	r1, #1
    31f2:	f003 fbeb 	bl	69cc <arm_core_mpu_configure_dynamic_mpu_regions>
						   region_num);
}
    31f6:	bd08      	pop	{r3, pc}
    31f8:	200004e0 	.word	0x200004e0
    31fc:	150b0000 	.word	0x150b0000

00003200 <region_init>:
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Select the region you want to access */
	MPU->RNR = index;
    3200:	4a06      	ldr	r2, [pc, #24]	; (321c <region_init+0x1c>)
    3202:	6090      	str	r0, [r2, #8]
	/* Configure the region */
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    3204:	680b      	ldr	r3, [r1, #0]
    3206:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    320a:	4303      	orrs	r3, r0
    320c:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    3210:	60d3      	str	r3, [r2, #12]
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    3212:	688b      	ldr	r3, [r1, #8]
    3214:	f043 0301 	orr.w	r3, r3, #1
    3218:	6113      	str	r3, [r2, #16]
	LOG_DBG("[%d] 0x%08x 0x%08x",
		index, region_conf->base, region_conf->attr.rasr);
}
    321a:	4770      	bx	lr
    321c:	e000ed90 	.word	0xe000ed90

00003220 <region_allocate_and_init>:
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
    3220:	b510      	push	{r4, lr}
    3222:	4604      	mov	r4, r0
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
    3224:	2807      	cmp	r0, #7
    3226:	d803      	bhi.n	3230 <region_allocate_and_init+0x10>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    3228:	f7ff ffea 	bl	3200 <region_init>

	return index;
    322c:	4620      	mov	r0, r4
}
    322e:	bd10      	pop	{r4, pc}
    3230:	4b09      	ldr	r3, [pc, #36]	; (3258 <region_allocate_and_init+0x38>)
    3232:	4a0a      	ldr	r2, [pc, #40]	; (325c <region_allocate_and_init+0x3c>)
    3234:	1a9b      	subs	r3, r3, r2
    3236:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
    3238:	f04f 0200 	mov.w	r2, #0
    323c:	2101      	movs	r1, #1
    323e:	f361 0202 	bfi	r2, r1, #0, #3
    3242:	f36f 02c5 	bfc	r2, #3, #3
    3246:	f363 128f 	bfi	r2, r3, #6, #10
    324a:	4601      	mov	r1, r0
    324c:	4804      	ldr	r0, [pc, #16]	; (3260 <region_allocate_and_init+0x40>)
    324e:	f7fe fa1b 	bl	1688 <log_1>
		return -EINVAL;
    3252:	f06f 0015 	mvn.w	r0, #21
    3256:	e7ea      	b.n	322e <region_allocate_and_init+0xe>
    3258:	000079dc 	.word	0x000079dc
    325c:	000079c4 	.word	0x000079c4
    3260:	00008188 	.word	0x00008188

00003264 <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    3264:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3268:	4680      	mov	r8, r0
    326a:	460f      	mov	r7, r1
    326c:	469a      	mov	sl, r3
	int i;
	int reg_index = start_reg_index;
    326e:	4616      	mov	r6, r2

	for (i = 0; i < regions_num; i++) {
    3270:	2400      	movs	r4, #0
    3272:	e009      	b.n	3288 <mpu_configure_regions+0x24>
				(!mpu_partition_is_valid(&regions[i]))) {
			LOG_ERR("Partition %u: sanity check failed.", i);
			return -EINVAL;
		}

		reg_index = mpu_configure_region(reg_index, &regions[i]);
    3274:	4629      	mov	r1, r5
    3276:	b2f0      	uxtb	r0, r6
    3278:	f003 fb85 	bl	6986 <mpu_configure_region>
    327c:	4606      	mov	r6, r0

		if (reg_index == -EINVAL) {
    327e:	f110 0f16 	cmn.w	r0, #22
    3282:	d025      	beq.n	32d0 <mpu_configure_regions+0x6c>
			return reg_index;
		}

		/* Increment number of programmed MPU indices. */
		reg_index++;
    3284:	3601      	adds	r6, #1
	for (i = 0; i < regions_num; i++) {
    3286:	3401      	adds	r4, #1
    3288:	42bc      	cmp	r4, r7
    328a:	da21      	bge.n	32d0 <mpu_configure_regions+0x6c>
		if (regions[i].size == 0U) {
    328c:	eb04 0544 	add.w	r5, r4, r4, lsl #1
    3290:	eb08 0585 	add.w	r5, r8, r5, lsl #2
    3294:	686a      	ldr	r2, [r5, #4]
    3296:	2a00      	cmp	r2, #0
    3298:	d0f5      	beq.n	3286 <mpu_configure_regions+0x22>
		if (do_sanity_check &&
    329a:	f1ba 0f00 	cmp.w	sl, #0
    329e:	d0e9      	beq.n	3274 <mpu_configure_regions+0x10>
				(!mpu_partition_is_valid(&regions[i]))) {
    32a0:	4628      	mov	r0, r5
    32a2:	f003 fb5f 	bl	6964 <mpu_partition_is_valid>
		if (do_sanity_check &&
    32a6:	2800      	cmp	r0, #0
    32a8:	d1e4      	bne.n	3274 <mpu_configure_regions+0x10>
    32aa:	4b0b      	ldr	r3, [pc, #44]	; (32d8 <mpu_configure_regions+0x74>)
    32ac:	4a0b      	ldr	r2, [pc, #44]	; (32dc <mpu_configure_regions+0x78>)
    32ae:	1a9b      	subs	r3, r3, r2
    32b0:	08db      	lsrs	r3, r3, #3
			LOG_ERR("Partition %u: sanity check failed.", i);
    32b2:	f04f 0200 	mov.w	r2, #0
    32b6:	2101      	movs	r1, #1
    32b8:	f361 0202 	bfi	r2, r1, #0, #3
    32bc:	f36f 02c5 	bfc	r2, #3, #3
    32c0:	f363 128f 	bfi	r2, r3, #6, #10
    32c4:	4621      	mov	r1, r4
    32c6:	4806      	ldr	r0, [pc, #24]	; (32e0 <mpu_configure_regions+0x7c>)
    32c8:	f7fe f9de 	bl	1688 <log_1>
			return -EINVAL;
    32cc:	f06f 0615 	mvn.w	r6, #21
	}

	return reg_index;
}
    32d0:	4630      	mov	r0, r6
    32d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    32d6:	bf00      	nop
    32d8:	000079dc 	.word	0x000079dc
    32dc:	000079c4 	.word	0x000079c4
    32e0:	000081b0 	.word	0x000081b0

000032e4 <mpu_configure_static_mpu_regions>:
 */
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
    32e4:	b510      	push	{r4, lr}
	int mpu_reg_index = static_regions_num;
    32e6:	4c03      	ldr	r4, [pc, #12]	; (32f4 <mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    32e8:	2301      	movs	r3, #1
    32ea:	7822      	ldrb	r2, [r4, #0]
    32ec:	f7ff ffba 	bl	3264 <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    32f0:	7020      	strb	r0, [r4, #0]

	return mpu_reg_index;
}
    32f2:	bd10      	pop	{r4, pc}
    32f4:	20000a76 	.word	0x20000a76

000032f8 <mpu_configure_dynamic_mpu_regions>:
 * If the dynamic MPU regions configuration has not been successfully
 * performed, the error signal is propagated to the caller of the function.
 */
static int mpu_configure_dynamic_mpu_regions(const struct z_arm_mpu_partition
	dynamic_regions[], uint8_t regions_num)
{
    32f8:	b508      	push	{r3, lr}

	/* In ARMv7-M architecture the dynamic regions are
	 * programmed on top of existing SRAM region configuration.
	 */

	mpu_reg_index = mpu_configure_regions(dynamic_regions,
    32fa:	2300      	movs	r3, #0
    32fc:	4a08      	ldr	r2, [pc, #32]	; (3320 <mpu_configure_dynamic_mpu_regions+0x28>)
    32fe:	7812      	ldrb	r2, [r2, #0]
    3300:	f7ff ffb0 	bl	3264 <mpu_configure_regions>
		regions_num, mpu_reg_index, false);

	if (mpu_reg_index != -EINVAL) {
    3304:	f110 0f16 	cmn.w	r0, #22
    3308:	d008      	beq.n	331c <mpu_configure_dynamic_mpu_regions+0x24>

		/* Disable the non-programmed MPU regions. */
		for (int i = mpu_reg_index; i < get_num_regions(); i++) {
    330a:	4603      	mov	r3, r0
    330c:	2b07      	cmp	r3, #7
    330e:	dc05      	bgt.n	331c <mpu_configure_dynamic_mpu_regions+0x24>
  MPU->RNR = rnr;
    3310:	4a04      	ldr	r2, [pc, #16]	; (3324 <mpu_configure_dynamic_mpu_regions+0x2c>)
    3312:	6093      	str	r3, [r2, #8]
  MPU->RASR = 0U;
    3314:	2100      	movs	r1, #0
    3316:	6111      	str	r1, [r2, #16]
    3318:	3301      	adds	r3, #1
    331a:	e7f7      	b.n	330c <mpu_configure_dynamic_mpu_regions+0x14>
			ARM_MPU_ClrRegion(i);
		}
	}

	return mpu_reg_index;
}
    331c:	bd08      	pop	{r3, pc}
    331e:	bf00      	nop
    3320:	20000a76 	.word	0x20000a76
    3324:	e000ed90 	.word	0xe000ed90

00003328 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    3328:	4b03      	ldr	r3, [pc, #12]	; (3338 <arm_core_mpu_enable+0x10>)
    332a:	2205      	movs	r2, #5
    332c:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    332e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    3332:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    3336:	4770      	bx	lr
    3338:	e000ed90 	.word	0xe000ed90

0000333c <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    333c:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    3340:	4b01      	ldr	r3, [pc, #4]	; (3348 <arm_core_mpu_disable+0xc>)
    3342:	2200      	movs	r2, #0
    3344:	605a      	str	r2, [r3, #4]
}
    3346:	4770      	bx	lr
    3348:	e000ed90 	.word	0xe000ed90

0000334c <z_arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
int z_arm_mpu_init(void)
{
    334c:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    334e:	4b0e      	ldr	r3, [pc, #56]	; (3388 <z_arm_mpu_init+0x3c>)
    3350:	681d      	ldr	r5, [r3, #0]
    3352:	2d08      	cmp	r5, #8
    3354:	d815      	bhi.n	3382 <z_arm_mpu_init+0x36>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    3356:	f7ff fff1 	bl	333c <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    335a:	2400      	movs	r4, #0
    335c:	42a5      	cmp	r5, r4
    335e:	d90a      	bls.n	3376 <z_arm_mpu_init+0x2a>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    3360:	4b09      	ldr	r3, [pc, #36]	; (3388 <z_arm_mpu_init+0x3c>)
    3362:	6859      	ldr	r1, [r3, #4]
    3364:	eb04 0244 	add.w	r2, r4, r4, lsl #1
    3368:	0093      	lsls	r3, r2, #2
    336a:	4419      	add	r1, r3
    336c:	4620      	mov	r0, r4
    336e:	f7ff ff47 	bl	3200 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    3372:	3401      	adds	r4, #1
    3374:	e7f2      	b.n	335c <z_arm_mpu_init+0x10>
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    3376:	4b05      	ldr	r3, [pc, #20]	; (338c <z_arm_mpu_init+0x40>)
    3378:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    337a:	f7ff ffd5 	bl	3328 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    337e:	2000      	movs	r0, #0
}
    3380:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
    3382:	f04f 30ff 	mov.w	r0, #4294967295
    3386:	e7fb      	b.n	3380 <z_arm_mpu_init+0x34>
    3388:	000081e4 	.word	0x000081e4
    338c:	20000a76 	.word	0x20000a76

00003390 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    3390:	4b01      	ldr	r3, [pc, #4]	; (3398 <__stdout_hook_install+0x8>)
    3392:	6018      	str	r0, [r3, #0]
}
    3394:	4770      	bx	lr
    3396:	bf00      	nop
    3398:	2000000c 	.word	0x2000000c

0000339c <nordicsemi_nrf52_init>:
	__asm__ volatile(
    339c:	f04f 0320 	mov.w	r3, #32
    33a0:	f3ef 8211 	mrs	r2, BASEPRI
    33a4:	f383 8811 	msr	BASEPRI, r3
    33a8:	f3bf 8f6f 	isb	sy

	key = irq_lock();

#ifdef CONFIG_NRF_ENABLE_ICACHE
	/* Enable the instruction cache */
	NRF_NVMC->ICACHECNF = NVMC_ICACHECNF_CACHEEN_Msk;
    33ac:	2301      	movs	r3, #1
    33ae:	4906      	ldr	r1, [pc, #24]	; (33c8 <nordicsemi_nrf52_init+0x2c>)
    33b0:	f8c1 3540 	str.w	r3, [r1, #1344]	; 0x540
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    33b4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    33b8:	f8c1 3578 	str.w	r3, [r1, #1400]	; 0x578
	__asm__ volatile(
    33bc:	f382 8811 	msr	BASEPRI, r2
    33c0:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    33c4:	2000      	movs	r0, #0
    33c6:	4770      	bx	lr
    33c8:	4001e000 	.word	0x4001e000

000033cc <sys_arch_reboot>:
    *p_gpregret = val;
    33cc:	b2c0      	uxtb	r0, r0
    33ce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    33d2:	f8c3 051c 	str.w	r0, [r3, #1308]	; 0x51c
  __ASM volatile ("dsb 0xF":::"memory");
    33d6:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    33da:	4905      	ldr	r1, [pc, #20]	; (33f0 <sys_arch_reboot+0x24>)
    33dc:	68ca      	ldr	r2, [r1, #12]
    33de:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    33e2:	4b04      	ldr	r3, [pc, #16]	; (33f4 <sys_arch_reboot+0x28>)
    33e4:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    33e6:	60cb      	str	r3, [r1, #12]
    33e8:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    33ec:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    33ee:	e7fd      	b.n	33ec <sys_arch_reboot+0x20>
    33f0:	e000ed00 	.word	0xe000ed00
    33f4:	05fa0004 	.word	0x05fa0004

000033f8 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    33f8:	b130      	cbz	r0, 3408 <arch_busy_wait+0x10>

void arch_busy_wait(uint32_t time_us)
{
    33fa:	b508      	push	{r3, lr}
    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    33fc:	0180      	lsls	r0, r0, #6
    33fe:	4b03      	ldr	r3, [pc, #12]	; (340c <arch_busy_wait+0x14>)
    3400:	f043 0301 	orr.w	r3, r3, #1
    3404:	4798      	blx	r3
	nrfx_coredep_delay_us(time_us);
}
    3406:	bd08      	pop	{r3, pc}
    3408:	4770      	bx	lr
    340a:	bf00      	nop
    340c:	00007aa0 	.word	0x00007aa0

00003410 <gpio_nrfx_config>:
	return res;
}

static int gpio_nrfx_config(const struct device *port,
			    gpio_pin_t pin, gpio_flags_t flags)
{
    3410:	b470      	push	{r4, r5, r6}
	return port->config;
    3412:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    3414:	685e      	ldr	r6, [r3, #4]
	nrf_gpio_pin_pull_t pull;
	nrf_gpio_pin_drive_t drive;
	nrf_gpio_pin_dir_t dir;
	nrf_gpio_pin_input_t input;

	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    3416:	4b32      	ldr	r3, [pc, #200]	; (34e0 <gpio_nrfx_config+0xd0>)
    3418:	4013      	ands	r3, r2
    341a:	4832      	ldr	r0, [pc, #200]	; (34e4 <gpio_nrfx_config+0xd4>)
    341c:	4283      	cmp	r3, r0
    341e:	d027      	beq.n	3470 <gpio_nrfx_config+0x60>
    3420:	d812      	bhi.n	3448 <gpio_nrfx_config+0x38>
    3422:	2b06      	cmp	r3, #6
    3424:	d026      	beq.n	3474 <gpio_nrfx_config+0x64>
    3426:	d904      	bls.n	3432 <gpio_nrfx_config+0x22>
    3428:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    342c:	d109      	bne.n	3442 <gpio_nrfx_config+0x32>
	case GPIO_DS_DFLT_LOW | GPIO_OPEN_DRAIN:
		drive = NRF_GPIO_PIN_S0D1;
		break;

	case GPIO_DS_ALT_LOW | GPIO_DS_DFLT_HIGH:
		drive = NRF_GPIO_PIN_H0S1;
    342e:	2001      	movs	r0, #1
    3430:	e016      	b.n	3460 <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    3432:	b30b      	cbz	r3, 3478 <gpio_nrfx_config+0x68>
    3434:	2b02      	cmp	r3, #2
    3436:	d101      	bne.n	343c <gpio_nrfx_config+0x2c>
	case GPIO_DS_ALT_LOW | GPIO_OPEN_DRAIN:
		drive = NRF_GPIO_PIN_H0D1;
		break;

	case GPIO_DS_DFLT_HIGH | GPIO_OPEN_SOURCE:
		drive = NRF_GPIO_PIN_D0S1;
    3438:	2004      	movs	r0, #4
    343a:	e011      	b.n	3460 <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    343c:	f06f 0015 	mvn.w	r0, #21
    3440:	e03f      	b.n	34c2 <gpio_nrfx_config+0xb2>
    3442:	f06f 0015 	mvn.w	r0, #21
    3446:	e03c      	b.n	34c2 <gpio_nrfx_config+0xb2>
    3448:	4827      	ldr	r0, [pc, #156]	; (34e8 <gpio_nrfx_config+0xd8>)
    344a:	4283      	cmp	r3, r0
    344c:	d016      	beq.n	347c <gpio_nrfx_config+0x6c>
    344e:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    3452:	d101      	bne.n	3458 <gpio_nrfx_config+0x48>
		drive = NRF_GPIO_PIN_H0H1;
    3454:	2003      	movs	r0, #3
    3456:	e003      	b.n	3460 <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    3458:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    345c:	d13d      	bne.n	34da <gpio_nrfx_config+0xca>
		drive = NRF_GPIO_PIN_S0H1;
    345e:	2002      	movs	r0, #2

	default:
		return -EINVAL;
	}

	if ((flags & GPIO_PULL_UP) != 0) {
    3460:	f012 0f10 	tst.w	r2, #16
    3464:	d10c      	bne.n	3480 <gpio_nrfx_config+0x70>
		pull = NRF_GPIO_PIN_PULLUP;
	} else if ((flags & GPIO_PULL_DOWN) != 0) {
    3466:	f012 0f20 	tst.w	r2, #32
    346a:	d02c      	beq.n	34c6 <gpio_nrfx_config+0xb6>
		pull = NRF_GPIO_PIN_PULLDOWN;
    346c:	2401      	movs	r4, #1
    346e:	e008      	b.n	3482 <gpio_nrfx_config+0x72>
		drive = NRF_GPIO_PIN_H0D1;
    3470:	2007      	movs	r0, #7
    3472:	e7f5      	b.n	3460 <gpio_nrfx_config+0x50>
		drive = NRF_GPIO_PIN_S0D1;
    3474:	2006      	movs	r0, #6
    3476:	e7f3      	b.n	3460 <gpio_nrfx_config+0x50>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    3478:	2000      	movs	r0, #0
    347a:	e7f1      	b.n	3460 <gpio_nrfx_config+0x50>
		drive = NRF_GPIO_PIN_D0H1;
    347c:	2005      	movs	r0, #5
    347e:	e7ef      	b.n	3460 <gpio_nrfx_config+0x50>
		pull = NRF_GPIO_PIN_PULLUP;
    3480:	2403      	movs	r4, #3
	} else {
		pull = NRF_GPIO_PIN_NOPULL;
	}

	dir = ((flags & GPIO_OUTPUT) != 0)
    3482:	f3c2 2340 	ubfx	r3, r2, #9, #1
	      ? NRF_GPIO_PIN_DIR_OUTPUT
	      : NRF_GPIO_PIN_DIR_INPUT;

	input = ((flags & GPIO_INPUT) != 0)
		? NRF_GPIO_PIN_INPUT_CONNECT
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    3486:	f412 7f80 	tst.w	r2, #256	; 0x100
    348a:	bf0c      	ite	eq
    348c:	2501      	moveq	r5, #1
    348e:	2500      	movne	r5, #0

	if ((flags & GPIO_OUTPUT) != 0) {
    3490:	f412 7f00 	tst.w	r2, #512	; 0x200
    3494:	d006      	beq.n	34a4 <gpio_nrfx_config+0x94>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    3496:	f412 6f00 	tst.w	r2, #2048	; 0x800
    349a:	d016      	beq.n	34ca <gpio_nrfx_config+0xba>
			nrf_gpio_port_out_set(reg, BIT(pin));
    349c:	2201      	movs	r2, #1
    349e:	408a      	lsls	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
    34a0:	f8c6 2508 	str.w	r2, [r6, #1288]	; 0x508
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    34a4:	f001 011f 	and.w	r1, r1, #31
    cnf |= ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)     |
    34a8:	ea43 0345 	orr.w	r3, r3, r5, lsl #1
           ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos) |
    34ac:	ea43 0384 	orr.w	r3, r3, r4, lsl #2
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    34b0:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    reg->PIN_CNF[pin_number] = cnf;
    34b4:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
    34b8:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    34bc:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	}

	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
		     dir, input, pull, drive, NRF_GPIO_PIN_NOSENSE);

	return 0;
    34c0:	2000      	movs	r0, #0
}
    34c2:	bc70      	pop	{r4, r5, r6}
    34c4:	4770      	bx	lr
		pull = NRF_GPIO_PIN_NOPULL;
    34c6:	2400      	movs	r4, #0
    34c8:	e7db      	b.n	3482 <gpio_nrfx_config+0x72>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    34ca:	f412 6f80 	tst.w	r2, #1024	; 0x400
    34ce:	d0e9      	beq.n	34a4 <gpio_nrfx_config+0x94>
			nrf_gpio_port_out_clear(reg, BIT(pin));
    34d0:	2201      	movs	r2, #1
    34d2:	408a      	lsls	r2, r1
    p_reg->OUTCLR = clr_mask;
    34d4:	f8c6 250c 	str.w	r2, [r6, #1292]	; 0x50c
}
    34d8:	e7e4      	b.n	34a4 <gpio_nrfx_config+0x94>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    34da:	f06f 0015 	mvn.w	r0, #21
    34de:	e7f0      	b.n	34c2 <gpio_nrfx_config+0xb2>
    34e0:	00f00006 	.word	0x00f00006
    34e4:	00100006 	.word	0x00100006
    34e8:	00400002 	.word	0x00400002

000034ec <gpiote_event_handler>:

	gpio_fire_callbacks(list, port, pins);
}

static void gpiote_event_handler(void)
{
    34ec:	b570      	push	{r4, r5, r6, lr}
    34ee:	b082      	sub	sp, #8
	uint32_t fired_triggers[GPIO_COUNT] = {0};
    34f0:	2300      	movs	r3, #0
    34f2:	9301      	str	r3, [sp, #4]
	uint32_t sense_levels[GPIO_COUNT] = {0};
    34f4:	9300      	str	r3, [sp, #0]
}

NRF_STATIC_INLINE bool nrf_gpiote_event_check(NRF_GPIOTE_Type const * p_reg,
                                              nrf_gpiote_event_t      event)
{
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    34f6:	4b2e      	ldr	r3, [pc, #184]	; (35b0 <gpiote_event_handler+0xc4>)
    34f8:	681c      	ldr	r4, [r3, #0]
	bool port_event = nrf_gpiote_event_check(NRF_GPIOTE,
						 NRF_GPIOTE_EVENT_PORT);

	if (port_event) {
    34fa:	b90c      	cbnz	r4, 3500 <gpiote_event_handler+0x14>
{
    34fc:	2100      	movs	r1, #0
    34fe:	e00a      	b.n	3516 <gpiote_event_handler+0x2a>
#ifdef CONFIG_GPIO_NRF_P0
		fired_triggers[0] =
			check_level_trigger_pins(DEVICE_DT_GET(GPIO(0)),
    3500:	4669      	mov	r1, sp
    3502:	482c      	ldr	r0, [pc, #176]	; (35b4 <gpiote_event_handler+0xc8>)
    3504:	f003 fb92 	bl	6c2c <check_level_trigger_pins>
		fired_triggers[0] =
    3508:	9001      	str	r0, [sp, #4]
}

NRF_STATIC_INLINE void nrf_gpiote_event_clear(NRF_GPIOTE_Type * p_reg, nrf_gpiote_event_t event)
{
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    350a:	4b29      	ldr	r3, [pc, #164]	; (35b0 <gpiote_event_handler+0xc4>)
    350c:	2200      	movs	r2, #0
    350e:	601a      	str	r2, [r3, #0]
    3510:	681b      	ldr	r3, [r3, #0]
    nrf_event_readback((void *)nrf_gpiote_event_address_get(p_reg, event));
}
    3512:	e7f3      	b.n	34fc <gpiote_event_handler+0x10>
		 */
		nrf_gpiote_event_clear(NRF_GPIOTE, NRF_GPIOTE_EVENT_PORT);
	}

	/* Handle interrupt from GPIOTE channels. */
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    3514:	3101      	adds	r1, #1
    3516:	2907      	cmp	r1, #7
    3518:	d826      	bhi.n	3568 <gpiote_event_handler+0x7c>
		nrf_gpiote_event_t evt =
    351a:	f101 0340 	add.w	r3, r1, #64	; 0x40
    351e:	009b      	lsls	r3, r3, #2
    3520:	b29a      	uxth	r2, r3
			offsetof(NRF_GPIOTE_Type, EVENTS_IN[i]);

		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    3522:	2301      	movs	r3, #1
    3524:	408b      	lsls	r3, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    3526:	4824      	ldr	r0, [pc, #144]	; (35b8 <gpiote_event_handler+0xcc>)
    3528:	f8d0 0304 	ldr.w	r0, [r0, #772]	; 0x304
    352c:	4203      	tst	r3, r0
    352e:	d0f1      	beq.n	3514 <gpiote_event_handler+0x28>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    3530:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    3534:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    3538:	681b      	ldr	r3, [r3, #0]
    353a:	2b00      	cmp	r3, #0
    353c:	d0ea      	beq.n	3514 <gpiote_event_handler+0x28>
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    353e:	f501 73a2 	add.w	r3, r1, #324	; 0x144
    3542:	481d      	ldr	r0, [pc, #116]	; (35b8 <gpiote_event_handler+0xcc>)
    3544:	f850 0023 	ldr.w	r0, [r0, r3, lsl #2]
    3548:	f3c0 2004 	ubfx	r0, r0, #8, #5
		    nrf_gpiote_event_check(NRF_GPIOTE, evt)) {
			uint32_t abs_pin = nrf_gpiote_event_pin_get(NRF_GPIOTE, i);
			/* Divide absolute pin number to port and pin parts. */
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    354c:	2301      	movs	r3, #1
    354e:	fa03 f000 	lsl.w	r0, r3, r0
    3552:	9b01      	ldr	r3, [sp, #4]
    3554:	4303      	orrs	r3, r0
    3556:	9301      	str	r3, [sp, #4]
    return ((uint32_t)p_reg + event);
    3558:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    355c:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    3560:	2200      	movs	r2, #0
    3562:	601a      	str	r2, [r3, #0]
    3564:	681b      	ldr	r3, [r3, #0]
}
    3566:	e7d5      	b.n	3514 <gpiote_event_handler+0x28>
		cfg_edge_sense_pins(DEVICE_DT_GET(GPIO(1)), sense_levels[1]);
#endif
	}

#ifdef CONFIG_GPIO_NRF_P0
	if (fired_triggers[0]) {
    3568:	9e01      	ldr	r6, [sp, #4]
    356a:	b916      	cbnz	r6, 3572 <gpiote_event_handler+0x86>
	if (fired_triggers[1]) {
		fire_callbacks(DEVICE_DT_GET(GPIO(1)), fired_triggers[1]);
	}
#endif

	if (port_event) {
    356c:	b9dc      	cbnz	r4, 35a6 <gpiote_event_handler+0xba>
#endif
#ifdef CONFIG_GPIO_NRF_P1
		cfg_level_pins(DEVICE_DT_GET(GPIO(1)));
#endif
	}
}
    356e:	b002      	add	sp, #8
    3570:	bd70      	pop	{r4, r5, r6, pc}
	return list->head;
    3572:	4b12      	ldr	r3, [pc, #72]	; (35bc <gpiote_event_handler+0xd0>)
    3574:	6859      	ldr	r1, [r3, #4]
					const struct device *port,
					uint32_t pins)
{
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    3576:	b119      	cbz	r1, 3580 <gpiote_event_handler+0x94>
    3578:	460d      	mov	r5, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
    357a:	b149      	cbz	r1, 3590 <gpiote_event_handler+0xa4>
	return node->next;
    357c:	680d      	ldr	r5, [r1, #0]
    357e:	e007      	b.n	3590 <gpiote_event_handler+0xa4>
    3580:	460d      	mov	r5, r1
    3582:	e005      	b.n	3590 <gpiote_event_handler+0xa4>
    3584:	b16d      	cbz	r5, 35a2 <gpiote_event_handler+0xb6>
    3586:	462b      	mov	r3, r5
Z_GENLIST_PEEK_NEXT(slist, snode)
    3588:	b105      	cbz	r5, 358c <gpiote_event_handler+0xa0>
	return node->next;
    358a:	682b      	ldr	r3, [r5, #0]
    358c:	4629      	mov	r1, r5
    358e:	461d      	mov	r5, r3
    3590:	2900      	cmp	r1, #0
    3592:	d0eb      	beq.n	356c <gpiote_event_handler+0x80>
		if (cb->pin_mask & pins) {
    3594:	688a      	ldr	r2, [r1, #8]
    3596:	4032      	ands	r2, r6
    3598:	d0f4      	beq.n	3584 <gpiote_event_handler+0x98>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
    359a:	684b      	ldr	r3, [r1, #4]
    359c:	4805      	ldr	r0, [pc, #20]	; (35b4 <gpiote_event_handler+0xc8>)
    359e:	4798      	blx	r3
    35a0:	e7f0      	b.n	3584 <gpiote_event_handler+0x98>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
    35a2:	462b      	mov	r3, r5
    35a4:	e7f2      	b.n	358c <gpiote_event_handler+0xa0>
		cfg_level_pins(DEVICE_DT_GET(GPIO(0)));
    35a6:	4803      	ldr	r0, [pc, #12]	; (35b4 <gpiote_event_handler+0xc8>)
    35a8:	f003 fb0e 	bl	6bc8 <cfg_level_pins>
}
    35ac:	e7df      	b.n	356e <gpiote_event_handler+0x82>
    35ae:	bf00      	nop
    35b0:	4000617c 	.word	0x4000617c
    35b4:	00007874 	.word	0x00007874
    35b8:	40006000 	.word	0x40006000
    35bc:	200004f0 	.word	0x200004f0

000035c0 <gpiote_pin_cleanup>:
{
    35c0:	b510      	push	{r4, lr}
    return p_reg->INTENSET & mask;
    35c2:	4b14      	ldr	r3, [pc, #80]	; (3614 <gpiote_pin_cleanup+0x54>)
    35c4:	f8d3 4304 	ldr.w	r4, [r3, #772]	; 0x304
    35c8:	b2e4      	uxtb	r4, r4
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    35ca:	2300      	movs	r3, #0
    35cc:	e000      	b.n	35d0 <gpiote_pin_cleanup+0x10>
    35ce:	3301      	adds	r3, #1
    35d0:	2b07      	cmp	r3, #7
    35d2:	d81d      	bhi.n	3610 <gpiote_pin_cleanup+0x50>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    35d4:	f503 72a2 	add.w	r2, r3, #324	; 0x144
    35d8:	490e      	ldr	r1, [pc, #56]	; (3614 <gpiote_pin_cleanup+0x54>)
    35da:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    35de:	f3c2 2204 	ubfx	r2, r2, #8, #5
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    35e2:	4290      	cmp	r0, r2
    35e4:	d1f3      	bne.n	35ce <gpiote_pin_cleanup+0xe>
		    && (intenset & BIT(i))) {
    35e6:	fa24 f203 	lsr.w	r2, r4, r3
    35ea:	f012 0f01 	tst.w	r2, #1
    35ee:	d0ee      	beq.n	35ce <gpiote_pin_cleanup+0xe>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    35f0:	460a      	mov	r2, r1
    35f2:	f503 70a2 	add.w	r0, r3, #324	; 0x144
    35f6:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
    35fa:	f021 0101 	bic.w	r1, r1, #1
    35fe:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    3602:	2101      	movs	r1, #1
    3604:	4099      	lsls	r1, r3
    p_reg->INTENCLR = mask;
    3606:	f8c2 1308 	str.w	r1, [r2, #776]	; 0x308
			nrfx_gpiote_channel_free(i);
    360a:	b2d8      	uxtb	r0, r3
    360c:	f000 fd2e 	bl	406c <nrfx_gpiote_channel_free>
}
    3610:	bd10      	pop	{r4, pc}
    3612:	bf00      	nop
    3614:	40006000 	.word	0x40006000

00003618 <gpiote_channel_alloc>:
{
    3618:	b570      	push	{r4, r5, r6, lr}
    361a:	b082      	sub	sp, #8
    361c:	4604      	mov	r4, r0
    361e:	460d      	mov	r5, r1
	if (nrfx_gpiote_channel_alloc(&channel) != NRFX_SUCCESS) {
    3620:	f10d 0007 	add.w	r0, sp, #7
    3624:	f000 fd3e 	bl	40a4 <nrfx_gpiote_channel_alloc>
    3628:	4b1c      	ldr	r3, [pc, #112]	; (369c <gpiote_channel_alloc+0x84>)
    362a:	4298      	cmp	r0, r3
    362c:	d132      	bne.n	3694 <gpiote_channel_alloc+0x7c>
	nrf_gpiote_event_t evt = offsetof(NRF_GPIOTE_Type, EVENTS_IN[channel]);
    362e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    3632:	f103 0240 	add.w	r2, r3, #64	; 0x40
    3636:	0092      	lsls	r2, r2, #2
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    3638:	4e19      	ldr	r6, [pc, #100]	; (36a0 <gpiote_channel_alloc+0x88>)
    363a:	f503 73a2 	add.w	r3, r3, #324	; 0x144
    363e:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
    3642:	f421 3147 	bic.w	r1, r1, #203776	; 0x31c00
    3646:	f421 7140 	bic.w	r1, r1, #768	; 0x300
    364a:	f846 1023 	str.w	r1, [r6, r3, lsl #2]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    364e:	f856 1023 	ldr.w	r1, [r6, r3, lsl #2]
    3652:	0224      	lsls	r4, r4, #8
    3654:	f404 54f8 	and.w	r4, r4, #7936	; 0x1f00
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
    3658:	042d      	lsls	r5, r5, #16
    365a:	f405 3540 	and.w	r5, r5, #196608	; 0x30000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    365e:	432c      	orrs	r4, r5
    3660:	430c      	orrs	r4, r1
    3662:	f846 4023 	str.w	r4, [r6, r3, lsl #2]
    return ((uint32_t)p_reg + event);
    3666:	f102 4380 	add.w	r3, r2, #1073741824	; 0x40000000
    366a:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    366e:	2000      	movs	r0, #0
    3670:	6018      	str	r0, [r3, #0]
    3672:	681b      	ldr	r3, [r3, #0]
	nrf_gpiote_event_enable(NRF_GPIOTE, channel);
    3674:	f89d 1007 	ldrb.w	r1, [sp, #7]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    3678:	f501 73a2 	add.w	r3, r1, #324	; 0x144
    367c:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
    3680:	f042 0201 	orr.w	r2, r2, #1
    3684:	f846 2023 	str.w	r2, [r6, r3, lsl #2]
	nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    3688:	2301      	movs	r3, #1
    368a:	408b      	lsls	r3, r1
    p_reg->INTENSET = mask;
    368c:	f8c6 3304 	str.w	r3, [r6, #772]	; 0x304
}
    3690:	b002      	add	sp, #8
    3692:	bd70      	pop	{r4, r5, r6, pc}
		return -ENODEV;
    3694:	f06f 0012 	mvn.w	r0, #18
    3698:	e7fa      	b.n	3690 <gpiote_channel_alloc+0x78>
    369a:	bf00      	nop
    369c:	0bad0000 	.word	0x0bad0000
    36a0:	40006000 	.word	0x40006000

000036a4 <gpio_nrfx_init>:

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    36a4:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    36a6:	4b0b      	ldr	r3, [pc, #44]	; (36d4 <gpio_nrfx_init+0x30>)
    36a8:	781b      	ldrb	r3, [r3, #0]
    36aa:	b10b      	cbz	r3, 36b0 <gpio_nrfx_init+0xc>
		irq_enable(DT_IRQN(GPIOTE_NODE));
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    36ac:	2000      	movs	r0, #0
    36ae:	bd08      	pop	{r3, pc}
		gpio_initialized = true;
    36b0:	4b08      	ldr	r3, [pc, #32]	; (36d4 <gpio_nrfx_init+0x30>)
    36b2:	2201      	movs	r2, #1
    36b4:	701a      	strb	r2, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    36b6:	2200      	movs	r2, #0
    36b8:	2105      	movs	r1, #5
    36ba:	2006      	movs	r0, #6
    36bc:	f7ff f828 	bl	2710 <z_arm_irq_priority_set>
		irq_enable(DT_IRQN(GPIOTE_NODE));
    36c0:	2006      	movs	r0, #6
    36c2:	f7ff f807 	bl	26d4 <arch_irq_enable>
    36c6:	4b04      	ldr	r3, [pc, #16]	; (36d8 <gpio_nrfx_init+0x34>)
    36c8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    36cc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    36d0:	e7ec      	b.n	36ac <gpio_nrfx_init+0x8>
    36d2:	bf00      	nop
    36d4:	20000a77 	.word	0x20000a77
    36d8:	40006000 	.word	0x40006000

000036dc <baudrate_set>:
	return dev->data;
}

static inline const struct uarte_nrfx_config *get_dev_config(const struct device *dev)
{
	return dev->config;
    36dc:	6843      	ldr	r3, [r0, #4]

static inline NRF_UARTE_Type *get_uarte_instance(const struct device *dev)
{
	const struct uarte_nrfx_config *config = get_dev_config(dev);

	return config->uarte_regs;
    36de:	681a      	ldr	r2, [r3, #0]
static int baudrate_set(const struct device *dev, uint32_t baudrate)
{
	nrf_uarte_baudrate_t nrf_baudrate; /* calculated baudrate divisor */
	NRF_UARTE_Type *uarte = get_uarte_instance(dev);

	switch (baudrate) {
    36e0:	f5b1 4f16 	cmp.w	r1, #38400	; 0x9600
    36e4:	d06f      	beq.n	37c6 <baudrate_set+0xea>
    36e6:	d83a      	bhi.n	375e <baudrate_set+0x82>
    36e8:	f5b1 5f16 	cmp.w	r1, #9600	; 0x2580
    36ec:	d06e      	beq.n	37cc <baudrate_set+0xf0>
    36ee:	d90a      	bls.n	3706 <baudrate_set+0x2a>
    36f0:	f5b1 4fe1 	cmp.w	r1, #28800	; 0x7080
    36f4:	d075      	beq.n	37e2 <baudrate_set+0x106>
    36f6:	d924      	bls.n	3742 <baudrate_set+0x66>
    36f8:	f647 2312 	movw	r3, #31250	; 0x7a12
    36fc:	4299      	cmp	r1, r3
    36fe:	d12b      	bne.n	3758 <baudrate_set+0x7c>
		break;
	case 28800:
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
		break;
	case 31250:
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    3700:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    3704:	e013      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    3706:	f5b1 6f96 	cmp.w	r1, #1200	; 0x4b0
    370a:	d061      	beq.n	37d0 <baudrate_set+0xf4>
    370c:	d907      	bls.n	371e <baudrate_set+0x42>
    370e:	f5b1 6f16 	cmp.w	r1, #2400	; 0x960
    3712:	d063      	beq.n	37dc <baudrate_set+0x100>
    3714:	f5b1 5f96 	cmp.w	r1, #4800	; 0x12c0
    3718:	d110      	bne.n	373c <baudrate_set+0x60>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    371a:	4b3c      	ldr	r3, [pc, #240]	; (380c <baudrate_set+0x130>)
    371c:	e007      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    371e:	f5b1 7f96 	cmp.w	r1, #300	; 0x12c
    3722:	d058      	beq.n	37d6 <baudrate_set+0xfa>
    3724:	f5b1 7f16 	cmp.w	r1, #600	; 0x258
    3728:	d105      	bne.n	3736 <baudrate_set+0x5a>
		nrf_baudrate = 0x00027000;
    372a:	f44f 331c 	mov.w	r3, #159744	; 0x27000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    372e:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
		return -EINVAL;
	}

	nrf_uarte_baudrate_set(uarte, nrf_baudrate);

	return 0;
    3732:	2000      	movs	r0, #0
    3734:	4770      	bx	lr
	switch (baudrate) {
    3736:	f06f 0015 	mvn.w	r0, #21
    373a:	4770      	bx	lr
    373c:	f06f 0015 	mvn.w	r0, #21
    3740:	4770      	bx	lr
    3742:	f5b1 5f61 	cmp.w	r1, #14400	; 0x3840
    3746:	d04e      	beq.n	37e6 <baudrate_set+0x10a>
    3748:	f5b1 4f96 	cmp.w	r1, #19200	; 0x4b00
    374c:	d101      	bne.n	3752 <baudrate_set+0x76>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    374e:	4b30      	ldr	r3, [pc, #192]	; (3810 <baudrate_set+0x134>)
    3750:	e7ed      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    3752:	f06f 0015 	mvn.w	r0, #21
    3756:	4770      	bx	lr
    3758:	f06f 0015 	mvn.w	r0, #21
    375c:	4770      	bx	lr
    375e:	f5b1 3f61 	cmp.w	r1, #230400	; 0x38400
    3762:	d042      	beq.n	37ea <baudrate_set+0x10e>
    3764:	d909      	bls.n	377a <baudrate_set+0x9e>
    3766:	f5b1 2f61 	cmp.w	r1, #921600	; 0xe1000
    376a:	d046      	beq.n	37fa <baudrate_set+0x11e>
    376c:	d91f      	bls.n	37ae <baudrate_set+0xd2>
    376e:	4b29      	ldr	r3, [pc, #164]	; (3814 <baudrate_set+0x138>)
    3770:	4299      	cmp	r1, r3
    3772:	d148      	bne.n	3806 <baudrate_set+0x12a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    3774:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    3778:	e7d9      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    377a:	f5b1 3f96 	cmp.w	r1, #76800	; 0x12c00
    377e:	d037      	beq.n	37f0 <baudrate_set+0x114>
    3780:	d905      	bls.n	378e <baudrate_set+0xb2>
    3782:	f5b1 3fe1 	cmp.w	r1, #115200	; 0x1c200
    3786:	d10f      	bne.n	37a8 <baudrate_set+0xcc>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    3788:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    378c:	e7cf      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    378e:	f64d 23c0 	movw	r3, #56000	; 0xdac0
    3792:	4299      	cmp	r1, r3
    3794:	d02e      	beq.n	37f4 <baudrate_set+0x118>
    3796:	f5b1 4f61 	cmp.w	r1, #57600	; 0xe100
    379a:	d102      	bne.n	37a2 <baudrate_set+0xc6>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    379c:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    37a0:	e7c5      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    37a2:	f06f 0015 	mvn.w	r0, #21
    37a6:	4770      	bx	lr
    37a8:	f06f 0015 	mvn.w	r0, #21
    37ac:	4770      	bx	lr
    37ae:	4b1a      	ldr	r3, [pc, #104]	; (3818 <baudrate_set+0x13c>)
    37b0:	4299      	cmp	r1, r3
    37b2:	d025      	beq.n	3800 <baudrate_set+0x124>
    37b4:	f5b1 2fe1 	cmp.w	r1, #460800	; 0x70800
    37b8:	d102      	bne.n	37c0 <baudrate_set+0xe4>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    37ba:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    37be:	e7b6      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    37c0:	f06f 0015 	mvn.w	r0, #21
    37c4:	4770      	bx	lr
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    37c6:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    37ca:	e7b0      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    37cc:	4b13      	ldr	r3, [pc, #76]	; (381c <baudrate_set+0x140>)
    37ce:	e7ae      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    37d0:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    37d4:	e7ab      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    37d6:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    37da:	e7a8      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    37dc:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    37e0:	e7a5      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    37e2:	4b0f      	ldr	r3, [pc, #60]	; (3820 <baudrate_set+0x144>)
    37e4:	e7a3      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    37e6:	4b0f      	ldr	r3, [pc, #60]	; (3824 <baudrate_set+0x148>)
    37e8:	e7a1      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    37ea:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    37ee:	e79e      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    37f0:	4b0d      	ldr	r3, [pc, #52]	; (3828 <baudrate_set+0x14c>)
    37f2:	e79c      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    37f4:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    37f8:	e799      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    37fa:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    37fe:	e796      	b.n	372e <baudrate_set+0x52>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    3800:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    3804:	e793      	b.n	372e <baudrate_set+0x52>
	switch (baudrate) {
    3806:	f06f 0015 	mvn.w	r0, #21
}
    380a:	4770      	bx	lr
    380c:	0013b000 	.word	0x0013b000
    3810:	004ea000 	.word	0x004ea000
    3814:	000f4240 	.word	0x000f4240
    3818:	0003d090 	.word	0x0003d090
    381c:	00275000 	.word	0x00275000
    3820:	0075c000 	.word	0x0075c000
    3824:	003af000 	.word	0x003af000
    3828:	013a9000 	.word	0x013a9000

0000382c <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
    382c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3830:	4605      	mov	r5, r0
    3832:	460f      	mov	r7, r1
	return dev->data;
    3834:	f8d0 8010 	ldr.w	r8, [r0, #16]
	struct uarte_nrfx_data *data = get_dev_data(dev);
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    3838:	f003 fd26 	bl	7288 <k_is_in_isr>
    383c:	b920      	cbnz	r0, 3848 <uarte_nrfx_poll_out+0x1c>
	return !z_sys_post_kernel;
    383e:	4b16      	ldr	r3, [pc, #88]	; (3898 <uarte_nrfx_poll_out+0x6c>)
    3840:	781b      	ldrb	r3, [r3, #0]
    3842:	b1ab      	cbz	r3, 3870 <uarte_nrfx_poll_out+0x44>
    3844:	2300      	movs	r3, #0
    3846:	e000      	b.n	384a <uarte_nrfx_poll_out+0x1e>
    3848:	2301      	movs	r3, #1
	int key;

	if (isr_mode) {
    384a:	b19b      	cbz	r3, 3874 <uarte_nrfx_poll_out+0x48>
	__asm__ volatile(
    384c:	f04f 0320 	mov.w	r3, #32
    3850:	f3ef 8411 	mrs	r4, BASEPRI
    3854:	f383 8811 	msr	BASEPRI, r3
    3858:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
    385c:	4626      	mov	r6, r4
			if (is_tx_ready(dev)) {
    385e:	4628      	mov	r0, r5
    3860:	f003 fb70 	bl	6f44 <is_tx_ready>
    3864:	b950      	cbnz	r0, 387c <uarte_nrfx_poll_out+0x50>
	__asm__ volatile(
    3866:	f384 8811 	msr	BASEPRI, r4
    386a:	f3bf 8f6f 	isb	sy
}
    386e:	e7ed      	b.n	384c <uarte_nrfx_poll_out+0x20>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    3870:	2301      	movs	r3, #1
    3872:	e7ea      	b.n	384a <uarte_nrfx_poll_out+0x1e>
			}

			irq_unlock(key);
		}
	} else {
		key = wait_tx_ready(dev);
    3874:	4628      	mov	r0, r5
    3876:	f003 fbb4 	bl	6fe2 <wait_tx_ready>
    387a:	4606      	mov	r6, r0
	}

	data->char_out = c;
    387c:	4641      	mov	r1, r8
    387e:	f801 7f10 	strb.w	r7, [r1, #16]!
	tx_start(dev, &data->char_out, 1);
    3882:	2201      	movs	r2, #1
    3884:	4628      	mov	r0, r5
    3886:	f003 fb77 	bl	6f78 <tx_start>
	__asm__ volatile(
    388a:	f386 8811 	msr	BASEPRI, r6
    388e:	f3bf 8f6f 	isb	sy

	irq_unlock(key);
}
    3892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3896:	bf00      	nop
    3898:	20000a78 	.word	0x20000a78

0000389c <endtx_stoptx_ppi_init>:
#endif /* UARTE_INTERRUPT_DRIVEN */
};

static int endtx_stoptx_ppi_init(NRF_UARTE_Type *uarte,
				 struct uarte_nrfx_data *data)
{
    389c:	b538      	push	{r3, r4, r5, lr}
    389e:	4604      	mov	r4, r0
    38a0:	460d      	mov	r5, r1
	nrfx_err_t ret;

	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    38a2:	f101 0012 	add.w	r0, r1, #18
    38a6:	f000 fc4b 	bl	4140 <nrfx_ppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
    38aa:	4b14      	ldr	r3, [pc, #80]	; (38fc <endtx_stoptx_ppi_init+0x60>)
    38ac:	4298      	cmp	r0, r3
    38ae:	d111      	bne.n	38d4 <endtx_stoptx_ppi_init+0x38>
		LOG_ERR("Failed to allocate PPI Channel");
		return -EIO;
	}

	nrfx_gppi_channel_endpoints_setup(data->ppi_ch_endtx,
    38b0:	7cab      	ldrb	r3, [r5, #18]
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)event);
    38b2:	f504 7190 	add.w	r1, r4, #288	; 0x120
    return (uint32_t)p_reg + (uint32_t)task;
    38b6:	340c      	adds	r4, #12
NRF_STATIC_INLINE void nrf_ppi_channel_endpoint_setup(NRF_PPI_Type *    p_reg,
                                                      nrf_ppi_channel_t channel,
                                                      uint32_t          eep,
                                                      uint32_t          tep)
{
    p_reg->CH[(uint32_t) channel].EEP = eep;
    38b8:	4a11      	ldr	r2, [pc, #68]	; (3900 <endtx_stoptx_ppi_init+0x64>)
    38ba:	33a2      	adds	r3, #162	; 0xa2
    38bc:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
    p_reg->CH[(uint32_t) channel].TEP = tep;
    38c0:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    38c4:	605c      	str	r4, [r3, #4]
		nrf_uarte_event_address_get(uarte, NRF_UARTE_EVENT_ENDTX),
		nrf_uarte_task_address_get(uarte, NRF_UARTE_TASK_STOPTX));
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    38c6:	7ca9      	ldrb	r1, [r5, #18]
    38c8:	2301      	movs	r3, #1
    38ca:	408b      	lsls	r3, r1
    p_reg->CHENSET = mask;
    38cc:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504

	return 0;
    38d0:	2000      	movs	r0, #0
}
    38d2:	bd38      	pop	{r3, r4, r5, pc}
    38d4:	4b0b      	ldr	r3, [pc, #44]	; (3904 <endtx_stoptx_ppi_init+0x68>)
    38d6:	4a0c      	ldr	r2, [pc, #48]	; (3908 <endtx_stoptx_ppi_init+0x6c>)
    38d8:	1a9b      	subs	r3, r3, r2
    38da:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Failed to allocate PPI Channel");
    38dc:	f04f 0100 	mov.w	r1, #0
    38e0:	2201      	movs	r2, #1
    38e2:	f362 0102 	bfi	r1, r2, #0, #3
    38e6:	f36f 01c5 	bfc	r1, #3, #3
    38ea:	f363 118f 	bfi	r1, r3, #6, #10
    38ee:	4807      	ldr	r0, [pc, #28]	; (390c <endtx_stoptx_ppi_init+0x70>)
    38f0:	f7fd ff3c 	bl	176c <log_0>
		return -EIO;
    38f4:	f06f 0004 	mvn.w	r0, #4
    38f8:	e7eb      	b.n	38d2 <endtx_stoptx_ppi_init+0x36>
    38fa:	bf00      	nop
    38fc:	0bad0000 	.word	0x0bad0000
    3900:	4001f000 	.word	0x4001f000
    3904:	000079fc 	.word	0x000079fc
    3908:	000079c4 	.word	0x000079c4
    390c:	00008238 	.word	0x00008238

00003910 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
    3910:	b530      	push	{r4, r5, lr}
    3912:	b085      	sub	sp, #20
    3914:	4605      	mov	r5, r0
    3916:	4b0a      	ldr	r3, [pc, #40]	; (3940 <uarte_0_init+0x30>)
    3918:	466c      	mov	r4, sp
    391a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    391c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    3920:	2200      	movs	r2, #0
    3922:	2101      	movs	r1, #1
    3924:	2002      	movs	r0, #2
    3926:	f7fe fef3 	bl	2710 <z_arm_irq_priority_set>
    392a:	2002      	movs	r0, #2
    392c:	f7fe fed2 	bl	26d4 <arch_irq_enable>
    3930:	2200      	movs	r2, #0
    3932:	4621      	mov	r1, r4
    3934:	4628      	mov	r0, r5
    3936:	f003 fb7b 	bl	7030 <uarte_instance_init>
    393a:	b005      	add	sp, #20
    393c:	bd30      	pop	{r4, r5, pc}
    393e:	bf00      	nop
    3940:	00007a90 	.word	0x00007a90

00003944 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
    3944:	b508      	push	{r3, lr}
	z_impl_log_panic();
    3946:	f7fd ff71 	bl	182c <z_impl_log_panic>
    394a:	4b09      	ldr	r3, [pc, #36]	; (3970 <k_sys_fatal_error_handler+0x2c>)
    394c:	4a09      	ldr	r2, [pc, #36]	; (3974 <k_sys_fatal_error_handler+0x30>)
    394e:	1a9b      	subs	r3, r3, r2
    3950:	08db      	lsrs	r3, r3, #3
	defined(CONFIG_SPM_SERVICE_NS_HANDLER_FROM_SPM_FAULT)
	z_spm_ns_fatal_error_handler();
#endif

	if (IS_ENABLED(CONFIG_RESET_ON_FATAL_ERROR)) {
		LOG_ERR("Resetting system");
    3952:	f04f 0100 	mov.w	r1, #0
    3956:	2201      	movs	r2, #1
    3958:	f362 0102 	bfi	r1, r2, #0, #3
    395c:	f36f 01c5 	bfc	r1, #3, #3
    3960:	f363 118f 	bfi	r1, r3, #6, #10
    3964:	4804      	ldr	r0, [pc, #16]	; (3978 <k_sys_fatal_error_handler+0x34>)
    3966:	f7fd ff01 	bl	176c <log_0>
		sys_arch_reboot(0);
    396a:	2000      	movs	r0, #0
    396c:	f7ff fd2e 	bl	33cc <sys_arch_reboot>
		for (;;) {
			/* Spin endlessly */
		}
	}

	CODE_UNREACHABLE;
    3970:	000079cc 	.word	0x000079cc
    3974:	000079c4 	.word	0x000079c4
    3978:	00008284 	.word	0x00008284

0000397c <nrf52_errata_12>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    397c:	4b06      	ldr	r3, [pc, #24]	; (3998 <nrf52_errata_12+0x1c>)
    397e:	681b      	ldr	r3, [r3, #0]
    3980:	f1b3 3fff 	cmp.w	r3, #4294967295
    3984:	d003      	beq.n	398e <nrf52_errata_12+0x12>
                var2 = *(uint32_t *)0x10000134ul;
            }
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3986:	2b06      	cmp	r3, #6
    3988:	d004      	beq.n	3994 <nrf52_errata_12+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    398a:	2000      	movs	r0, #0
    398c:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    398e:	4b03      	ldr	r3, [pc, #12]	; (399c <nrf52_errata_12+0x20>)
    3990:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3992:	e7f8      	b.n	3986 <nrf52_errata_12+0xa>
                        return true;
    3994:	2001      	movs	r0, #1
    #endif
}
    3996:	4770      	bx	lr
    3998:	10000130 	.word	0x10000130
    399c:	f0000fe0 	.word	0xf0000fe0

000039a0 <nrf52_errata_16>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    39a0:	4b09      	ldr	r3, [pc, #36]	; (39c8 <nrf52_errata_16+0x28>)
    39a2:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    39a4:	3308      	adds	r3, #8
    39a6:	681b      	ldr	r3, [r3, #0]
    39a8:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    39ac:	2a06      	cmp	r2, #6
    39ae:	d001      	beq.n	39b4 <nrf52_errata_16+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    39b0:	2000      	movs	r0, #0
    39b2:	4770      	bx	lr
                switch(var2)
    39b4:	3b03      	subs	r3, #3
    39b6:	2b00      	cmp	r3, #0
    39b8:	d804      	bhi.n	39c4 <nrf52_errata_16+0x24>
    39ba:	e8df f003 	tbb	[pc, r3]
    39be:	01          	.byte	0x01
    39bf:	00          	.byte	0x00
            if (var1 == 0x06)
    39c0:	2001      	movs	r0, #1
    39c2:	4770      	bx	lr
                        return false;
    39c4:	2000      	movs	r0, #0
    #endif
}
    39c6:	4770      	bx	lr
    39c8:	f0000fe0 	.word	0xf0000fe0

000039cc <nrf52_errata_31>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    39cc:	4b06      	ldr	r3, [pc, #24]	; (39e8 <nrf52_errata_31+0x1c>)
    39ce:	681b      	ldr	r3, [r3, #0]
    39d0:	f1b3 3fff 	cmp.w	r3, #4294967295
    39d4:	d003      	beq.n	39de <nrf52_errata_31+0x12>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    39d6:	2b06      	cmp	r3, #6
    39d8:	d004      	beq.n	39e4 <nrf52_errata_31+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    39da:	2000      	movs	r0, #0
    39dc:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    39de:	4b03      	ldr	r3, [pc, #12]	; (39ec <nrf52_errata_31+0x20>)
    39e0:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    39e2:	e7f8      	b.n	39d6 <nrf52_errata_31+0xa>
                        return true;
    39e4:	2001      	movs	r0, #1
    #endif
}
    39e6:	4770      	bx	lr
    39e8:	10000130 	.word	0x10000130
    39ec:	f0000fe0 	.word	0xf0000fe0

000039f0 <nrf52_errata_32>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    39f0:	4b09      	ldr	r3, [pc, #36]	; (3a18 <nrf52_errata_32+0x28>)
    39f2:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    39f4:	3308      	adds	r3, #8
    39f6:	681b      	ldr	r3, [r3, #0]
    39f8:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    39fc:	2a06      	cmp	r2, #6
    39fe:	d001      	beq.n	3a04 <nrf52_errata_32+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    3a00:	2000      	movs	r0, #0
    3a02:	4770      	bx	lr
                switch(var2)
    3a04:	3b03      	subs	r3, #3
    3a06:	2b00      	cmp	r3, #0
    3a08:	d804      	bhi.n	3a14 <nrf52_errata_32+0x24>
    3a0a:	e8df f003 	tbb	[pc, r3]
    3a0e:	01          	.byte	0x01
    3a0f:	00          	.byte	0x00
            if (var1 == 0x06)
    3a10:	2001      	movs	r0, #1
    3a12:	4770      	bx	lr
                        return false;
    3a14:	2000      	movs	r0, #0
    #endif
}
    3a16:	4770      	bx	lr
    3a18:	f0000fe0 	.word	0xf0000fe0

00003a1c <nrf52_errata_36>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    3a1c:	4b06      	ldr	r3, [pc, #24]	; (3a38 <nrf52_errata_36+0x1c>)
    3a1e:	681b      	ldr	r3, [r3, #0]
    3a20:	f1b3 3fff 	cmp.w	r3, #4294967295
    3a24:	d003      	beq.n	3a2e <nrf52_errata_36+0x12>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3a26:	2b06      	cmp	r3, #6
    3a28:	d004      	beq.n	3a34 <nrf52_errata_36+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    3a2a:	2000      	movs	r0, #0
    3a2c:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    3a2e:	4b03      	ldr	r3, [pc, #12]	; (3a3c <nrf52_errata_36+0x20>)
    3a30:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3a32:	e7f8      	b.n	3a26 <nrf52_errata_36+0xa>
                        return true;
    3a34:	2001      	movs	r0, #1
    #endif
}
    3a36:	4770      	bx	lr
    3a38:	10000130 	.word	0x10000130
    3a3c:	f0000fe0 	.word	0xf0000fe0

00003a40 <nrf52_errata_37>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    3a40:	4b09      	ldr	r3, [pc, #36]	; (3a68 <nrf52_errata_37+0x28>)
    3a42:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3a44:	3308      	adds	r3, #8
    3a46:	681b      	ldr	r3, [r3, #0]
    3a48:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3a4c:	2a06      	cmp	r2, #6
    3a4e:	d001      	beq.n	3a54 <nrf52_errata_37+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    3a50:	2000      	movs	r0, #0
    3a52:	4770      	bx	lr
                switch(var2)
    3a54:	3b03      	subs	r3, #3
    3a56:	2b00      	cmp	r3, #0
    3a58:	d804      	bhi.n	3a64 <nrf52_errata_37+0x24>
    3a5a:	e8df f003 	tbb	[pc, r3]
    3a5e:	01          	.byte	0x01
    3a5f:	00          	.byte	0x00
            if (var1 == 0x06)
    3a60:	2001      	movs	r0, #1
    3a62:	4770      	bx	lr
                        return false;
    3a64:	2000      	movs	r0, #0
    #endif
}
    3a66:	4770      	bx	lr
    3a68:	f0000fe0 	.word	0xf0000fe0

00003a6c <nrf52_errata_57>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    3a6c:	4b09      	ldr	r3, [pc, #36]	; (3a94 <nrf52_errata_57+0x28>)
    3a6e:	781a      	ldrb	r2, [r3, #0]
            uint32_t var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3a70:	3308      	adds	r3, #8
    3a72:	681b      	ldr	r3, [r3, #0]
    3a74:	f3c3 1303 	ubfx	r3, r3, #4, #4
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3a78:	2a06      	cmp	r2, #6
    3a7a:	d001      	beq.n	3a80 <nrf52_errata_57+0x14>
                    default:
                        return false;
                }
            }
        #endif
        return false;
    3a7c:	2000      	movs	r0, #0
    3a7e:	4770      	bx	lr
                switch(var2)
    3a80:	3b03      	subs	r3, #3
    3a82:	2b00      	cmp	r3, #0
    3a84:	d804      	bhi.n	3a90 <nrf52_errata_57+0x24>
    3a86:	e8df f003 	tbb	[pc, r3]
    3a8a:	01          	.byte	0x01
    3a8b:	00          	.byte	0x00
            if (var1 == 0x06)
    3a8c:	2001      	movs	r0, #1
    3a8e:	4770      	bx	lr
                        return false;
    3a90:	2000      	movs	r0, #0
    #endif
}
    3a92:	4770      	bx	lr
    3a94:	f0000fe0 	.word	0xf0000fe0

00003a98 <nrf52_errata_66>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    3a98:	4b0d      	ldr	r3, [pc, #52]	; (3ad0 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x38>)
    3a9a:	681a      	ldr	r2, [r3, #0]
    3a9c:	f1b2 3fff 	cmp.w	r2, #4294967295
    3aa0:	d005      	beq.n	3aae <nrf52_errata_66+0x16>
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
            }
            else
            {
                var1 = *(uint32_t *)0x10000130ul;
                var2 = *(uint32_t *)0x10000134ul;
    3aa2:	4b0c      	ldr	r3, [pc, #48]	; (3ad4 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x3c>)
    3aa4:	681b      	ldr	r3, [r3, #0]
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3aa6:	2a06      	cmp	r2, #6
    3aa8:	d008      	beq.n	3abc <nrf52_errata_66+0x24>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    3aaa:	2000      	movs	r0, #0
    3aac:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    3aae:	4b0a      	ldr	r3, [pc, #40]	; (3ad8 <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x40>)
    3ab0:	781a      	ldrb	r2, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3ab2:	3308      	adds	r3, #8
    3ab4:	681b      	ldr	r3, [r3, #0]
    3ab6:	f3c3 1303 	ubfx	r3, r3, #4, #4
    3aba:	e7f4      	b.n	3aa6 <nrf52_errata_66+0xe>
                switch(var2)
    3abc:	3b03      	subs	r3, #3
    3abe:	2b01      	cmp	r3, #1
    3ac0:	d804      	bhi.n	3acc <CONFIG_UART_CONSOLE_INPUT_EXPIRED_TIMEOUT+0x34>
    3ac2:	e8df f003 	tbb	[pc, r3]
    3ac6:	0101      	.short	0x0101
            if (var1 == 0x06)
    3ac8:	2000      	movs	r0, #0
    3aca:	4770      	bx	lr
                        return true;
    3acc:	2001      	movs	r0, #1
    #endif
}
    3ace:	4770      	bx	lr
    3ad0:	10000130 	.word	0x10000130
    3ad4:	10000134 	.word	0x10000134
    3ad8:	f0000fe0 	.word	0xf0000fe0

00003adc <nrf52_errata_108>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    3adc:	4b06      	ldr	r3, [pc, #24]	; (3af8 <nrf52_errata_108+0x1c>)
    3ade:	681b      	ldr	r3, [r3, #0]
    3ae0:	f1b3 3fff 	cmp.w	r3, #4294967295
    3ae4:	d003      	beq.n	3aee <nrf52_errata_108+0x12>
                var2 = *(uint32_t *)0x10000134ul;
            }
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3ae6:	2b06      	cmp	r3, #6
    3ae8:	d004      	beq.n	3af4 <nrf52_errata_108+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    3aea:	2000      	movs	r0, #0
    3aec:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    3aee:	4b03      	ldr	r3, [pc, #12]	; (3afc <nrf52_errata_108+0x20>)
    3af0:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3af2:	e7f8      	b.n	3ae6 <nrf52_errata_108+0xa>
                        return true;
    3af4:	2001      	movs	r0, #1
    #endif
}
    3af6:	4770      	bx	lr
    3af8:	10000130 	.word	0x10000130
    3afc:	f0000fe0 	.word	0xf0000fe0

00003b00 <nrf52_errata_136>:
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1;
            uint32_t var2;

            if (*(uint32_t *)0x10000130ul == 0xFFFFFFFF)
    3b00:	4b06      	ldr	r3, [pc, #24]	; (3b1c <nrf52_errata_136+0x1c>)
    3b02:	681b      	ldr	r3, [r3, #0]
    3b04:	f1b3 3fff 	cmp.w	r3, #4294967295
    3b08:	d003      	beq.n	3b12 <nrf52_errata_136+0x12>
            uint32_t var1 = *(uint32_t *)0x10000130ul;
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3b0a:	2b06      	cmp	r3, #6
    3b0c:	d004      	beq.n	3b18 <nrf52_errata_136+0x18>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    3b0e:	2000      	movs	r0, #0
    3b10:	4770      	bx	lr
                var1 = ((*(uint32_t *)0xF0000FE0ul) & 0x000000FFul);
    3b12:	4b03      	ldr	r3, [pc, #12]	; (3b20 <nrf52_errata_136+0x20>)
    3b14:	781b      	ldrb	r3, [r3, #0]
                var2 = ((*(uint32_t *)0xF0000FE8ul) & 0x000000F0ul) >> 4;
    3b16:	e7f8      	b.n	3b0a <nrf52_errata_136+0xa>
                        return true;
    3b18:	2001      	movs	r0, #1
    #endif
}
    3b1a:	4770      	bx	lr
    3b1c:	10000130 	.word	0x10000130
    3b20:	f0000fe0 	.word	0xf0000fe0

00003b24 <nrf52_errata_182>:
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    3b24:	4b08      	ldr	r3, [pc, #32]	; (3b48 <nrf52_errata_182+0x24>)
    3b26:	681b      	ldr	r3, [r3, #0]
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    3b28:	4a08      	ldr	r2, [pc, #32]	; (3b4c <nrf52_errata_182+0x28>)
    3b2a:	6812      	ldr	r2, [r2, #0]
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3b2c:	2b06      	cmp	r3, #6
    3b2e:	d001      	beq.n	3b34 <nrf52_errata_182+0x10>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    3b30:	2000      	movs	r0, #0
    3b32:	4770      	bx	lr
                switch(var2)
    3b34:	2a05      	cmp	r2, #5
    3b36:	d803      	bhi.n	3b40 <nrf52_errata_182+0x1c>
    3b38:	2a03      	cmp	r2, #3
    3b3a:	d303      	bcc.n	3b44 <nrf52_errata_182+0x20>
    3b3c:	2000      	movs	r0, #0
    3b3e:	4770      	bx	lr
                        return true;
    3b40:	2001      	movs	r0, #1
    3b42:	4770      	bx	lr
                        return true;
    3b44:	2001      	movs	r0, #1
    #endif
}
    3b46:	4770      	bx	lr
    3b48:	10000130 	.word	0x10000130
    3b4c:	10000134 	.word	0x10000134

00003b50 <nrf52_errata_249>:
        #if defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    3b50:	4b08      	ldr	r3, [pc, #32]	; (3b74 <nrf52_errata_249+0x24>)
    3b52:	681b      	ldr	r3, [r3, #0]
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    3b54:	4a08      	ldr	r2, [pc, #32]	; (3b78 <nrf52_errata_249+0x28>)
    3b56:	6812      	ldr	r2, [r2, #0]
        #endif
        #if defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)
            if (var1 == 0x06)
    3b58:	2b06      	cmp	r3, #6
    3b5a:	d001      	beq.n	3b60 <nrf52_errata_249+0x10>
                    default:
                        return true;
                }
            }
        #endif
        return false;
    3b5c:	2000      	movs	r0, #0
    3b5e:	4770      	bx	lr
                switch(var2)
    3b60:	2a06      	cmp	r2, #6
    3b62:	d803      	bhi.n	3b6c <nrf52_errata_249+0x1c>
    3b64:	2a03      	cmp	r2, #3
    3b66:	d303      	bcc.n	3b70 <nrf52_errata_249+0x20>
    3b68:	2000      	movs	r0, #0
    3b6a:	4770      	bx	lr
                        return true;
    3b6c:	2001      	movs	r0, #1
    3b6e:	4770      	bx	lr
                        return true;
    3b70:	2001      	movs	r0, #1
    #endif
}
    3b72:	4770      	bx	lr
    3b74:	10000130 	.word	0x10000130
    3b78:	10000134 	.word	0x10000134

00003b7c <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    3b7c:	4b02      	ldr	r3, [pc, #8]	; (3b88 <nvmc_wait+0xc>)
    3b7e:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    3b82:	2b00      	cmp	r3, #0
    3b84:	d0fa      	beq.n	3b7c <nvmc_wait>
}
    3b86:	4770      	bx	lr
    3b88:	4001e000 	.word	0x4001e000

00003b8c <nvmc_config>:

/*  Configure the NVMC to "mode".
    Mode must be an enumerator of field NVMC_CONFIG_WEN */
void nvmc_config(uint32_t mode)
{
    3b8c:	b508      	push	{r3, lr}
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    3b8e:	4b03      	ldr	r3, [pc, #12]	; (3b9c <nvmc_config+0x10>)
    3b90:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
    nvmc_wait();
    3b94:	f7ff fff2 	bl	3b7c <nvmc_wait>
}
    3b98:	bd08      	pop	{r3, pc}
    3b9a:	bf00      	nop
    3b9c:	4001e000 	.word	0x4001e000

00003ba0 <SystemCoreClockUpdate>:

void SystemCoreClockUpdate(void)
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    3ba0:	4b01      	ldr	r3, [pc, #4]	; (3ba8 <SystemCoreClockUpdate+0x8>)
    3ba2:	4a02      	ldr	r2, [pc, #8]	; (3bac <SystemCoreClockUpdate+0xc>)
    3ba4:	601a      	str	r2, [r3, #0]
}
    3ba6:	4770      	bx	lr
    3ba8:	20000024 	.word	0x20000024
    3bac:	03d09000 	.word	0x03d09000

00003bb0 <SystemInit>:

void SystemInit(void)
{
    3bb0:	b538      	push	{r3, r4, r5, lr}
    #endif

    #if NRF52_ERRATA_12_ENABLE_WORKAROUND
        /* Workaround for Errata 12 "COMP: Reference ladder not correctly calibrated" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_12()){
    3bb2:	f7ff fee3 	bl	397c <nrf52_errata_12>
    3bb6:	b128      	cbz	r0, 3bc4 <SystemInit+0x14>
            *(volatile uint32_t *)0x40013540 = (*(uint32_t *)0x10000324 & 0x00001F00) >> 8;
    3bb8:	4b70      	ldr	r3, [pc, #448]	; (3d7c <SystemInit+0x1cc>)
    3bba:	681b      	ldr	r3, [r3, #0]
    3bbc:	f3c3 2304 	ubfx	r3, r3, #8, #5
    3bc0:	4a6f      	ldr	r2, [pc, #444]	; (3d80 <SystemInit+0x1d0>)
    3bc2:	6013      	str	r3, [r2, #0]
    #endif

    #if NRF52_ERRATA_16_ENABLE_WORKAROUND
        /* Workaround for Errata 16 "System: RAM may be corrupt on wakeup from CPU IDLE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_16()){
    3bc4:	f7ff feec 	bl	39a0 <nrf52_errata_16>
    3bc8:	b110      	cbz	r0, 3bd0 <SystemInit+0x20>
            *(volatile uint32_t *)0x4007C074 = 3131961357ul;
    3bca:	4b6e      	ldr	r3, [pc, #440]	; (3d84 <SystemInit+0x1d4>)
    3bcc:	4a6e      	ldr	r2, [pc, #440]	; (3d88 <SystemInit+0x1d8>)
    3bce:	601a      	str	r2, [r3, #0]
    #endif

    #if NRF52_ERRATA_31_ENABLE_WORKAROUND
        /* Workaround for Errata 31 "CLOCK: Calibration values are not correctly loaded from FICR at reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_31()){
    3bd0:	f7ff fefc 	bl	39cc <nrf52_errata_31>
    3bd4:	b128      	cbz	r0, 3be2 <SystemInit+0x32>
            *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
    3bd6:	4b6d      	ldr	r3, [pc, #436]	; (3d8c <SystemInit+0x1dc>)
    3bd8:	681b      	ldr	r3, [r3, #0]
    3bda:	f3c3 3342 	ubfx	r3, r3, #13, #3
    3bde:	4a6c      	ldr	r2, [pc, #432]	; (3d90 <SystemInit+0x1e0>)
    3be0:	6013      	str	r3, [r2, #0]
    #endif

    #if NRF52_ERRATA_32_ENABLE_WORKAROUND
        /* Workaround for Errata 32 "DIF: Debug session automatically enables TracePort pins" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp */
        if (nrf52_errata_32()){
    3be2:	f7ff ff05 	bl	39f0 <nrf52_errata_32>
    3be6:	b120      	cbz	r0, 3bf2 <SystemInit+0x42>
            CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
    3be8:	4a6a      	ldr	r2, [pc, #424]	; (3d94 <SystemInit+0x1e4>)
    3bea:	68d3      	ldr	r3, [r2, #12]
    3bec:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
    3bf0:	60d3      	str	r3, [r2, #12]
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
    3bf2:	f7ff ff13 	bl	3a1c <nrf52_errata_36>
    3bf6:	b140      	cbz	r0, 3c0a <SystemInit+0x5a>
            NRF_CLOCK->EVENTS_DONE = 0;
    3bf8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3bfc:	2200      	movs	r2, #0
    3bfe:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
    3c02:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
    3c06:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_37_ENABLE_WORKAROUND
        /* Workaround for Errata 37 "RADIO: Encryption engine is slow by default" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_37()){
    3c0a:	f7ff ff19 	bl	3a40 <nrf52_errata_37>
    3c0e:	b110      	cbz	r0, 3c16 <SystemInit+0x66>
            *(volatile uint32_t *)0x400005A0 = 0x3;
    3c10:	4b61      	ldr	r3, [pc, #388]	; (3d98 <SystemInit+0x1e8>)
    3c12:	2203      	movs	r2, #3
    3c14:	601a      	str	r2, [r3, #0]
    #endif

    #if NRF52_ERRATA_57_ENABLE_WORKAROUND
        /* Workaround for Errata 57 "NFCT: NFC Modulation amplitude" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_57()){
    3c16:	f7ff ff29 	bl	3a6c <nrf52_errata_57>
    3c1a:	b158      	cbz	r0, 3c34 <SystemInit+0x84>
            *(volatile uint32_t *)0x40005610 = 0x00000005;
    3c1c:	4b5f      	ldr	r3, [pc, #380]	; (3d9c <SystemInit+0x1ec>)
    3c1e:	2205      	movs	r2, #5
    3c20:	601a      	str	r2, [r3, #0]
            *(volatile uint32_t *)0x40005688 = 0x00000001;
    3c22:	3378      	adds	r3, #120	; 0x78
    3c24:	2201      	movs	r2, #1
    3c26:	601a      	str	r2, [r3, #0]
            *(volatile uint32_t *)0x40005618 = 0x00000000;
    3c28:	3b70      	subs	r3, #112	; 0x70
    3c2a:	2200      	movs	r2, #0
    3c2c:	601a      	str	r2, [r3, #0]
            *(volatile uint32_t *)0x40005614 = 0x0000003F;
    3c2e:	3b04      	subs	r3, #4
    3c30:	223f      	movs	r2, #63	; 0x3f
    3c32:	601a      	str	r2, [r3, #0]
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
    3c34:	f7ff ff30 	bl	3a98 <nrf52_errata_66>
    3c38:	2800      	cmp	r0, #0
    3c3a:	d046      	beq.n	3cca <SystemInit+0x11a>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    3c3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    3c40:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    3c44:	4b56      	ldr	r3, [pc, #344]	; (3da0 <SystemInit+0x1f0>)
    3c46:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    3c4a:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    3c4e:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    3c52:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    3c56:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    3c5a:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    3c5e:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    3c62:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    3c66:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    3c6a:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    3c6e:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    3c72:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    3c76:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    3c7a:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    3c7e:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    3c82:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    3c86:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    3c8a:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    3c8e:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    3c92:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    3c96:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    3c9a:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    3c9e:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    3ca2:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    3ca6:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    3caa:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    3cae:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    3cb2:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    3cb6:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    3cba:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    3cbe:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    3cc2:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    3cc6:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_108_ENABLE_WORKAROUND
        /* Workaround for Errata 108 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_108()){
    3cca:	f7ff ff07 	bl	3adc <nrf52_errata_108>
    3cce:	b128      	cbz	r0, 3cdc <SystemInit+0x12c>
            *(volatile uint32_t *)0x40000EE4ul = *(volatile uint32_t *)0x10000258ul & 0x0000004Ful;
    3cd0:	4b34      	ldr	r3, [pc, #208]	; (3da4 <SystemInit+0x1f4>)
    3cd2:	681b      	ldr	r3, [r3, #0]
    3cd4:	f003 034f 	and.w	r3, r3, #79	; 0x4f
    3cd8:	4a33      	ldr	r2, [pc, #204]	; (3da8 <SystemInit+0x1f8>)
    3cda:	6013      	str	r3, [r2, #0]
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
    3cdc:	f7ff ff10 	bl	3b00 <nrf52_errata_136>
    3ce0:	b160      	cbz	r0, 3cfc <SystemInit+0x14c>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    3ce2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3ce6:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
    3cea:	f013 0f01 	tst.w	r3, #1
    3cee:	d005      	beq.n	3cfc <SystemInit+0x14c>
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    3cf0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3cf4:	f06f 0201 	mvn.w	r2, #1
    3cf8:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    #endif

    #if NRF52_ERRATA_182_ENABLE_WORKAROUND
        /* Workaround for Errata 182 "RADIO: Fixes for anomalies #102, #106, and #107 do not take effect" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_182()){
    3cfc:	f7ff ff12 	bl	3b24 <nrf52_errata_182>
    3d00:	b120      	cbz	r0, 3d0c <SystemInit+0x15c>
            *(volatile uint32_t *) 0x4000173C |= (0x1 << 10);
    3d02:	4a2a      	ldr	r2, [pc, #168]	; (3dac <SystemInit+0x1fc>)
    3d04:	6813      	ldr	r3, [r2, #0]
    3d06:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    3d0a:	6013      	str	r3, [r2, #0]
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_errata_249())
    3d0c:	f7ff ff20 	bl	3b50 <nrf52_errata_249>
    3d10:	b138      	cbz	r0, 3d22 <SystemInit+0x172>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
    3d12:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    3d16:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    3d1a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3d1e:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    3d22:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    3d26:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d2a:	2b00      	cmp	r3, #0
    3d2c:	db08      	blt.n	3d40 <SystemInit+0x190>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    3d2e:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    3d32:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    3d36:	2b00      	cmp	r3, #0
    3d38:	db02      	blt.n	3d40 <SystemInit+0x190>
            nvmc_config(NVMC_CONFIG_WEN_Ren);
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
    3d3a:	f7ff ff31 	bl	3ba0 <SystemCoreClockUpdate>
}
    3d3e:	bd38      	pop	{r3, r4, r5, pc}
            nvmc_config(NVMC_CONFIG_WEN_Wen);
    3d40:	2001      	movs	r0, #1
    3d42:	f7ff ff23 	bl	3b8c <nvmc_config>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    3d46:	f04f 2410 	mov.w	r4, #268439552	; 0x10001000
    3d4a:	2515      	movs	r5, #21
    3d4c:	f8c4 5200 	str.w	r5, [r4, #512]	; 0x200
            nvmc_wait();
    3d50:	f7ff ff14 	bl	3b7c <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
    3d54:	f8c4 5204 	str.w	r5, [r4, #516]	; 0x204
            nvmc_wait();
    3d58:	f7ff ff10 	bl	3b7c <nvmc_wait>
            nvmc_config(NVMC_CONFIG_WEN_Ren);
    3d5c:	2000      	movs	r0, #0
    3d5e:	f7ff ff15 	bl	3b8c <nvmc_config>
    3d62:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    3d66:	4912      	ldr	r1, [pc, #72]	; (3db0 <SystemInit+0x200>)
    3d68:	68ca      	ldr	r2, [r1, #12]
    3d6a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    3d6e:	4b11      	ldr	r3, [pc, #68]	; (3db4 <SystemInit+0x204>)
    3d70:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    3d72:	60cb      	str	r3, [r1, #12]
    3d74:	f3bf 8f4f 	dsb	sy
    __NOP();
    3d78:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    3d7a:	e7fd      	b.n	3d78 <SystemInit+0x1c8>
    3d7c:	10000324 	.word	0x10000324
    3d80:	40013540 	.word	0x40013540
    3d84:	4007c074 	.word	0x4007c074
    3d88:	baadf00d 	.word	0xbaadf00d
    3d8c:	10000244 	.word	0x10000244
    3d90:	4000053c 	.word	0x4000053c
    3d94:	e000edf0 	.word	0xe000edf0
    3d98:	400005a0 	.word	0x400005a0
    3d9c:	40005610 	.word	0x40005610
    3da0:	4000c000 	.word	0x4000c000
    3da4:	10000258 	.word	0x10000258
    3da8:	40000ee4 	.word	0x40000ee4
    3dac:	4000173c 	.word	0x4000173c
    3db0:	e000ed00 	.word	0xe000ed00
    3db4:	05fa0004 	.word	0x05fa0004

00003db8 <nrfx_clock_anomaly_132>:
    uint32_t core_debug;
    uint32_t dwt_ctrl;

    // Preserve DEMCR register to do not influence into its configuration. Enable the trace and
    // debug blocks. It is required to read and write data to DWT block.
    core_debug = CoreDebug->DEMCR;
    3db8:	4b0b      	ldr	r3, [pc, #44]	; (3de8 <nrfx_clock_anomaly_132+0x30>)
    3dba:	68d9      	ldr	r1, [r3, #12]
    CoreDebug->DEMCR = core_debug | CoreDebug_DEMCR_TRCENA_Msk;
    3dbc:	f041 7280 	orr.w	r2, r1, #16777216	; 0x1000000
    3dc0:	60da      	str	r2, [r3, #12]

    // Preserve CTRL register in DWT block to do not influence into its configuration. Make sure
    // that cycle counter is enabled.
    dwt_ctrl = DWT->CTRL;
    3dc2:	4b0a      	ldr	r3, [pc, #40]	; (3dec <nrfx_clock_anomaly_132+0x34>)
    3dc4:	6818      	ldr	r0, [r3, #0]
    DWT->CTRL = dwt_ctrl | DWT_CTRL_CYCCNTENA_Msk;
    3dc6:	f040 0201 	orr.w	r2, r0, #1
    3dca:	601a      	str	r2, [r3, #0]

    // Store start value of cycle counter.
    cyccnt_inital = DWT->CYCCNT;
    3dcc:	685a      	ldr	r2, [r3, #4]

    // Delay required time.
    while ((DWT->CYCCNT - cyccnt_inital) < ANOMALY_132_DELAY_CYCLES)
    3dce:	4b07      	ldr	r3, [pc, #28]	; (3dec <nrfx_clock_anomaly_132+0x34>)
    3dd0:	685b      	ldr	r3, [r3, #4]
    3dd2:	1a9b      	subs	r3, r3, r2
    3dd4:	f5b3 5f0a 	cmp.w	r3, #8832	; 0x2280
    3dd8:	d3f9      	bcc.n	3dce <nrfx_clock_anomaly_132+0x16>
    {}

    // Restore preserved registers.
    DWT->CTRL = dwt_ctrl;
    3dda:	4b04      	ldr	r3, [pc, #16]	; (3dec <nrfx_clock_anomaly_132+0x34>)
    3ddc:	6018      	str	r0, [r3, #0]
    CoreDebug->DEMCR = core_debug;
    3dde:	f503 435d 	add.w	r3, r3, #56576	; 0xdd00
    3de2:	33f0      	adds	r3, #240	; 0xf0
    3de4:	60d9      	str	r1, [r3, #12]
}
    3de6:	4770      	bx	lr
    3de8:	e000edf0 	.word	0xe000edf0
    3dec:	e0001000 	.word	0xe0001000

00003df0 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    3df0:	4b06      	ldr	r3, [pc, #24]	; (3e0c <nrfx_clock_init+0x1c>)
    3df2:	791b      	ldrb	r3, [r3, #4]
    3df4:	b93b      	cbnz	r3, 3e06 <nrfx_clock_init+0x16>
    else
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
    3df6:	4b05      	ldr	r3, [pc, #20]	; (3e0c <nrfx_clock_init+0x1c>)
    3df8:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    3dfa:	2201      	movs	r2, #1
    3dfc:	711a      	strb	r2, [r3, #4]
#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        m_clock_cb.hfclk_started = false;
    3dfe:	2200      	movs	r2, #0
    3e00:	715a      	strb	r2, [r3, #5]
    nrfx_err_t err_code = NRFX_SUCCESS;
    3e02:	4803      	ldr	r0, [pc, #12]	; (3e10 <nrfx_clock_init+0x20>)
    3e04:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    3e06:	4803      	ldr	r0, [pc, #12]	; (3e14 <nrfx_clock_init+0x24>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    3e08:	4770      	bx	lr
    3e0a:	bf00      	nop
    3e0c:	20000510 	.word	0x20000510
    3e10:	0bad0000 	.word	0x0bad0000
    3e14:	0bad000c 	.word	0x0bad000c

00003e18 <nrfx_clock_start>:
    m_clock_cb.module_initialized = false;
    NRFX_LOG_INFO("Uninitialized.");
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    3e18:	b508      	push	{r3, lr}
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    3e1a:	b110      	cbz	r0, 3e22 <nrfx_clock_start+0xa>
    3e1c:	2801      	cmp	r0, #1
    3e1e:	d027      	beq.n	3e70 <nrfx_clock_start+0x58>
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
    3e20:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    3e22:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    3e26:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    3e2a:	f003 0303 	and.w	r3, r3, #3
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    3e2e:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
    3e32:	f412 3f80 	tst.w	r2, #65536	; 0x10000
    3e36:	d113      	bne.n	3e60 <nrfx_clock_start+0x48>
    p_reg->LFCLKSRC = (uint32_t)(source);
    3e38:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3e3c:	2200      	movs	r2, #0
    3e3e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3e42:	4b11      	ldr	r3, [pc, #68]	; (3e88 <nrfx_clock_start+0x70>)
    3e44:	2200      	movs	r2, #0
    3e46:	601a      	str	r2, [r3, #0]
    3e48:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    3e4a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3e4e:	2202      	movs	r2, #2
    3e50:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
            nrfx_clock_anomaly_132();
    3e54:	f7ff ffb0 	bl	3db8 <nrfx_clock_anomaly_132>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3e58:	4b0c      	ldr	r3, [pc, #48]	; (3e8c <nrfx_clock_start+0x74>)
    3e5a:	2201      	movs	r2, #1
    3e5c:	601a      	str	r2, [r3, #0]
}
    3e5e:	e7df      	b.n	3e20 <nrfx_clock_start+0x8>
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    3e60:	2b01      	cmp	r3, #1
    3e62:	d1e9      	bne.n	3e38 <nrfx_clock_start+0x20>
    p_reg->LFCLKSRC = (uint32_t)(source);
    3e64:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3e68:	2201      	movs	r2, #1
    3e6a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    3e6e:	e7e8      	b.n	3e42 <nrfx_clock_start+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3e70:	4b07      	ldr	r3, [pc, #28]	; (3e90 <nrfx_clock_start+0x78>)
    3e72:	2200      	movs	r2, #0
    3e74:	601a      	str	r2, [r3, #0]
    3e76:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    3e78:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3e7c:	2201      	movs	r2, #1
    3e7e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3e82:	601a      	str	r2, [r3, #0]
}
    3e84:	e7cc      	b.n	3e20 <nrfx_clock_start+0x8>
    3e86:	bf00      	nop
    3e88:	40000104 	.word	0x40000104
    3e8c:	40000008 	.word	0x40000008
    3e90:	40000100 	.word	0x40000100

00003e94 <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    3e94:	b530      	push	{r4, r5, lr}
    3e96:	b083      	sub	sp, #12
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    3e98:	4604      	mov	r4, r0
    3e9a:	b118      	cbz	r0, 3ea4 <nrfx_clock_stop+0x10>
    3e9c:	2801      	cmp	r0, #1
    3e9e:	d013      	beq.n	3ec8 <nrfx_clock_stop+0x34>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    3ea0:	b003      	add	sp, #12
    3ea2:	bd30      	pop	{r4, r5, pc}
    p_reg->INTENCLR = mask;
    3ea4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3ea8:	2202      	movs	r2, #2
    3eaa:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3eae:	f503 7382 	add.w	r3, r3, #260	; 0x104
    3eb2:	2200      	movs	r2, #0
    3eb4:	601a      	str	r2, [r3, #0]
    3eb6:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3eb8:	4b39      	ldr	r3, [pc, #228]	; (3fa0 <nrfx_clock_stop+0x10c>)
    3eba:	2201      	movs	r2, #1
    3ebc:	601a      	str	r2, [r3, #0]
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    3ebe:	2c01      	cmp	r4, #1
    3ec0:	d00f      	beq.n	3ee2 <nrfx_clock_stop+0x4e>
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    3ec2:	f242 7510 	movw	r5, #10000	; 0x2710
    3ec6:	e052      	b.n	3f6e <nrfx_clock_stop+0xda>
    p_reg->INTENCLR = mask;
    3ec8:	2301      	movs	r3, #1
    3eca:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    3ece:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3ed2:	f502 7280 	add.w	r2, r2, #256	; 0x100
    3ed6:	2100      	movs	r1, #0
    3ed8:	6011      	str	r1, [r2, #0]
    3eda:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    3edc:	4a31      	ldr	r2, [pc, #196]	; (3fa4 <nrfx_clock_stop+0x110>)
    3ede:	6013      	str	r3, [r2, #0]
}
    3ee0:	e7ed      	b.n	3ebe <nrfx_clock_stop+0x2a>
        nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    3ee2:	2301      	movs	r3, #1
    3ee4:	f88d 3007 	strb.w	r3, [sp, #7]
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    3ee8:	f242 7510 	movw	r5, #10000	; 0x2710
    3eec:	e018      	b.n	3f20 <nrfx_clock_stop+0x8c>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    3eee:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    3ef2:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    3ef6:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    3efa:	f8cd 3007 	str.w	r3, [sp, #7]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    3efe:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
    3f02:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    3f06:	d120      	bne.n	3f4a <nrfx_clock_stop+0xb6>
    return false;
    3f08:	2300      	movs	r3, #0
    3f0a:	2b00      	cmp	r3, #0
    3f0c:	d042      	beq.n	3f94 <nrfx_clock_stop+0x100>
    3f0e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    3f12:	2b01      	cmp	r3, #1
    3f14:	d13e      	bne.n	3f94 <nrfx_clock_stop+0x100>
    3f16:	2001      	movs	r0, #1
    3f18:	f003 f928 	bl	716c <nrfx_busy_wait>
    3f1c:	3d01      	subs	r5, #1
    3f1e:	d039      	beq.n	3f94 <nrfx_clock_stop+0x100>
    switch (domain)
    3f20:	2c00      	cmp	r4, #0
    3f22:	d0e4      	beq.n	3eee <nrfx_clock_stop+0x5a>
    3f24:	2c01      	cmp	r4, #1
    3f26:	d001      	beq.n	3f2c <nrfx_clock_stop+0x98>
    3f28:	2300      	movs	r3, #0
    3f2a:	e7ee      	b.n	3f0a <nrfx_clock_stop+0x76>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    3f2c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    3f30:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
    3f34:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    3f38:	f88d 3007 	strb.w	r3, [sp, #7]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    3f3c:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
    3f40:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    3f44:	d103      	bne.n	3f4e <nrfx_clock_stop+0xba>
    return false;
    3f46:	2300      	movs	r3, #0
    3f48:	e7df      	b.n	3f0a <nrfx_clock_stop+0x76>
                return true;
    3f4a:	2301      	movs	r3, #1
    3f4c:	e7dd      	b.n	3f0a <nrfx_clock_stop+0x76>
                return true;
    3f4e:	2301      	movs	r3, #1
    3f50:	e7db      	b.n	3f0a <nrfx_clock_stop+0x76>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    3f52:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3f56:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
    3f5a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    3f5e:	d115      	bne.n	3f8c <nrfx_clock_stop+0xf8>
    return false;
    3f60:	2300      	movs	r3, #0
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    3f62:	b1bb      	cbz	r3, 3f94 <nrfx_clock_stop+0x100>
    3f64:	2001      	movs	r0, #1
    3f66:	f003 f901 	bl	716c <nrfx_busy_wait>
    3f6a:	3d01      	subs	r5, #1
    3f6c:	d012      	beq.n	3f94 <nrfx_clock_stop+0x100>
    switch (domain)
    3f6e:	2c00      	cmp	r4, #0
    3f70:	d0ef      	beq.n	3f52 <nrfx_clock_stop+0xbe>
    3f72:	2c01      	cmp	r4, #1
    3f74:	d001      	beq.n	3f7a <nrfx_clock_stop+0xe6>
    3f76:	2300      	movs	r3, #0
    3f78:	e7f3      	b.n	3f62 <nrfx_clock_stop+0xce>
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    3f7a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3f7e:	f8d3 340c 	ldr.w	r3, [r3, #1036]	; 0x40c
    3f82:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    3f86:	d103      	bne.n	3f90 <nrfx_clock_stop+0xfc>
    return false;
    3f88:	2300      	movs	r3, #0
    3f8a:	e7ea      	b.n	3f62 <nrfx_clock_stop+0xce>
                return true;
    3f8c:	2301      	movs	r3, #1
    3f8e:	e7e8      	b.n	3f62 <nrfx_clock_stop+0xce>
                return true;
    3f90:	2301      	movs	r3, #1
    3f92:	e7e6      	b.n	3f62 <nrfx_clock_stop+0xce>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    3f94:	2c01      	cmp	r4, #1
    3f96:	d183      	bne.n	3ea0 <nrfx_clock_stop+0xc>
            m_clock_cb.hfclk_started = false;
    3f98:	4b03      	ldr	r3, [pc, #12]	; (3fa8 <nrfx_clock_stop+0x114>)
    3f9a:	2200      	movs	r2, #0
    3f9c:	715a      	strb	r2, [r3, #5]
    3f9e:	e77f      	b.n	3ea0 <nrfx_clock_stop+0xc>
    3fa0:	4000000c 	.word	0x4000000c
    3fa4:	40000004 	.word	0x40000004
    3fa8:	20000510 	.word	0x20000510

00003fac <nrfx_power_clock_irq_handler>:
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    3fac:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    3fae:	4b1b      	ldr	r3, [pc, #108]	; (401c <nrfx_power_clock_irq_handler+0x70>)
    3fb0:	681b      	ldr	r3, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    3fb2:	b183      	cbz	r3, 3fd6 <nrfx_power_clock_irq_handler+0x2a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3fb4:	4b19      	ldr	r3, [pc, #100]	; (401c <nrfx_power_clock_irq_handler+0x70>)
    3fb6:	2200      	movs	r2, #0
    3fb8:	601a      	str	r2, [r3, #0]
    3fba:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    3fbc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3fc0:	2201      	movs	r2, #1
    3fc2:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
    3fc6:	4b16      	ldr	r3, [pc, #88]	; (4020 <nrfx_power_clock_irq_handler+0x74>)
    3fc8:	795b      	ldrb	r3, [r3, #5]
    3fca:	b923      	cbnz	r3, 3fd6 <nrfx_power_clock_irq_handler+0x2a>
        {
            m_clock_cb.hfclk_started = true;
    3fcc:	4b14      	ldr	r3, [pc, #80]	; (4020 <nrfx_power_clock_irq_handler+0x74>)
    3fce:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    3fd0:	681b      	ldr	r3, [r3, #0]
    3fd2:	2000      	movs	r0, #0
    3fd4:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    3fd6:	4b13      	ldr	r3, [pc, #76]	; (4024 <nrfx_power_clock_irq_handler+0x78>)
    3fd8:	681b      	ldr	r3, [r3, #0]
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    3fda:	b19b      	cbz	r3, 4004 <nrfx_power_clock_irq_handler+0x58>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    3fdc:	4b11      	ldr	r3, [pc, #68]	; (4024 <nrfx_power_clock_irq_handler+0x78>)
    3fde:	2200      	movs	r2, #0
    3fe0:	601a      	str	r2, [r3, #0]
    3fe2:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    3fe4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    3fe8:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    3fec:	f8d3 3418 	ldr.w	r3, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    3ff0:	f012 0f03 	tst.w	r2, #3
    3ff4:	d107      	bne.n	4006 <nrfx_power_clock_irq_handler+0x5a>
    p_reg->LFCLKSRC = (uint32_t)(source);
    3ff6:	2301      	movs	r3, #1
    3ff8:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    3ffc:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    4000:	3208      	adds	r2, #8
    4002:	6013      	str	r3, [r2, #0]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    4004:	bd08      	pop	{r3, pc}
    p_reg->INTENCLR = mask;
    4006:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    400a:	2202      	movs	r2, #2
    400c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    4010:	4b03      	ldr	r3, [pc, #12]	; (4020 <nrfx_power_clock_irq_handler+0x74>)
    4012:	681b      	ldr	r3, [r3, #0]
    4014:	2001      	movs	r0, #1
    4016:	4798      	blx	r3
}
    4018:	e7f4      	b.n	4004 <nrfx_power_clock_irq_handler+0x58>
    401a:	bf00      	nop
    401c:	40000100 	.word	0x40000100
    4020:	20000510 	.word	0x20000510
    4024:	40000104 	.word	0x40000104

00004028 <is_allocated_channel>:
    NRFX_LOG_INFO("Uninitialized.");
}

static bool is_allocated_channel(uint8_t index)
{
    return m_cb.allocated_channels_mask & (1UL << index);
    4028:	4b04      	ldr	r3, [pc, #16]	; (403c <is_allocated_channel+0x14>)
    402a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    402c:	2301      	movs	r3, #1
    402e:	4083      	lsls	r3, r0
    4030:	421a      	tst	r2, r3
}
    4032:	bf14      	ite	ne
    4034:	2001      	movne	r0, #1
    4036:	2000      	moveq	r0, #0
    4038:	4770      	bx	lr
    403a:	bf00      	nop
    403c:	20000518 	.word	0x20000518

00004040 <channel_allocated_set>:
    return NRFX_GPIOTE_APP_CHANNELS_MASK & (1UL << index);
}

static void channel_allocated_set(uint8_t index)
{
    m_cb.allocated_channels_mask |= (1UL << index);
    4040:	2301      	movs	r3, #1
    4042:	fa03 f000 	lsl.w	r0, r3, r0
    4046:	4a02      	ldr	r2, [pc, #8]	; (4050 <channel_allocated_set+0x10>)
    4048:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    404a:	4303      	orrs	r3, r0
    404c:	64d3      	str	r3, [r2, #76]	; 0x4c
}
    404e:	4770      	bx	lr
    4050:	20000518 	.word	0x20000518

00004054 <channel_allocated_clr>:

static void channel_allocated_clr(uint8_t index)
{
    m_cb.allocated_channels_mask &= ~(1UL << index);
    4054:	2301      	movs	r3, #1
    4056:	fa03 f000 	lsl.w	r0, r3, r0
    405a:	4a03      	ldr	r2, [pc, #12]	; (4068 <channel_allocated_clr+0x14>)
    405c:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
    405e:	ea23 0300 	bic.w	r3, r3, r0
    4062:	64d3      	str	r3, [r2, #76]	; 0x4c
}
    4064:	4770      	bx	lr
    4066:	bf00      	nop
    4068:	20000518 	.word	0x20000518

0000406c <nrfx_gpiote_channel_free>:

nrfx_err_t nrfx_gpiote_channel_free(uint8_t channel)
{
    406c:	b538      	push	{r3, r4, r5, lr}
    406e:	4604      	mov	r4, r0
    nrfx_err_t err_code = NRFX_SUCCESS;

    if (!is_app_channel(channel))
    4070:	f003 f889 	bl	7186 <is_app_channel>
    4074:	b908      	cbnz	r0, 407a <nrfx_gpiote_channel_free+0xe>
    {
        err_code = NRFX_ERROR_INVALID_PARAM;
    4076:	4809      	ldr	r0, [pc, #36]	; (409c <nrfx_gpiote_channel_free+0x30>)
        NRFX_CRITICAL_SECTION_EXIT();
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    4078:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    407a:	f04f 0320 	mov.w	r3, #32
    407e:	f3ef 8511 	mrs	r5, BASEPRI
    4082:	f383 8811 	msr	BASEPRI, r3
    4086:	f3bf 8f6f 	isb	sy
        channel_allocated_clr(channel);
    408a:	4620      	mov	r0, r4
    408c:	f7ff ffe2 	bl	4054 <channel_allocated_clr>
	__asm__ volatile(
    4090:	f385 8811 	msr	BASEPRI, r5
    4094:	f3bf 8f6f 	isb	sy
    nrfx_err_t err_code = NRFX_SUCCESS;
    4098:	4801      	ldr	r0, [pc, #4]	; (40a0 <nrfx_gpiote_channel_free+0x34>)
}
    409a:	e7ed      	b.n	4078 <nrfx_gpiote_channel_free+0xc>
    409c:	0bad0004 	.word	0x0bad0004
    40a0:	0bad0000 	.word	0x0bad0000

000040a4 <nrfx_gpiote_channel_alloc>:

nrfx_err_t nrfx_gpiote_channel_alloc(uint8_t * p_channel)
{
    40a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    40a8:	4680      	mov	r8, r0
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    uint32_t mask = NRFX_GPIOTE_APP_CHANNELS_MASK;

    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    40aa:	2400      	movs	r4, #0
    uint32_t mask = NRFX_GPIOTE_APP_CHANNELS_MASK;
    40ac:	25ff      	movs	r5, #255	; 0xff
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    40ae:	4f17      	ldr	r7, [pc, #92]	; (410c <nrfx_gpiote_channel_alloc+0x68>)
    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    40b0:	e013      	b.n	40da <nrfx_gpiote_channel_alloc+0x36>
    {
        NRFX_CRITICAL_SECTION_ENTER();
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
        {
            channel_allocated_set(ch_idx);
    40b2:	4620      	mov	r0, r4
    40b4:	f7ff ffc4 	bl	4040 <channel_allocated_set>
            *p_channel = ch_idx;
    40b8:	f888 4000 	strb.w	r4, [r8]
            err_code = NRFX_SUCCESS;
    40bc:	4f14      	ldr	r7, [pc, #80]	; (4110 <nrfx_gpiote_channel_alloc+0x6c>)
	__asm__ volatile(
    40be:	f386 8811 	msr	BASEPRI, r6
    40c2:	f3bf 8f6f 	isb	sy
        }
        NRFX_CRITICAL_SECTION_EXIT();

        if (err_code == NRFX_SUCCESS)
    40c6:	4b12      	ldr	r3, [pc, #72]	; (4110 <nrfx_gpiote_channel_alloc+0x6c>)
    40c8:	429f      	cmp	r7, r3
    40ca:	d01b      	beq.n	4104 <nrfx_gpiote_channel_alloc+0x60>
        {
            NRFX_LOG_INFO("Allocated channel: %d.", ch_idx);
            break;
        }

        mask &= ~(1UL << ch_idx);
    40cc:	2301      	movs	r3, #1
    40ce:	fa03 f309 	lsl.w	r3, r3, r9
    40d2:	ea25 0503 	bic.w	r5, r5, r3
    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    40d6:	3401      	adds	r4, #1
    40d8:	b2e4      	uxtb	r4, r4
    40da:	b19d      	cbz	r5, 4104 <nrfx_gpiote_channel_alloc+0x60>
	__asm__ volatile(
    40dc:	f04f 0320 	mov.w	r3, #32
    40e0:	f3ef 8611 	mrs	r6, BASEPRI
    40e4:	f383 8811 	msr	BASEPRI, r3
    40e8:	f3bf 8f6f 	isb	sy
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
    40ec:	46a1      	mov	r9, r4
    40ee:	fa25 f304 	lsr.w	r3, r5, r4
    40f2:	f013 0f01 	tst.w	r3, #1
    40f6:	d0e2      	beq.n	40be <nrfx_gpiote_channel_alloc+0x1a>
    40f8:	4620      	mov	r0, r4
    40fa:	f7ff ff95 	bl	4028 <is_allocated_channel>
    40fe:	2800      	cmp	r0, #0
    4100:	d1dd      	bne.n	40be <nrfx_gpiote_channel_alloc+0x1a>
    4102:	e7d6      	b.n	40b2 <nrfx_gpiote_channel_alloc+0xe>
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    4104:	4638      	mov	r0, r7
    4106:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    410a:	bf00      	nop
    410c:	0bad0002 	.word	0x0bad0002
    4110:	0bad0000 	.word	0x0bad0000

00004114 <is_allocated_channel>:
NRFX_STATIC_INLINE uint32_t nrfx_ppi_task_addr_group_disable_get(nrf_ppi_channel_group_t group);

#ifndef NRFX_DECLARE_ONLY
NRFX_STATIC_INLINE uint32_t nrfx_ppi_channel_to_mask(nrf_ppi_channel_t channel)
{
    return (1uL << (uint32_t) channel);
    4114:	2301      	movs	r3, #1
    4116:	4083      	lsls	r3, r0
 * @retval true  The channel is allocated.
 * @retval false The channel is not allocated.
 */
static bool is_allocated_channel(nrf_ppi_channel_t channel)
{
    return ((m_channels_allocated & nrfx_ppi_channel_to_mask(channel)) != 0);
    4118:	4a03      	ldr	r2, [pc, #12]	; (4128 <is_allocated_channel+0x14>)
    411a:	6812      	ldr	r2, [r2, #0]
    411c:	4213      	tst	r3, r2
}
    411e:	bf14      	ite	ne
    4120:	2001      	movne	r0, #1
    4122:	2000      	moveq	r0, #0
    4124:	4770      	bx	lr
    4126:	bf00      	nop
    4128:	20000568 	.word	0x20000568

0000412c <channel_allocated_set>:
    412c:	2301      	movs	r3, #1
    412e:	fa03 f000 	lsl.w	r0, r3, r0
 *
 * @param[in] channel_num Specifies the channel to set the "allocated" indication.
 */
static void channel_allocated_set(nrf_ppi_channel_t channel)
{
    m_channels_allocated |= nrfx_ppi_channel_to_mask(channel);
    4132:	4a02      	ldr	r2, [pc, #8]	; (413c <channel_allocated_set+0x10>)
    4134:	6813      	ldr	r3, [r2, #0]
    4136:	4303      	orrs	r3, r0
    4138:	6013      	str	r3, [r2, #0]
}
    413a:	4770      	bx	lr
    413c:	20000568 	.word	0x20000568

00004140 <nrfx_ppi_channel_alloc>:
    group_allocated_clr_all();
}


nrfx_err_t nrfx_ppi_channel_alloc(nrf_ppi_channel_t * p_channel)
{
    4140:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4144:	4681      	mov	r9, r0
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    uint32_t mask = NRFX_PPI_PROG_APP_CHANNELS_MASK;

    for (uint8_t ch_idx = NRF_PPI_CHANNEL0; mask != 0; ch_idx++)
    4146:	2400      	movs	r4, #0
    uint32_t mask = NRFX_PPI_PROG_APP_CHANNELS_MASK;
    4148:	4e15      	ldr	r6, [pc, #84]	; (41a0 <nrfx_ppi_channel_alloc+0x60>)
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    414a:	f8df 805c 	ldr.w	r8, [pc, #92]	; 41a8 <nrfx_ppi_channel_alloc+0x68>
    for (uint8_t ch_idx = NRF_PPI_CHANNEL0; mask != 0; ch_idx++)
    414e:	e011      	b.n	4174 <nrfx_ppi_channel_alloc+0x34>
    {
        nrf_ppi_channel_t channel = (nrf_ppi_channel_t)ch_idx;
        NRFX_CRITICAL_SECTION_ENTER();
        if ((mask & nrfx_ppi_channel_to_mask(channel)) && (!is_allocated_channel(channel)))
        {
            channel_allocated_set(channel);
    4150:	4620      	mov	r0, r4
    4152:	f7ff ffeb 	bl	412c <channel_allocated_set>
            *p_channel = channel;
    4156:	f889 4000 	strb.w	r4, [r9]
            err_code   = NRFX_SUCCESS;
    415a:	f8df 8048 	ldr.w	r8, [pc, #72]	; 41a4 <nrfx_ppi_channel_alloc+0x64>
	__asm__ volatile(
    415e:	f387 8811 	msr	BASEPRI, r7
    4162:	f3bf 8f6f 	isb	sy
        }
        NRFX_CRITICAL_SECTION_EXIT();
        if (err_code == NRFX_SUCCESS)
    4166:	4b0f      	ldr	r3, [pc, #60]	; (41a4 <nrfx_ppi_channel_alloc+0x64>)
    4168:	4598      	cmp	r8, r3
    416a:	d016      	beq.n	419a <nrfx_ppi_channel_alloc+0x5a>
        {
            NRFX_LOG_INFO("Allocated channel: %d.", channel);
            break;
        }
        mask &= ~nrfx_ppi_channel_to_mask(channel);
    416c:	ea26 0605 	bic.w	r6, r6, r5
    for (uint8_t ch_idx = NRF_PPI_CHANNEL0; mask != 0; ch_idx++)
    4170:	3401      	adds	r4, #1
    4172:	b2e4      	uxtb	r4, r4
    4174:	b18e      	cbz	r6, 419a <nrfx_ppi_channel_alloc+0x5a>
	__asm__ volatile(
    4176:	f04f 0320 	mov.w	r3, #32
    417a:	f3ef 8711 	mrs	r7, BASEPRI
    417e:	f383 8811 	msr	BASEPRI, r3
    4182:	f3bf 8f6f 	isb	sy
    4186:	2501      	movs	r5, #1
    4188:	40a5      	lsls	r5, r4
        if ((mask & nrfx_ppi_channel_to_mask(channel)) && (!is_allocated_channel(channel)))
    418a:	4235      	tst	r5, r6
    418c:	d0e7      	beq.n	415e <nrfx_ppi_channel_alloc+0x1e>
    418e:	4620      	mov	r0, r4
    4190:	f7ff ffc0 	bl	4114 <is_allocated_channel>
    4194:	2800      	cmp	r0, #0
    4196:	d1e2      	bne.n	415e <nrfx_ppi_channel_alloc+0x1e>
    4198:	e7da      	b.n	4150 <nrfx_ppi_channel_alloc+0x10>
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    419a:	4640      	mov	r0, r8
    419c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    41a0:	000fffff 	.word	0x000fffff
    41a4:	0bad0000 	.word	0x0bad0000
    41a8:	0bad0002 	.word	0x0bad0002

000041ac <_DoInit>:
                      _DoInit();                                                                     \
                    }                                                                                \
                  } while (0);                                                                       \
                }

static void _DoInit(void) {
    41ac:	b510      	push	{r4, lr}
  volatile SEGGER_RTT_CB* p;   // Volatile to make sure that compiler cannot change the order of accesses to the control block
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((char*)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    41ae:	4c11      	ldr	r4, [pc, #68]	; (41f4 <_DoInit+0x48>)
    41b0:	2303      	movs	r3, #3
    41b2:	6123      	str	r3, [r4, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    41b4:	6163      	str	r3, [r4, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
    41b6:	4a10      	ldr	r2, [pc, #64]	; (41f8 <_DoInit+0x4c>)
    41b8:	61a2      	str	r2, [r4, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
    41ba:	4b10      	ldr	r3, [pc, #64]	; (41fc <_DoInit+0x50>)
    41bc:	61e3      	str	r3, [r4, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
    41be:	f44f 6380 	mov.w	r3, #1024	; 0x400
    41c2:	6223      	str	r3, [r4, #32]
  p->aUp[0].RdOff         = 0u;
    41c4:	2300      	movs	r3, #0
    41c6:	62a3      	str	r3, [r4, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
    41c8:	6263      	str	r3, [r4, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    41ca:	62e3      	str	r3, [r4, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
    41cc:	6622      	str	r2, [r4, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
    41ce:	4a0c      	ldr	r2, [pc, #48]	; (4200 <_DoInit+0x54>)
    41d0:	6662      	str	r2, [r4, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
    41d2:	2210      	movs	r2, #16
    41d4:	66a2      	str	r2, [r4, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
    41d6:	6723      	str	r3, [r4, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
    41d8:	66e3      	str	r3, [r4, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    41da:	6763      	str	r3, [r4, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  STRCPY((char*)&p->acID[7], "RTT");
    41dc:	4909      	ldr	r1, [pc, #36]	; (4204 <_DoInit+0x58>)
    41de:	1de0      	adds	r0, r4, #7
    41e0:	f002 fbf8 	bl	69d4 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  STRCPY((char*)&p->acID[0], "SEGGER");
    41e4:	4908      	ldr	r1, [pc, #32]	; (4208 <_DoInit+0x5c>)
    41e6:	4620      	mov	r0, r4
    41e8:	f002 fbf4 	bl	69d4 <strcpy>
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
  p->acID[6] = ' ';
    41ec:	2320      	movs	r3, #32
    41ee:	71a3      	strb	r3, [r4, #6]
  RTT__DMB();                       // Force order of memory accessed inside core for cores that allow to change the order
}
    41f0:	bd10      	pop	{r4, pc}
    41f2:	bf00      	nop
    41f4:	2000056c 	.word	0x2000056c
    41f8:	000082a4 	.word	0x000082a4
    41fc:	20000624 	.word	0x20000624
    4200:	20000614 	.word	0x20000614
    4204:	000082b0 	.word	0x000082b0
    4208:	000082b4 	.word	0x000082b4

0000420c <SEGGER_RTT_WriteSkipNoLock>:
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
#if (RTT_USE_ASM == 0)
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    420c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4210:	4604      	mov	r4, r0
    4212:	460e      	mov	r6, r1
    4214:	4615      	mov	r5, r2
  //
  // 1) is the most common case for large buffers and assuming that J-Link reads the data fast enough
  //
  pData = (const char *)pBuffer;
  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  RdOff = pRing->RdOff;
    4216:	eb00 0340 	add.w	r3, r0, r0, lsl #1
    421a:	4a2d      	ldr	r2, [pc, #180]	; (42d0 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    421c:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    4220:	6a93      	ldr	r3, [r2, #40]	; 0x28
  WrOff = pRing->WrOff;
    4222:	6a57      	ldr	r7, [r2, #36]	; 0x24
  if (RdOff <= WrOff) {                                 // Case 1), 2) or 3)
    4224:	42bb      	cmp	r3, r7
    4226:	d84b      	bhi.n	42c0 <SEGGER_RTT_WriteSkipNoLock+0xb4>
    Avail = pRing->SizeOfBuffer - WrOff - 1u;           // Space until wrap-around (assume 1 byte not usable for case that RdOff == 0)
    4228:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    422c:	4928      	ldr	r1, [pc, #160]	; (42d0 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    422e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
    4232:	f8d2 8020 	ldr.w	r8, [r2, #32]
    4236:	eba8 0907 	sub.w	r9, r8, r7
    423a:	f109 32ff 	add.w	r2, r9, #4294967295
    if (Avail >= NumBytes) {                            // Case 1)?
    423e:	4295      	cmp	r5, r2
    4240:	d904      	bls.n	424c <SEGGER_RTT_WriteSkipNoLock+0x40>
      memcpy((void*)pDst, pData, NumBytes);
      RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
      pRing->WrOff = WrOff + NumBytes;
      return 1;
    }
    Avail += RdOff;                                     // Space incl. wrap-around
    4242:	4413      	add	r3, r2
    if (Avail >= NumBytes) {                            // Case 2? => If not, we have case 3) (does not fit)
    4244:	429d      	cmp	r5, r3
    4246:	d916      	bls.n	4276 <SEGGER_RTT_WriteSkipNoLock+0x6a>
    Avail = RdOff - WrOff - 1u;
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
      goto CopyStraight;
    }
  }
  return 0;     // No space in buffer
    4248:	2000      	movs	r0, #0
    424a:	e03e      	b.n	42ca <SEGGER_RTT_WriteSkipNoLock+0xbe>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    424c:	f8df 8080 	ldr.w	r8, [pc, #128]	; 42d0 <SEGGER_RTT_WriteSkipNoLock+0xc4>
    4250:	1c63      	adds	r3, r4, #1
    4252:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    4256:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
    425a:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, NumBytes);
    425c:	462a      	mov	r2, r5
    425e:	4631      	mov	r1, r6
    4260:	4438      	add	r0, r7
    4262:	f002 fbf6 	bl	6a52 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
    4266:	443d      	add	r5, r7
    4268:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    426c:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
    4270:	6265      	str	r5, [r4, #36]	; 0x24
      return 1;
    4272:	2001      	movs	r0, #1
    4274:	e029      	b.n	42ca <SEGGER_RTT_WriteSkipNoLock+0xbe>
      pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
    4276:	1c43      	adds	r3, r0, #1
    4278:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    427c:	4a14      	ldr	r2, [pc, #80]	; (42d0 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    427e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
    4282:	6858      	ldr	r0, [r3, #4]
      memcpy((void*)pDst, pData, Rem);                  // Copy 1st chunk
    4284:	464a      	mov	r2, r9
    4286:	4631      	mov	r1, r6
    4288:	4438      	add	r0, r7
    428a:	f002 fbe2 	bl	6a52 <memcpy>
      NumBytes -= Rem;
    428e:	eba7 0708 	sub.w	r7, r7, r8
      if (NumBytes) {
    4292:	197f      	adds	r7, r7, r5
    4294:	d107      	bne.n	42a6 <SEGGER_RTT_WriteSkipNoLock+0x9a>
      pRing->WrOff = NumBytes;
    4296:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    429a:	4b0d      	ldr	r3, [pc, #52]	; (42d0 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    429c:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    42a0:	6267      	str	r7, [r4, #36]	; 0x24
      return 1;
    42a2:	2001      	movs	r0, #1
    42a4:	e011      	b.n	42ca <SEGGER_RTT_WriteSkipNoLock+0xbe>
        pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
    42a6:	1c63      	adds	r3, r4, #1
    42a8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    42ac:	4a08      	ldr	r2, [pc, #32]	; (42d0 <SEGGER_RTT_WriteSkipNoLock+0xc4>)
    42ae:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
        memcpy((void*)pDst, pData + Rem, NumBytes);
    42b2:	463a      	mov	r2, r7
    42b4:	eb06 0109 	add.w	r1, r6, r9
    42b8:	6858      	ldr	r0, [r3, #4]
    42ba:	f002 fbca 	bl	6a52 <memcpy>
    42be:	e7ea      	b.n	4296 <SEGGER_RTT_WriteSkipNoLock+0x8a>
    Avail = RdOff - WrOff - 1u;
    42c0:	1bdb      	subs	r3, r3, r7
    42c2:	3b01      	subs	r3, #1
    if (Avail >= NumBytes) {                           // Case 4)? => If not, we have case 5) (does not fit)
    42c4:	42ab      	cmp	r3, r5
    42c6:	d2c1      	bcs.n	424c <SEGGER_RTT_WriteSkipNoLock+0x40>
  return 0;     // No space in buffer
    42c8:	2000      	movs	r0, #0
}
    42ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    42ce:	bf00      	nop
    42d0:	2000056c 	.word	0x2000056c

000042d4 <SEGGER_RTT_HasDataUp>:
unsigned SEGGER_RTT_HasDataUp(unsigned BufferIndex) {
  SEGGER_RTT_BUFFER_UP* pRing;
  unsigned                v;

  pRing = (SEGGER_RTT_BUFFER_UP*)((char*)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
  v = pRing->RdOff;
    42d4:	4b06      	ldr	r3, [pc, #24]	; (42f0 <SEGGER_RTT_HasDataUp+0x1c>)
    42d6:	eb00 0240 	add.w	r2, r0, r0, lsl #1
    42da:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
    42de:	6a92      	ldr	r2, [r2, #40]	; 0x28
  return pRing->WrOff - v;
    42e0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
    42e4:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    42e8:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
    42ea:	1a80      	subs	r0, r0, r2
    42ec:	4770      	bx	lr
    42ee:	bf00      	nop
    42f0:	2000056c 	.word	0x2000056c

000042f4 <z_device_state_init>:
 * The state object is always zero-initialized, but this may not be
 * sufficient.
 */
void z_device_state_init(void)
{
	const struct device *dev = __device_start;
    42f4:	4b03      	ldr	r3, [pc, #12]	; (4304 <z_device_state_init+0x10>)

	while (dev < __device_end) {
    42f6:	4a04      	ldr	r2, [pc, #16]	; (4308 <z_device_state_init+0x14>)
    42f8:	4293      	cmp	r3, r2
    42fa:	d201      	bcs.n	4300 <z_device_state_init+0xc>
		device_pm_state_init(dev);
		z_object_init(dev);
		++dev;
    42fc:	3318      	adds	r3, #24
    42fe:	e7fa      	b.n	42f6 <z_device_state_init+0x2>
	}
}
    4300:	4770      	bx	lr
    4302:	bf00      	nop
    4304:	0000782c 	.word	0x0000782c
    4308:	0000788c 	.word	0x0000788c

0000430c <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    430c:	b570      	push	{r4, r5, r6, lr}
    430e:	4606      	mov	r6, r0
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    4310:	4b11      	ldr	r3, [pc, #68]	; (4358 <z_sys_init_run_level+0x4c>)
    4312:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    4316:	e009      	b.n	432c <z_sys_init_run_level+0x20>
			/* Mark device initialized.  If initialization
			 * failed, record the error condition.
			 */
			if (rc != 0) {
				if (rc < 0) {
					rc = -rc;
    4318:	4240      	negs	r0, r0
    431a:	e017      	b.n	434c <z_sys_init_run_level+0x40>
				}
				if (rc > UINT8_MAX) {
					rc = UINT8_MAX;
				}
				dev->state->init_res = rc;
    431c:	68eb      	ldr	r3, [r5, #12]
    431e:	7018      	strb	r0, [r3, #0]
			}
			dev->state->initialized = true;
    4320:	68ea      	ldr	r2, [r5, #12]
    4322:	7853      	ldrb	r3, [r2, #1]
    4324:	f043 0301 	orr.w	r3, r3, #1
    4328:	7053      	strb	r3, [r2, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    432a:	3408      	adds	r4, #8
    432c:	1c73      	adds	r3, r6, #1
    432e:	4a0a      	ldr	r2, [pc, #40]	; (4358 <z_sys_init_run_level+0x4c>)
    4330:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4334:	42a3      	cmp	r3, r4
    4336:	d90d      	bls.n	4354 <z_sys_init_run_level+0x48>
		const struct device *dev = entry->dev;
    4338:	6865      	ldr	r5, [r4, #4]
		int rc = entry->init(dev);
    433a:	6823      	ldr	r3, [r4, #0]
    433c:	4628      	mov	r0, r5
    433e:	4798      	blx	r3
		if (dev != NULL) {
    4340:	2d00      	cmp	r5, #0
    4342:	d0f2      	beq.n	432a <z_sys_init_run_level+0x1e>
			if (rc != 0) {
    4344:	2800      	cmp	r0, #0
    4346:	d0eb      	beq.n	4320 <z_sys_init_run_level+0x14>
				if (rc < 0) {
    4348:	2800      	cmp	r0, #0
    434a:	dbe5      	blt.n	4318 <z_sys_init_run_level+0xc>
				if (rc > UINT8_MAX) {
    434c:	28ff      	cmp	r0, #255	; 0xff
    434e:	dde5      	ble.n	431c <z_sys_init_run_level+0x10>
					rc = UINT8_MAX;
    4350:	20ff      	movs	r0, #255	; 0xff
    4352:	e7e3      	b.n	431c <z_sys_init_run_level+0x10>
		}
	}
}
    4354:	bd70      	pop	{r4, r5, r6, pc}
    4356:	bf00      	nop
    4358:	000082bc 	.word	0x000082bc

0000435c <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    435c:	b538      	push	{r3, r4, r5, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    435e:	4605      	mov	r5, r0
    4360:	b328      	cbz	r0, 43ae <z_impl_device_get_binding+0x52>
    4362:	7803      	ldrb	r3, [r0, #0]
    4364:	b32b      	cbz	r3, 43b2 <z_impl_device_get_binding+0x56>
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
    4366:	4c14      	ldr	r4, [pc, #80]	; (43b8 <z_impl_device_get_binding+0x5c>)
    4368:	e000      	b.n	436c <z_impl_device_get_binding+0x10>
    436a:	3418      	adds	r4, #24
    436c:	4b13      	ldr	r3, [pc, #76]	; (43bc <z_impl_device_get_binding+0x60>)
    436e:	429c      	cmp	r4, r3
    4370:	d008      	beq.n	4384 <z_impl_device_get_binding+0x28>
		if (z_device_ready(dev) && (dev->name == name)) {
    4372:	4620      	mov	r0, r4
    4374:	f002 ff18 	bl	71a8 <z_device_ready>
    4378:	2800      	cmp	r0, #0
    437a:	d0f6      	beq.n	436a <z_impl_device_get_binding+0xe>
    437c:	6823      	ldr	r3, [r4, #0]
    437e:	42ab      	cmp	r3, r5
    4380:	d1f3      	bne.n	436a <z_impl_device_get_binding+0xe>
    4382:	e012      	b.n	43aa <z_impl_device_get_binding+0x4e>
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
    4384:	4c0c      	ldr	r4, [pc, #48]	; (43b8 <z_impl_device_get_binding+0x5c>)
    4386:	e000      	b.n	438a <z_impl_device_get_binding+0x2e>
    4388:	3418      	adds	r4, #24
    438a:	4b0c      	ldr	r3, [pc, #48]	; (43bc <z_impl_device_get_binding+0x60>)
    438c:	429c      	cmp	r4, r3
    438e:	d00b      	beq.n	43a8 <z_impl_device_get_binding+0x4c>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    4390:	4620      	mov	r0, r4
    4392:	f002 ff09 	bl	71a8 <z_device_ready>
    4396:	2800      	cmp	r0, #0
    4398:	d0f6      	beq.n	4388 <z_impl_device_get_binding+0x2c>
    439a:	6821      	ldr	r1, [r4, #0]
    439c:	4628      	mov	r0, r5
    439e:	f002 fb4e 	bl	6a3e <strcmp>
    43a2:	2800      	cmp	r0, #0
    43a4:	d1f0      	bne.n	4388 <z_impl_device_get_binding+0x2c>
    43a6:	e000      	b.n	43aa <z_impl_device_get_binding+0x4e>
			return dev;
		}
	}

	return NULL;
    43a8:	2400      	movs	r4, #0
}
    43aa:	4620      	mov	r0, r4
    43ac:	bd38      	pop	{r3, r4, r5, pc}
		return NULL;
    43ae:	4604      	mov	r4, r0
    43b0:	e7fb      	b.n	43aa <z_impl_device_get_binding+0x4e>
    43b2:	2400      	movs	r4, #0
    43b4:	e7f9      	b.n	43aa <z_impl_device_get_binding+0x4e>
    43b6:	bf00      	nop
    43b8:	0000782c 	.word	0x0000782c
    43bc:	0000788c 	.word	0x0000788c

000043c0 <reason_to_str>:
	return thread_name;
}

static const char *reason_to_str(unsigned int reason)
{
	switch (reason) {
    43c0:	2804      	cmp	r0, #4
    43c2:	d80c      	bhi.n	43de <reason_to_str+0x1e>
    43c4:	e8df f000 	tbb	[pc, r0]
    43c8:	07050d03 	.word	0x07050d03
    43cc:	09          	.byte	0x09
    43cd:	00          	.byte	0x00
	case K_ERR_STACK_CHK_FAIL:
		return "Stack overflow";
	case K_ERR_KERNEL_OOPS:
		return "Kernel oops";
	case K_ERR_KERNEL_PANIC:
		return "Kernel panic";
    43ce:	4806      	ldr	r0, [pc, #24]	; (43e8 <reason_to_str+0x28>)
    43d0:	4770      	bx	lr
		return "Stack overflow";
    43d2:	4806      	ldr	r0, [pc, #24]	; (43ec <reason_to_str+0x2c>)
    43d4:	4770      	bx	lr
		return "Kernel oops";
    43d6:	4806      	ldr	r0, [pc, #24]	; (43f0 <reason_to_str+0x30>)
    43d8:	4770      	bx	lr
		return "Kernel panic";
    43da:	4806      	ldr	r0, [pc, #24]	; (43f4 <reason_to_str+0x34>)
    43dc:	4770      	bx	lr
	default:
		return "Unknown error";
    43de:	4806      	ldr	r0, [pc, #24]	; (43f8 <reason_to_str+0x38>)
    43e0:	4770      	bx	lr
		return "Unhandled interrupt";
    43e2:	4806      	ldr	r0, [pc, #24]	; (43fc <reason_to_str+0x3c>)
	}
}
    43e4:	4770      	bx	lr
    43e6:	bf00      	nop
    43e8:	00008324 	.word	0x00008324
    43ec:	000082f8 	.word	0x000082f8
    43f0:	00008308 	.word	0x00008308
    43f4:	00008314 	.word	0x00008314
    43f8:	000082d4 	.word	0x000082d4
    43fc:	000082e4 	.word	0x000082e4

00004400 <thread_name_get>:
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    4400:	b130      	cbz	r0, 4410 <thread_name_get+0x10>
{
    4402:	b508      	push	{r3, lr}
	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
    4404:	f002 ff46 	bl	7294 <k_thread_name_get>
	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
    4408:	b120      	cbz	r0, 4414 <thread_name_get+0x14>
    440a:	7803      	ldrb	r3, [r0, #0]
    440c:	b123      	cbz	r3, 4418 <thread_name_get+0x18>
}
    440e:	bd08      	pop	{r3, pc}
		thread_name = "unknown";
    4410:	4802      	ldr	r0, [pc, #8]	; (441c <thread_name_get+0x1c>)
}
    4412:	4770      	bx	lr
		thread_name = "unknown";
    4414:	4801      	ldr	r0, [pc, #4]	; (441c <thread_name_get+0x1c>)
    4416:	e7fa      	b.n	440e <thread_name_get+0xe>
    4418:	4800      	ldr	r0, [pc, #0]	; (441c <thread_name_get+0x1c>)
	return thread_name;
    441a:	e7f8      	b.n	440e <thread_name_get+0xe>
    441c:	00008334 	.word	0x00008334

00004420 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    4420:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4424:	b082      	sub	sp, #8
    4426:	4605      	mov	r5, r0
    4428:	460e      	mov	r6, r1
    442a:	f04f 0320 	mov.w	r3, #32
    442e:	f3ef 8711 	mrs	r7, BASEPRI
    4432:	f383 8811 	msr	BASEPRI, r3
    4436:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
    443a:	f001 f8e3 	bl	5604 <z_impl_k_current_get>
    443e:	4604      	mov	r4, r0
    4440:	4b29      	ldr	r3, [pc, #164]	; (44e8 <z_fatal_error+0xc8>)
    4442:	4a2a      	ldr	r2, [pc, #168]	; (44ec <z_fatal_error+0xcc>)
    4444:	1a9b      	subs	r3, r3, r2
    4446:	08db      	lsrs	r3, r3, #3
			k_current_get() : NULL;

	/* twister looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating twister
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
    4448:	f04f 0800 	mov.w	r8, #0
    444c:	2201      	movs	r2, #1
    444e:	f362 0802 	bfi	r8, r2, #0, #3
    4452:	f36f 08c5 	bfc	r8, #3, #3
    4456:	f363 188f 	bfi	r8, r3, #6, #10
    445a:	4628      	mov	r0, r5
    445c:	f7ff ffb0 	bl	43c0 <reason_to_str>
    4460:	4602      	mov	r2, r0
    4462:	f8ad 8000 	strh.w	r8, [sp]
    4466:	2300      	movs	r3, #0
    4468:	4629      	mov	r1, r5
    446a:	4821      	ldr	r0, [pc, #132]	; (44f0 <z_fatal_error+0xd0>)
    446c:	f7fd f8ce 	bl	160c <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
    4470:	b11e      	cbz	r6, 447a <z_fatal_error+0x5a>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
    4472:	69f3      	ldr	r3, [r6, #28]
    4474:	f3c3 0308 	ubfx	r3, r3, #0, #9
    4478:	bb2b      	cbnz	r3, 44c6 <z_fatal_error+0xa6>
    447a:	4b1b      	ldr	r3, [pc, #108]	; (44e8 <z_fatal_error+0xc8>)
    447c:	4a1b      	ldr	r2, [pc, #108]	; (44ec <z_fatal_error+0xcc>)
    447e:	1a9b      	subs	r3, r3, r2
    4480:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Fault during interrupt handling\n");
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
    4482:	f04f 0800 	mov.w	r8, #0
    4486:	2201      	movs	r2, #1
    4488:	f362 0802 	bfi	r8, r2, #0, #3
    448c:	f36f 08c5 	bfc	r8, #3, #3
    4490:	f363 188f 	bfi	r8, r3, #6, #10
    4494:	4620      	mov	r0, r4
    4496:	f7ff ffb3 	bl	4400 <thread_name_get>
{
	if (IS_ENABLED(CONFIG_LOG_MINIMAL) || IS_ENABLED(CONFIG_LOG2)) {
		return (char *)str;
	}

	return z_log_strdup(str);
    449a:	f7fc ff7b 	bl	1394 <z_log_strdup>
    449e:	4602      	mov	r2, r0
    44a0:	4643      	mov	r3, r8
    44a2:	4621      	mov	r1, r4
    44a4:	4813      	ldr	r0, [pc, #76]	; (44f4 <z_fatal_error+0xd4>)
    44a6:	f7fd f925 	bl	16f4 <log_2>
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    44aa:	4631      	mov	r1, r6
    44ac:	4628      	mov	r0, r5
    44ae:	f7ff fa49 	bl	3944 <k_sys_fatal_error_handler>
	__asm__ volatile(
    44b2:	f387 8811 	msr	BASEPRI, r7
    44b6:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
    44ba:	4620      	mov	r0, r4
    44bc:	f7fe fe6a 	bl	3194 <z_impl_k_thread_abort>
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    44c0:	b002      	add	sp, #8
    44c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    44c6:	4b08      	ldr	r3, [pc, #32]	; (44e8 <z_fatal_error+0xc8>)
    44c8:	4a08      	ldr	r2, [pc, #32]	; (44ec <z_fatal_error+0xcc>)
    44ca:	1a9b      	subs	r3, r3, r2
    44cc:	08db      	lsrs	r3, r3, #3
		LOG_ERR("Fault during interrupt handling\n");
    44ce:	f04f 0100 	mov.w	r1, #0
    44d2:	2201      	movs	r2, #1
    44d4:	f362 0102 	bfi	r1, r2, #0, #3
    44d8:	f36f 01c5 	bfc	r1, #3, #3
    44dc:	f363 118f 	bfi	r1, r3, #6, #10
    44e0:	4805      	ldr	r0, [pc, #20]	; (44f8 <z_fatal_error+0xd8>)
    44e2:	f7fd f943 	bl	176c <log_0>
    44e6:	e7c8      	b.n	447a <z_fatal_error+0x5a>
    44e8:	000079e4 	.word	0x000079e4
    44ec:	000079c4 	.word	0x000079c4
    44f0:	0000833c 	.word	0x0000833c
    44f4:	00008388 	.word	0x00008388
    44f8:	00008364 	.word	0x00008364

000044fc <init_idle_thread>:
/* LCOV_EXCL_STOP */

#if defined(CONFIG_MULTITHREADING)
__boot_func
static void init_idle_thread(int i)
{
    44fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    44fe:	b089      	sub	sp, #36	; 0x24
    4500:	4604      	mov	r4, r0
	struct k_thread *thread = &z_idle_threads[i];
    4502:	4b15      	ldr	r3, [pc, #84]	; (4558 <init_idle_thread+0x5c>)
    4504:	25b0      	movs	r5, #176	; 0xb0
    4506:	fb05 3500 	mla	r5, r5, r0, r3
	k_thread_stack_t *stack = z_idle_stacks[i];
    450a:	4b14      	ldr	r3, [pc, #80]	; (455c <init_idle_thread+0x60>)
    450c:	f44f 76b0 	mov.w	r6, #352	; 0x160
    4510:	fb06 3600 	mla	r6, r6, r0, r3

#ifdef CONFIG_THREAD_NAME
	char tname[8];

	snprintk(tname, 8, "idle %02d", i);
    4514:	af06      	add	r7, sp, #24
    4516:	4603      	mov	r3, r0
    4518:	4a11      	ldr	r2, [pc, #68]	; (4560 <init_idle_thread+0x64>)
    451a:	2108      	movs	r1, #8
    451c:	4638      	mov	r0, r7
    451e:	f001 fb5d 	bl	5bdc <snprintk>
#else
	char *tname = NULL;
#endif /* CONFIG_THREAD_NAME */

	z_setup_new_thread(thread, stack,
			  CONFIG_IDLE_STACK_SIZE, idle, &_kernel.cpus[i],
    4522:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    4526:	480f      	ldr	r0, [pc, #60]	; (4564 <init_idle_thread+0x68>)
    4528:	eb00 04c4 	add.w	r4, r0, r4, lsl #3
	z_setup_new_thread(thread, stack,
    452c:	9705      	str	r7, [sp, #20]
    452e:	2301      	movs	r3, #1
    4530:	9304      	str	r3, [sp, #16]
    4532:	230f      	movs	r3, #15
    4534:	9303      	str	r3, [sp, #12]
    4536:	2300      	movs	r3, #0
    4538:	9302      	str	r3, [sp, #8]
    453a:	9301      	str	r3, [sp, #4]
    453c:	9400      	str	r4, [sp, #0]
    453e:	4b0a      	ldr	r3, [pc, #40]	; (4568 <init_idle_thread+0x6c>)
    4540:	f44f 72a0 	mov.w	r2, #320	; 0x140
    4544:	4631      	mov	r1, r6
    4546:	4628      	mov	r0, r5
    4548:	f000 f95c 	bl	4804 <z_setup_new_thread>
	SYS_PORT_TRACING_FUNC(k_thread, sched_resume, thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    454c:	7b6b      	ldrb	r3, [r5, #13]
    454e:	f023 0304 	bic.w	r3, r3, #4
    4552:	736b      	strb	r3, [r5, #13]
	z_mark_thread_as_started(thread);

#ifdef CONFIG_SMP
	thread->base.is_idle = 1U;
#endif
}
    4554:	b009      	add	sp, #36	; 0x24
    4556:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4558:	20000140 	.word	0x20000140
    455c:	200011c0 	.word	0x200011c0
    4560:	000083a0 	.word	0x000083a0
    4564:	20000a24 	.word	0x20000a24
    4568:	00007307 	.word	0x00007307

0000456c <prepare_multithreading>:
 *
 * @return initial stack pointer for the main thread
 */
__boot_func
static char *prepare_multithreading(void)
{
    456c:	b570      	push	{r4, r5, r6, lr}
    456e:	b086      	sub	sp, #24
	char *stack_ptr;

	/* _kernel.ready_q is all zeroes */
	z_sched_init();
    4570:	f000 ff7a 	bl	5468 <z_sched_init>
	 * - the main thread will be the one to run first
	 * - no other thread is initialized yet and thus their priority fields
	 *   contain garbage, which would prevent the cache loading algorithm
	 *   to work as intended
	 */
	_kernel.ready_q.cache = &z_main_thread;
    4574:	4d1e      	ldr	r5, [pc, #120]	; (45f0 <prepare_multithreading+0x84>)
    4576:	4b1f      	ldr	r3, [pc, #124]	; (45f4 <prepare_multithreading+0x88>)
    4578:	625d      	str	r5, [r3, #36]	; 0x24
#endif
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    457a:	4b1f      	ldr	r3, [pc, #124]	; (45f8 <prepare_multithreading+0x8c>)
    457c:	9305      	str	r3, [sp, #20]
    457e:	2301      	movs	r3, #1
    4580:	9304      	str	r3, [sp, #16]
    4582:	2400      	movs	r4, #0
    4584:	9403      	str	r4, [sp, #12]
    4586:	9402      	str	r4, [sp, #8]
    4588:	9401      	str	r4, [sp, #4]
    458a:	9400      	str	r4, [sp, #0]
    458c:	4b1b      	ldr	r3, [pc, #108]	; (45fc <prepare_multithreading+0x90>)
    458e:	f44f 6280 	mov.w	r2, #1024	; 0x400
    4592:	491b      	ldr	r1, [pc, #108]	; (4600 <prepare_multithreading+0x94>)
    4594:	4628      	mov	r0, r5
    4596:	f000 f935 	bl	4804 <z_setup_new_thread>
    459a:	4606      	mov	r6, r0
    459c:	7b6b      	ldrb	r3, [r5, #13]
    459e:	f023 0304 	bic.w	r3, r3, #4
    45a2:	736b      	strb	r3, [r5, #13]
				       CONFIG_MAIN_STACK_SIZE, bg_thread_main,
				       NULL, NULL, NULL,
				       CONFIG_MAIN_THREAD_PRIORITY,
				       K_ESSENTIAL, "main");
	z_mark_thread_as_started(&z_main_thread);
	z_ready_thread(&z_main_thread);
    45a4:	4628      	mov	r0, r5
    45a6:	f002 ff92 	bl	74ce <z_ready_thread>

	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    45aa:	2c00      	cmp	r4, #0
    45ac:	dd07      	ble.n	45be <prepare_multithreading+0x52>
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    45ae:	4b11      	ldr	r3, [pc, #68]	; (45f4 <prepare_multithreading+0x88>)
    45b0:	f103 0218 	add.w	r2, r3, #24
    45b4:	619a      	str	r2, [r3, #24]
	list->tail = (sys_dnode_t *)list;
    45b6:	61da      	str	r2, [r3, #28]
	}

	initialize_timeouts();

	return stack_ptr;
}
    45b8:	4630      	mov	r0, r6
    45ba:	b006      	add	sp, #24
    45bc:	bd70      	pop	{r4, r5, r6, pc}
		init_idle_thread(i);
    45be:	4620      	mov	r0, r4
    45c0:	f7ff ff9c 	bl	44fc <init_idle_thread>
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    45c4:	4b0f      	ldr	r3, [pc, #60]	; (4604 <prepare_multithreading+0x98>)
    45c6:	22b0      	movs	r2, #176	; 0xb0
    45c8:	fb02 3204 	mla	r2, r2, r4, r3
    45cc:	eb04 0144 	add.w	r1, r4, r4, lsl #1
    45d0:	4b08      	ldr	r3, [pc, #32]	; (45f4 <prepare_multithreading+0x88>)
    45d2:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
    45d6:	60da      	str	r2, [r3, #12]
		_kernel.cpus[i].id = i;
    45d8:	751c      	strb	r4, [r3, #20]
			(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[i]) +
    45da:	eb04 1184 	add.w	r1, r4, r4, lsl #6
    45de:	4a0a      	ldr	r2, [pc, #40]	; (4608 <prepare_multithreading+0x9c>)
    45e0:	eb02 1241 	add.w	r2, r2, r1, lsl #5
    45e4:	f502 6202 	add.w	r2, r2, #2080	; 0x820
		_kernel.cpus[i].irq_stack =
    45e8:	605a      	str	r2, [r3, #4]
	for (int i = 0; i < CONFIG_MP_NUM_CPUS; i++) {
    45ea:	3401      	adds	r4, #1
    45ec:	e7dd      	b.n	45aa <prepare_multithreading+0x3e>
    45ee:	bf00      	nop
    45f0:	200001f0 	.word	0x200001f0
    45f4:	20000a24 	.word	0x20000a24
    45f8:	000083ac 	.word	0x000083ac
    45fc:	00004639 	.word	0x00004639
    4600:	20000da0 	.word	0x20000da0
    4604:	20000140 	.word	0x20000140
    4608:	20001320 	.word	0x20001320

0000460c <switch_to_main_thread>:

__boot_func
static FUNC_NORETURN void switch_to_main_thread(char *stack_ptr)
{
    460c:	b508      	push	{r3, lr}
    460e:	4601      	mov	r1, r0
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    4610:	4a01      	ldr	r2, [pc, #4]	; (4618 <switch_to_main_thread+0xc>)
    4612:	4802      	ldr	r0, [pc, #8]	; (461c <switch_to_main_thread+0x10>)
    4614:	f7fe f8e2 	bl	27dc <arch_switch_to_main_thread>
	 * current fake thread is not on a wait queue or ready queue, so it
	 * will never be rescheduled in.
	 */
	z_swap_unlocked();
#endif
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    4618:	00004639 	.word	0x00004639
    461c:	200001f0 	.word	0x200001f0

00004620 <z_bss_zero>:
{
    4620:	b508      	push	{r3, lr}
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    4622:	4803      	ldr	r0, [pc, #12]	; (4630 <z_bss_zero+0x10>)
    4624:	4a03      	ldr	r2, [pc, #12]	; (4634 <z_bss_zero+0x14>)
    4626:	1a12      	subs	r2, r2, r0
    4628:	2100      	movs	r1, #0
    462a:	f002 fa36 	bl	6a9a <memset>
}
    462e:	bd08      	pop	{r3, pc}
    4630:	20000058 	.word	0x20000058
    4634:	20000a7c 	.word	0x20000a7c

00004638 <bg_thread_main>:
{
    4638:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    463a:	4b0a      	ldr	r3, [pc, #40]	; (4664 <bg_thread_main+0x2c>)
    463c:	2201      	movs	r2, #1
    463e:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    4640:	2002      	movs	r0, #2
    4642:	f7ff fe63 	bl	430c <z_sys_init_run_level>
	boot_banner();
    4646:	f001 fa55 	bl	5af4 <boot_banner>
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    464a:	2003      	movs	r0, #3
    464c:	f7ff fe5e 	bl	430c <z_sys_init_run_level>
	z_init_static_threads();
    4650:	f000 f93c 	bl	48cc <z_init_static_threads>
	main();
    4654:	f7fb ff92 	bl	57c <main>
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    4658:	4a03      	ldr	r2, [pc, #12]	; (4668 <bg_thread_main+0x30>)
    465a:	7b13      	ldrb	r3, [r2, #12]
    465c:	f023 0301 	bic.w	r3, r3, #1
    4660:	7313      	strb	r3, [r2, #12]
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    4662:	bd08      	pop	{r3, pc}
    4664:	20000a78 	.word	0x20000a78
    4668:	200001f0 	.word	0x200001f0

0000466c <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    466c:	b500      	push	{lr}
    466e:	b0ad      	sub	sp, #180	; 0xb4
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
    4670:	f7fc fda6 	bl	11c0 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
    4674:	4b1a      	ldr	r3, [pc, #104]	; (46e0 <z_cstart+0x74>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    4676:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    467a:	4c1a      	ldr	r4, [pc, #104]	; (46e4 <z_cstart+0x78>)
    467c:	6963      	ldr	r3, [r4, #20]
    467e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    4682:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    4684:	23e0      	movs	r3, #224	; 0xe0
    4686:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    468a:	2500      	movs	r5, #0
    468c:	77e5      	strb	r5, [r4, #31]
    468e:	7625      	strb	r5, [r4, #24]
    4690:	7665      	strb	r5, [r4, #25]
    4692:	76a5      	strb	r5, [r4, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    4694:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4696:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    469a:	6263      	str	r3, [r4, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    469c:	f7fe fd10 	bl	30c0 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    46a0:	f7fe f8b2 	bl	2808 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    46a4:	f04f 33ff 	mov.w	r3, #4294967295
    46a8:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    46aa:	62e3      	str	r3, [r4, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
    46ac:	f7fe fe4e 	bl	334c <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    46b0:	f7fe fd86 	bl	31c0 <z_arm_configure_static_mpu_regions>
 *
 * The memory of the dummy thread can be completely uninitialized.
 */
static inline void z_dummy_thread_init(struct k_thread *dummy_thread)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
    46b4:	2401      	movs	r4, #1
    46b6:	f88d 400d 	strb.w	r4, [sp, #13]
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    46ba:	f88d 400c 	strb.w	r4, [sp, #12]
#ifdef CONFIG_THREAD_STACK_INFO
	dummy_thread->stack_info.start = 0U;
    46be:	9526      	str	r5, [sp, #152]	; 0x98
	dummy_thread->stack_info.size = 0U;
    46c0:	9527      	str	r5, [sp, #156]	; 0x9c
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    46c2:	4b09      	ldr	r3, [pc, #36]	; (46e8 <z_cstart+0x7c>)
    46c4:	f8c3 d008 	str.w	sp, [r3, #8]
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    46c8:	f7ff fe14 	bl	42f4 <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    46cc:	4628      	mov	r0, r5
    46ce:	f7ff fe1d 	bl	430c <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    46d2:	4620      	mov	r0, r4
    46d4:	f7ff fe1a 	bl	430c <z_sys_init_run_level>
	timing_init();
	timing_start();
#endif

#ifdef CONFIG_MULTITHREADING
	switch_to_main_thread(prepare_multithreading());
    46d8:	f7ff ff48 	bl	456c <prepare_multithreading>
    46dc:	f7ff ff96 	bl	460c <switch_to_main_thread>
    46e0:	20001b40 	.word	0x20001b40
    46e4:	e000ed00 	.word	0xe000ed00
    46e8:	20000a24 	.word	0x20000a24

000046ec <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
    46ec:	b510      	push	{r4, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    46ee:	4c06      	ldr	r4, [pc, #24]	; (4708 <init_mem_slab_module+0x1c>)
	int rc = 0;
    46f0:	2000      	movs	r0, #0
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    46f2:	4b06      	ldr	r3, [pc, #24]	; (470c <init_mem_slab_module+0x20>)
    46f4:	429c      	cmp	r4, r3
    46f6:	d206      	bcs.n	4706 <init_mem_slab_module+0x1a>
		rc = create_free_list(slab);
    46f8:	4620      	mov	r0, r4
    46fa:	f002 fd62 	bl	71c2 <create_free_list>
		if (rc < 0) {
    46fe:	2800      	cmp	r0, #0
    4700:	db01      	blt.n	4706 <init_mem_slab_module+0x1a>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    4702:	341c      	adds	r4, #28
    4704:	e7f5      	b.n	46f2 <init_mem_slab_module+0x6>
		z_object_init(slab);
	}

out:
	return rc;
}
    4706:	bd10      	pop	{r4, pc}
    4708:	20000030 	.word	0x20000030
    470c:	20000030 	.word	0x20000030

00004710 <k_mem_slab_alloc>:

	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    4710:	b5f0      	push	{r4, r5, r6, r7, lr}
    4712:	b083      	sub	sp, #12
    4714:	460c      	mov	r4, r1
    4716:	461f      	mov	r7, r3
	__asm__ volatile(
    4718:	f04f 0320 	mov.w	r3, #32
    471c:	f3ef 8111 	mrs	r1, BASEPRI
    4720:	f383 8811 	msr	BASEPRI, r3
    4724:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);
	int result;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, alloc, slab, timeout);

	if (slab->free_list != NULL) {
    4728:	6943      	ldr	r3, [r0, #20]
    472a:	b16b      	cbz	r3, 4748 <k_mem_slab_alloc+0x38>
		/* take a free block */
		*mem = slab->free_list;
    472c:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    472e:	6943      	ldr	r3, [r0, #20]
    4730:	681b      	ldr	r3, [r3, #0]
    4732:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    4734:	6983      	ldr	r3, [r0, #24]
    4736:	3301      	adds	r3, #1
    4738:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    473a:	2000      	movs	r0, #0
	__asm__ volatile(
    473c:	f381 8811 	msr	BASEPRI, r1
    4740:	f3bf 8f6f 	isb	sy
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, alloc, slab, timeout, result);

	k_spin_unlock(&slab->lock, key);

	return result;
}
    4744:	b003      	add	sp, #12
    4746:	bdf0      	pop	{r4, r5, r6, r7, pc}
    4748:	4616      	mov	r6, r2
    474a:	f100 0508 	add.w	r5, r0, #8
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT) ||
    474e:	ea56 0307 	orrs.w	r3, r6, r7
    4752:	d104      	bne.n	475e <k_mem_slab_alloc+0x4e>
		*mem = NULL;
    4754:	2300      	movs	r3, #0
    4756:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    4758:	f06f 000b 	mvn.w	r0, #11
    475c:	e7ee      	b.n	473c <k_mem_slab_alloc+0x2c>
		result = z_pend_curr(&slab->lock, key, &slab->wait_q, timeout);
    475e:	e9cd 6700 	strd	r6, r7, [sp]
    4762:	4602      	mov	r2, r0
    4764:	4628      	mov	r0, r5
    4766:	f000 fc67 	bl	5038 <z_pend_curr>
		if (result == 0) {
    476a:	2800      	cmp	r0, #0
    476c:	d1ea      	bne.n	4744 <k_mem_slab_alloc+0x34>
			*mem = _current->base.swap_data;
    476e:	4b02      	ldr	r3, [pc, #8]	; (4778 <k_mem_slab_alloc+0x68>)
    4770:	689b      	ldr	r3, [r3, #8]
    4772:	695b      	ldr	r3, [r3, #20]
    4774:	6023      	str	r3, [r4, #0]
		return result;
    4776:	e7e5      	b.n	4744 <k_mem_slab_alloc+0x34>
    4778:	20000a24 	.word	0x20000a24

0000477c <z_thread_monitor_exit>:
	__asm__ volatile(
    477c:	f04f 0320 	mov.w	r3, #32
    4780:	f3ef 8111 	mrs	r1, BASEPRI
    4784:	f383 8811 	msr	BASEPRI, r3
    4788:	f3bf 8f6f 	isb	sy
 */
void z_thread_monitor_exit(struct k_thread *thread)
{
	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	if (thread == _kernel.threads) {
    478c:	4b0a      	ldr	r3, [pc, #40]	; (47b8 <z_thread_monitor_exit+0x3c>)
    478e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    4790:	4283      	cmp	r3, r0
    4792:	d104      	bne.n	479e <z_thread_monitor_exit+0x22>
		_kernel.threads = _kernel.threads->next_thread;
    4794:	6f1a      	ldr	r2, [r3, #112]	; 0x70
    4796:	4b08      	ldr	r3, [pc, #32]	; (47b8 <z_thread_monitor_exit+0x3c>)
    4798:	631a      	str	r2, [r3, #48]	; 0x30
    479a:	e007      	b.n	47ac <z_thread_monitor_exit+0x30>
		struct k_thread *prev_thread;

		prev_thread = _kernel.threads;
		while ((prev_thread != NULL) &&
			(thread != prev_thread->next_thread)) {
			prev_thread = prev_thread->next_thread;
    479c:	4613      	mov	r3, r2
		while ((prev_thread != NULL) &&
    479e:	b113      	cbz	r3, 47a6 <z_thread_monitor_exit+0x2a>
			(thread != prev_thread->next_thread)) {
    47a0:	6f1a      	ldr	r2, [r3, #112]	; 0x70
		while ((prev_thread != NULL) &&
    47a2:	4282      	cmp	r2, r0
    47a4:	d1fa      	bne.n	479c <z_thread_monitor_exit+0x20>
		}
		if (prev_thread != NULL) {
    47a6:	b10b      	cbz	r3, 47ac <z_thread_monitor_exit+0x30>
			prev_thread->next_thread = thread->next_thread;
    47a8:	6f02      	ldr	r2, [r0, #112]	; 0x70
    47aa:	671a      	str	r2, [r3, #112]	; 0x70
	__asm__ volatile(
    47ac:	f381 8811 	msr	BASEPRI, r1
    47b0:	f3bf 8f6f 	isb	sy
		}
	}

	k_spin_unlock(&z_thread_monitor_lock, key);
}
    47b4:	4770      	bx	lr
    47b6:	bf00      	nop
    47b8:	20000a24 	.word	0x20000a24

000047bc <z_impl_k_thread_name_set>:
#endif

int z_impl_k_thread_name_set(struct k_thread *thread, const char *value)
{
    47bc:	b510      	push	{r4, lr}
#ifdef CONFIG_THREAD_NAME
	if (thread == NULL) {
    47be:	4604      	mov	r4, r0
    47c0:	b140      	cbz	r0, 47d4 <z_impl_k_thread_name_set+0x18>
		thread = _current;
	}

	strncpy(thread->name, value, CONFIG_THREAD_MAX_NAME_LEN);
    47c2:	2220      	movs	r2, #32
    47c4:	f104 0074 	add.w	r0, r4, #116	; 0x74
    47c8:	f002 f90d 	bl	69e6 <strncpy>
	thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    47cc:	2000      	movs	r0, #0
    47ce:	f884 0093 	strb.w	r0, [r4, #147]	; 0x93

	SYS_PORT_TRACING_OBJ_FUNC(k_thread, name_set, thread, -ENOSYS);

	return -ENOSYS;
#endif /* CONFIG_THREAD_NAME */
}
    47d2:	bd10      	pop	{r4, pc}
		thread = _current;
    47d4:	4b01      	ldr	r3, [pc, #4]	; (47dc <z_impl_k_thread_name_set+0x20>)
    47d6:	689c      	ldr	r4, [r3, #8]
    47d8:	e7f3      	b.n	47c2 <z_impl_k_thread_name_set+0x6>
    47da:	bf00      	nop
    47dc:	20000a24 	.word	0x20000a24

000047e0 <schedule_new_thread>:
#endif
#endif

#ifdef CONFIG_MULTITHREADING
static void schedule_new_thread(struct k_thread *thread, k_timeout_t delay)
{
    47e0:	b538      	push	{r3, r4, r5, lr}
    47e2:	4614      	mov	r4, r2
    47e4:	461d      	mov	r5, r3
#ifdef CONFIG_SYS_CLOCK_EXISTS
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    47e6:	ea54 0305 	orrs.w	r3, r4, r5
    47ea:	d102      	bne.n	47f2 <schedule_new_thread+0x12>
	z_impl_k_thread_start(thread);
    47ec:	f002 fd54 	bl	7298 <z_impl_k_thread_start>
	}
#else
	ARG_UNUSED(delay);
	k_thread_start(thread);
#endif
}
    47f0:	bd38      	pop	{r3, r4, r5, pc}

extern void z_thread_timeout(struct _timeout *timeout);

static inline void z_add_thread_timeout(struct k_thread *thread, k_timeout_t ticks)
{
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    47f2:	462b      	mov	r3, r5
    47f4:	4902      	ldr	r1, [pc, #8]	; (4800 <schedule_new_thread+0x20>)
    47f6:	3018      	adds	r0, #24
    47f8:	f000 ffb6 	bl	5768 <z_add_timeout>
    47fc:	e7f8      	b.n	47f0 <schedule_new_thread+0x10>
    47fe:	bf00      	nop
    4800:	00007507 	.word	0x00007507

00004804 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    4804:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4808:	b085      	sub	sp, #20
    480a:	4604      	mov	r4, r0
    480c:	460f      	mov	r7, r1
    480e:	4615      	mov	r5, r2
    4810:	461e      	mov	r6, r3
    4812:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
    4816:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    481a:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    481e:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
	SYS_DLIST_FOR_EACH_CONTAINER(&((wq)->waitq), thread_ptr, \
				     base.qnode_dlist)

static inline void z_waitq_init(_wait_q_t *w)
{
	sys_dlist_init(&w->waitq);
    4822:	f100 0358 	add.w	r3, r0, #88	; 0x58
	list->head = (sys_dnode_t *)list;
    4826:	6583      	str	r3, [r0, #88]	; 0x58
	list->tail = (sys_dnode_t *)list;
    4828:	65c3      	str	r3, [r0, #92]	; 0x5c
	k_object_access_grant(new_thread, new_thread);
#endif
	z_waitq_init(&new_thread->join_queue);

	/* Initialize various struct k_thread members */
	z_init_thread_base(&new_thread->base, prio, _THREAD_PRESTART, options);
    482a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    482c:	2204      	movs	r2, #4
    482e:	9911      	ldr	r1, [sp, #68]	; 0x44
    4830:	f002 fd36 	bl	72a0 <z_init_thread_base>
	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
    4834:	462a      	mov	r2, r5
    4836:	4639      	mov	r1, r7
    4838:	4620      	mov	r0, r4
    483a:	f002 fd13 	bl	7264 <setup_thread_stack>
    483e:	4605      	mov	r5, r0
	 */
	__ASSERT_NO_MSG(arch_mem_coherent(new_thread));
	__ASSERT_NO_MSG(!arch_mem_coherent(stack));
#endif

	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    4840:	f8cd 8008 	str.w	r8, [sp, #8]
    4844:	f8cd 9004 	str.w	r9, [sp, #4]
    4848:	f8cd a000 	str.w	sl, [sp]
    484c:	4633      	mov	r3, r6
    484e:	4602      	mov	r2, r0
    4850:	4639      	mov	r1, r7
    4852:	4620      	mov	r0, r4
    4854:	f7fd ff72 	bl	273c <arch_new_thread>

	/* static threads overwrite it afterwards with real value */
	new_thread->init_data = NULL;
    4858:	2300      	movs	r3, #0
    485a:	6563      	str	r3, [r4, #84]	; 0x54
#ifdef CONFIG_THREAD_CUSTOM_DATA
	/* Initialize custom data field (value is opaque to kernel) */
	new_thread->custom_data = NULL;
#endif
#ifdef CONFIG_THREAD_MONITOR
	new_thread->entry.pEntry = entry;
    485c:	6626      	str	r6, [r4, #96]	; 0x60
	new_thread->entry.parameter1 = p1;
    485e:	f8c4 a064 	str.w	sl, [r4, #100]	; 0x64
	new_thread->entry.parameter2 = p2;
    4862:	f8c4 9068 	str.w	r9, [r4, #104]	; 0x68
	new_thread->entry.parameter3 = p3;
    4866:	f8c4 806c 	str.w	r8, [r4, #108]	; 0x6c
	__asm__ volatile(
    486a:	f04f 0320 	mov.w	r3, #32
    486e:	f3ef 8211 	mrs	r2, BASEPRI
    4872:	f383 8811 	msr	BASEPRI, r3
    4876:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&z_thread_monitor_lock);

	new_thread->next_thread = _kernel.threads;
    487a:	4b13      	ldr	r3, [pc, #76]	; (48c8 <z_setup_new_thread+0xc4>)
    487c:	6b19      	ldr	r1, [r3, #48]	; 0x30
    487e:	6721      	str	r1, [r4, #112]	; 0x70
	_kernel.threads = new_thread;
    4880:	631c      	str	r4, [r3, #48]	; 0x30
	__asm__ volatile(
    4882:	f382 8811 	msr	BASEPRI, r2
    4886:	f3bf 8f6f 	isb	sy
	k_spin_unlock(&z_thread_monitor_lock, key);
#endif
#ifdef CONFIG_THREAD_NAME
	if (name != NULL) {
    488a:	f1bb 0f00 	cmp.w	fp, #0
    488e:	d013      	beq.n	48b8 <z_setup_new_thread+0xb4>
		strncpy(new_thread->name, name,
    4890:	221f      	movs	r2, #31
    4892:	4659      	mov	r1, fp
    4894:	f104 0074 	add.w	r0, r4, #116	; 0x74
    4898:	f002 f8a5 	bl	69e6 <strncpy>
			CONFIG_THREAD_MAX_NAME_LEN - 1);
		/* Ensure NULL termination, truncate if longer */
		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
    489c:	2300      	movs	r3, #0
    489e:	f884 3093 	strb.w	r3, [r4, #147]	; 0x93
#ifdef CONFIG_SCHED_CPU_MASK
	new_thread->base.cpu_mask = -1;
#endif
#ifdef CONFIG_ARCH_HAS_CUSTOM_SWAP_TO_MAIN
	/* _current may be null if the dummy thread is not used */
	if (!_current) {
    48a2:	4b09      	ldr	r3, [pc, #36]	; (48c8 <z_setup_new_thread+0xc4>)
    48a4:	689b      	ldr	r3, [r3, #8]
    48a6:	b15b      	cbz	r3, 48c0 <z_setup_new_thread+0xbc>
	}
#endif
#ifdef CONFIG_SCHED_DEADLINE
	new_thread->base.prio_deadline = 0;
#endif
	new_thread->resource_pool = _current->resource_pool;
    48a8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
    48ac:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
#ifdef CONFIG_THREAD_RUNTIME_STATS
	memset(&new_thread->rt_stats, 0, sizeof(new_thread->rt_stats));
#endif

	return stack_ptr;
}
    48b0:	4628      	mov	r0, r5
    48b2:	b005      	add	sp, #20
    48b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		new_thread->name[0] = '\0';
    48b8:	2300      	movs	r3, #0
    48ba:	f884 3074 	strb.w	r3, [r4, #116]	; 0x74
    48be:	e7f0      	b.n	48a2 <z_setup_new_thread+0x9e>
		new_thread->resource_pool = NULL;
    48c0:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4
		return stack_ptr;
    48c4:	e7f4      	b.n	48b0 <z_setup_new_thread+0xac>
    48c6:	bf00      	nop
    48c8:	20000a24 	.word	0x20000a24

000048cc <z_init_static_threads>:
	}
}
#endif /* CONFIG_USERSPACE */

void z_init_static_threads(void)
{
    48cc:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
    48d0:	b086      	sub	sp, #24
	_FOREACH_STATIC_THREAD(thread_data) {
    48d2:	4c23      	ldr	r4, [pc, #140]	; (4960 <z_init_static_threads+0x94>)
    48d4:	4b23      	ldr	r3, [pc, #140]	; (4964 <z_init_static_threads+0x98>)
    48d6:	429c      	cmp	r4, r3
    48d8:	d215      	bcs.n	4906 <z_init_static_threads+0x3a>
		z_setup_new_thread(
    48da:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    48dc:	9305      	str	r3, [sp, #20]
    48de:	6a23      	ldr	r3, [r4, #32]
    48e0:	9304      	str	r3, [sp, #16]
    48e2:	69e3      	ldr	r3, [r4, #28]
    48e4:	9303      	str	r3, [sp, #12]
    48e6:	69a3      	ldr	r3, [r4, #24]
    48e8:	9302      	str	r3, [sp, #8]
    48ea:	6963      	ldr	r3, [r4, #20]
    48ec:	9301      	str	r3, [sp, #4]
    48ee:	6923      	ldr	r3, [r4, #16]
    48f0:	9300      	str	r3, [sp, #0]
    48f2:	68e3      	ldr	r3, [r4, #12]
    48f4:	68a2      	ldr	r2, [r4, #8]
    48f6:	6861      	ldr	r1, [r4, #4]
    48f8:	6820      	ldr	r0, [r4, #0]
    48fa:	f7ff ff83 	bl	4804 <z_setup_new_thread>
			thread_data->init_p3,
			thread_data->init_prio,
			thread_data->init_options,
			thread_data->init_name);

		thread_data->init_thread->init_data = thread_data;
    48fe:	6823      	ldr	r3, [r4, #0]
    4900:	655c      	str	r4, [r3, #84]	; 0x54
	_FOREACH_STATIC_THREAD(thread_data) {
    4902:	3430      	adds	r4, #48	; 0x30
    4904:	e7e6      	b.n	48d4 <z_init_static_threads+0x8>
	 * until they are all started.
	 *
	 * Note that static threads defined using the legacy API have a
	 * delay of K_FOREVER.
	 */
	k_sched_lock();
    4906:	f000 fb3d 	bl	4f84 <k_sched_lock>
	_FOREACH_STATIC_THREAD(thread_data) {
    490a:	4c15      	ldr	r4, [pc, #84]	; (4960 <z_init_static_threads+0x94>)
    490c:	e01b      	b.n	4946 <z_init_static_threads+0x7a>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
			schedule_new_thread(thread_data->init_thread,
    490e:	6826      	ldr	r6, [r4, #0]
					    K_MSEC(thread_data->init_delay));
    4910:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    4914:	ea4f 79e3 	mov.w	r9, r3, asr #31
		} else {
			return (t * to_hz + off) / from_hz;
    4918:	ea4f 31c9 	mov.w	r1, r9, lsl #15
    491c:	ea41 4153 	orr.w	r1, r1, r3, lsr #17
    4920:	03d8      	lsls	r0, r3, #15
    4922:	f240 35e7 	movw	r5, #999	; 0x3e7
    4926:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    492a:	2300      	movs	r3, #0
    492c:	1940      	adds	r0, r0, r5
    492e:	f04f 0500 	mov.w	r5, #0
    4932:	eb45 0101 	adc.w	r1, r5, r1
    4936:	f7fb fbd1 	bl	dc <__aeabi_uldivmod>
    493a:	4602      	mov	r2, r0
    493c:	460b      	mov	r3, r1
			schedule_new_thread(thread_data->init_thread,
    493e:	4630      	mov	r0, r6
    4940:	f7ff ff4e 	bl	47e0 <schedule_new_thread>
	_FOREACH_STATIC_THREAD(thread_data) {
    4944:	3430      	adds	r4, #48	; 0x30
    4946:	4b07      	ldr	r3, [pc, #28]	; (4964 <z_init_static_threads+0x98>)
    4948:	429c      	cmp	r4, r3
    494a:	d204      	bcs.n	4956 <z_init_static_threads+0x8a>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    494c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    494e:	f1b3 3fff 	cmp.w	r3, #4294967295
    4952:	d0f7      	beq.n	4944 <z_init_static_threads+0x78>
    4954:	e7db      	b.n	490e <z_init_static_threads+0x42>
		}
	}
	k_sched_unlock();
    4956:	f000 fbc5 	bl	50e4 <k_sched_unlock>
}
    495a:	b006      	add	sp, #24
    495c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}
    4960:	20000030 	.word	0x20000030
    4964:	20000030 	.word	0x20000030

00004968 <pm_save_idle>:
 *
 * Sets the kernel data structure idle field to either a positive value or
 * K_FOREVER.
 */
static void pm_save_idle(void)
{
    4968:	b508      	push	{r3, lr}
#ifdef CONFIG_PM
	int32_t ticks = z_get_next_timeout_expiry();
    496a:	f002 febe 	bl	76ea <z_get_next_timeout_expiry>
	_kernel.idle = ticks;
    496e:	4b04      	ldr	r3, [pc, #16]	; (4980 <pm_save_idle+0x18>)
    4970:	6218      	str	r0, [r3, #32]
	 * before exiting. This is because the kernel does not do its own idle
	 * processing in those cases i.e. skips k_cpu_idle(). The kernel's
	 * idle processing re-enables interrupts which is essential for
	 * the kernel's scheduling logic.
	 */
	if (pm_system_suspend(ticks) == PM_STATE_ACTIVE) {
    4972:	f7fd fb1b 	bl	1fac <pm_system_suspend>
    4976:	b100      	cbz	r0, 497a <pm_save_idle+0x12>
		k_cpu_idle();
	}
#endif
}
    4978:	bd08      	pop	{r3, pc}
	arch_cpu_idle();
    497a:	f7fd ff4b 	bl	2814 <arch_cpu_idle>
    497e:	e7fb      	b.n	4978 <pm_save_idle+0x10>
    4980:	20000a24 	.word	0x20000a24

00004984 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    4984:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4988:	b083      	sub	sp, #12
    498a:	4604      	mov	r4, r0
    498c:	461d      	mov	r5, r3
	__asm__ volatile(
    498e:	f04f 0320 	mov.w	r3, #32
    4992:	f3ef 8711 	mrs	r7, BASEPRI
    4996:	f383 8811 	msr	BASEPRI, r3
    499a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, lock, mutex, timeout);

	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    499e:	68c1      	ldr	r1, [r0, #12]
    49a0:	b999      	cbnz	r1, 49ca <z_impl_k_mutex_lock+0x46>

		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
					_current->base.prio :
    49a2:	2900      	cmp	r1, #0
    49a4:	d14f      	bne.n	4a46 <z_impl_k_mutex_lock+0xc2>
    49a6:	4b3a      	ldr	r3, [pc, #232]	; (4a90 <z_impl_k_mutex_lock+0x10c>)
    49a8:	689b      	ldr	r3, [r3, #8]
    49aa:	f993 300e 	ldrsb.w	r3, [r3, #14]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    49ae:	6123      	str	r3, [r4, #16]
					mutex->owner_orig_prio;

		mutex->lock_count++;
    49b0:	3101      	adds	r1, #1
    49b2:	60e1      	str	r1, [r4, #12]
		mutex->owner = _current;
    49b4:	4b36      	ldr	r3, [pc, #216]	; (4a90 <z_impl_k_mutex_lock+0x10c>)
    49b6:	689b      	ldr	r3, [r3, #8]
    49b8:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
    49ba:	f387 8811 	msr	BASEPRI, r7
    49be:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&lock, key);

		SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, 0);

		return 0;
    49c2:	2000      	movs	r0, #0
	}

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, lock, mutex, timeout, -EAGAIN);

	return -EAGAIN;
}
    49c4:	b003      	add	sp, #12
    49c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    49ca:	4616      	mov	r6, r2
	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    49cc:	6882      	ldr	r2, [r0, #8]
    49ce:	4b30      	ldr	r3, [pc, #192]	; (4a90 <z_impl_k_mutex_lock+0x10c>)
    49d0:	689b      	ldr	r3, [r3, #8]
    49d2:	429a      	cmp	r2, r3
    49d4:	d0e5      	beq.n	49a2 <z_impl_k_mutex_lock+0x1e>
	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    49d6:	ea55 0106 	orrs.w	r1, r5, r6
    49da:	bf0c      	ite	eq
    49dc:	f04f 0801 	moveq.w	r8, #1
    49e0:	f04f 0800 	movne.w	r8, #0
    49e4:	d031      	beq.n	4a4a <z_impl_k_mutex_lock+0xc6>
					    mutex->owner->base.prio);
    49e6:	f992 900e 	ldrsb.w	r9, [r2, #14]
	new_prio = new_prio_for_inheritance(_current->base.prio,
    49ea:	4649      	mov	r1, r9
    49ec:	f993 000e 	ldrsb.w	r0, [r3, #14]
    49f0:	f002 fc95 	bl	731e <new_prio_for_inheritance>
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    49f4:	4581      	cmp	r9, r0
    49f6:	dc2f      	bgt.n	4a58 <z_impl_k_mutex_lock+0xd4>
	bool resched = false;
    49f8:	f04f 0900 	mov.w	r9, #0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    49fc:	9600      	str	r6, [sp, #0]
    49fe:	9501      	str	r5, [sp, #4]
    4a00:	4622      	mov	r2, r4
    4a02:	4639      	mov	r1, r7
    4a04:	4823      	ldr	r0, [pc, #140]	; (4a94 <z_impl_k_mutex_lock+0x110>)
    4a06:	f000 fb17 	bl	5038 <z_pend_curr>
	if (got_mutex == 0) {
    4a0a:	2800      	cmp	r0, #0
    4a0c:	d0da      	beq.n	49c4 <z_impl_k_mutex_lock+0x40>
	__asm__ volatile(
    4a0e:	f04f 0320 	mov.w	r3, #32
    4a12:	f3ef 8511 	mrs	r5, BASEPRI
    4a16:	f383 8811 	msr	BASEPRI, r3
    4a1a:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    4a1e:	6823      	ldr	r3, [r4, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    4a20:	429c      	cmp	r4, r3
    4a22:	d01f      	beq.n	4a64 <z_impl_k_mutex_lock+0xe0>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    4a24:	b1f3      	cbz	r3, 4a64 <z_impl_k_mutex_lock+0xe0>
    4a26:	6921      	ldr	r1, [r4, #16]
    4a28:	f993 000e 	ldrsb.w	r0, [r3, #14]
    4a2c:	f002 fc77 	bl	731e <new_prio_for_inheritance>
    4a30:	4601      	mov	r1, r0
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    4a32:	4620      	mov	r0, r4
    4a34:	f002 fc7e 	bl	7334 <adjust_owner_prio>
    4a38:	b9b0      	cbnz	r0, 4a68 <z_impl_k_mutex_lock+0xe4>
    4a3a:	f1b9 0f00 	cmp.w	r9, #0
    4a3e:	d015      	beq.n	4a6c <z_impl_k_mutex_lock+0xe8>
    4a40:	f04f 0801 	mov.w	r8, #1
    4a44:	e012      	b.n	4a6c <z_impl_k_mutex_lock+0xe8>
					_current->base.prio :
    4a46:	6923      	ldr	r3, [r4, #16]
    4a48:	e7b1      	b.n	49ae <z_impl_k_mutex_lock+0x2a>
	__asm__ volatile(
    4a4a:	f387 8811 	msr	BASEPRI, r7
    4a4e:	f3bf 8f6f 	isb	sy
		return -EBUSY;
    4a52:	f06f 000f 	mvn.w	r0, #15
    4a56:	e7b5      	b.n	49c4 <z_impl_k_mutex_lock+0x40>
		resched = adjust_owner_prio(mutex, new_prio);
    4a58:	4601      	mov	r1, r0
    4a5a:	4620      	mov	r0, r4
    4a5c:	f002 fc6a 	bl	7334 <adjust_owner_prio>
    4a60:	4681      	mov	r9, r0
    4a62:	e7cb      	b.n	49fc <z_impl_k_mutex_lock+0x78>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    4a64:	6921      	ldr	r1, [r4, #16]
    4a66:	e7e4      	b.n	4a32 <z_impl_k_mutex_lock+0xae>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    4a68:	f04f 0801 	mov.w	r8, #1
	if (resched) {
    4a6c:	f1b8 0f00 	cmp.w	r8, #0
    4a70:	d106      	bne.n	4a80 <z_impl_k_mutex_lock+0xfc>
    4a72:	f385 8811 	msr	BASEPRI, r5
    4a76:	f3bf 8f6f 	isb	sy
	return -EAGAIN;
    4a7a:	f06f 000a 	mvn.w	r0, #10
    4a7e:	e7a1      	b.n	49c4 <z_impl_k_mutex_lock+0x40>
		z_reschedule(&lock, key);
    4a80:	4629      	mov	r1, r5
    4a82:	4804      	ldr	r0, [pc, #16]	; (4a94 <z_impl_k_mutex_lock+0x110>)
    4a84:	f000 fa62 	bl	4f4c <z_reschedule>
	return -EAGAIN;
    4a88:	f06f 000a 	mvn.w	r0, #10
    4a8c:	e79a      	b.n	49c4 <z_impl_k_mutex_lock+0x40>
    4a8e:	bf00      	nop
    4a90:	20000a24 	.word	0x20000a24
    4a94:	20000a58 	.word	0x20000a58

00004a98 <z_impl_k_mutex_unlock>:

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mutex, unlock, mutex);

	CHECKIF(mutex->owner == NULL) {
    4a98:	6882      	ldr	r2, [r0, #8]
    4a9a:	2a00      	cmp	r2, #0
    4a9c:	d035      	beq.n	4b0a <z_impl_k_mutex_unlock+0x72>
{
    4a9e:	b538      	push	{r3, r4, r5, lr}
    4aa0:	4604      	mov	r4, r0
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    4aa2:	4b1d      	ldr	r3, [pc, #116]	; (4b18 <z_impl_k_mutex_unlock+0x80>)
    4aa4:	689b      	ldr	r3, [r3, #8]
    4aa6:	429a      	cmp	r2, r3
    4aa8:	d132      	bne.n	4b10 <z_impl_k_mutex_unlock+0x78>
static inline void z_sched_lock(void)
{
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1U, "");

	--_current->base.sched_locked;
    4aaa:	7bda      	ldrb	r2, [r3, #15]
    4aac:	3a01      	subs	r2, #1
    4aae:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count > 1U) {
    4ab0:	68c3      	ldr	r3, [r0, #12]
    4ab2:	2b01      	cmp	r3, #1
    4ab4:	d905      	bls.n	4ac2 <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
    4ab6:	3b01      	subs	r3, #1
    4ab8:	60c3      	str	r3, [r0, #12]


k_mutex_unlock_return:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mutex, unlock, mutex, 0);

	k_sched_unlock();
    4aba:	f000 fb13 	bl	50e4 <k_sched_unlock>

	return 0;
    4abe:	2000      	movs	r0, #0
}
    4ac0:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    4ac2:	f04f 0320 	mov.w	r3, #32
    4ac6:	f3ef 8511 	mrs	r5, BASEPRI
    4aca:	f383 8811 	msr	BASEPRI, r3
    4ace:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    4ad2:	6901      	ldr	r1, [r0, #16]
    4ad4:	f002 fc2e 	bl	7334 <adjust_owner_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    4ad8:	4620      	mov	r0, r4
    4ada:	f002 fd6f 	bl	75bc <z_unpend_first_thread>
	mutex->owner = new_owner;
    4ade:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    4ae0:	b160      	cbz	r0, 4afc <z_impl_k_mutex_unlock+0x64>
		mutex->owner_orig_prio = new_owner->base.prio;
    4ae2:	f990 300e 	ldrsb.w	r3, [r0, #14]
    4ae6:	6123      	str	r3, [r4, #16]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    4ae8:	2300      	movs	r3, #0
    4aea:	f8c0 30ac 	str.w	r3, [r0, #172]	; 0xac
		z_ready_thread(new_owner);
    4aee:	f002 fcee 	bl	74ce <z_ready_thread>
		z_reschedule(&lock, key);
    4af2:	4629      	mov	r1, r5
    4af4:	4809      	ldr	r0, [pc, #36]	; (4b1c <z_impl_k_mutex_unlock+0x84>)
    4af6:	f000 fa29 	bl	4f4c <z_reschedule>
    4afa:	e7de      	b.n	4aba <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
    4afc:	2300      	movs	r3, #0
    4afe:	60e3      	str	r3, [r4, #12]
	__asm__ volatile(
    4b00:	f385 8811 	msr	BASEPRI, r5
    4b04:	f3bf 8f6f 	isb	sy
    4b08:	e7d7      	b.n	4aba <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
    4b0a:	f06f 0015 	mvn.w	r0, #21
}
    4b0e:	4770      	bx	lr
		return -EPERM;
    4b10:	f04f 30ff 	mov.w	r0, #4294967295
    4b14:	e7d4      	b.n	4ac0 <z_impl_k_mutex_unlock+0x28>
    4b16:	bf00      	nop
    4b18:	20000a24 	.word	0x20000a24
    4b1c:	20000a58 	.word	0x20000a58

00004b20 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    4b20:	b538      	push	{r3, r4, r5, lr}
    4b22:	4604      	mov	r4, r0
	__asm__ volatile(
    4b24:	f04f 0320 	mov.w	r3, #32
    4b28:	f3ef 8511 	mrs	r5, BASEPRI
    4b2c:	f383 8811 	msr	BASEPRI, r3
    4b30:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, give, sem);

	thread = z_unpend_first_thread(&sem->wait_q);
    4b34:	f002 fd42 	bl	75bc <z_unpend_first_thread>

	if (thread != NULL) {
    4b38:	b148      	cbz	r0, 4b4e <z_impl_k_sem_give+0x2e>
    4b3a:	2200      	movs	r2, #0
    4b3c:	f8c0 20ac 	str.w	r2, [r0, #172]	; 0xac
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    4b40:	f002 fcc5 	bl	74ce <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    4b44:	4629      	mov	r1, r5
    4b46:	4807      	ldr	r0, [pc, #28]	; (4b64 <z_impl_k_sem_give+0x44>)
    4b48:	f000 fa00 	bl	4f4c <z_reschedule>

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, give, sem);
}
    4b4c:	bd38      	pop	{r3, r4, r5, pc}
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4b4e:	68a3      	ldr	r3, [r4, #8]
    4b50:	68e2      	ldr	r2, [r4, #12]
    4b52:	4293      	cmp	r3, r2
    4b54:	d003      	beq.n	4b5e <z_impl_k_sem_give+0x3e>
    4b56:	2201      	movs	r2, #1
    4b58:	4413      	add	r3, r2
    4b5a:	60a3      	str	r3, [r4, #8]
}
    4b5c:	e7f2      	b.n	4b44 <z_impl_k_sem_give+0x24>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    4b5e:	2200      	movs	r2, #0
    4b60:	e7fa      	b.n	4b58 <z_impl_k_sem_give+0x38>
    4b62:	bf00      	nop
    4b64:	20000a58 	.word	0x20000a58

00004b68 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    4b68:	b530      	push	{r4, r5, lr}
    4b6a:	b083      	sub	sp, #12
    4b6c:	461d      	mov	r5, r3
    4b6e:	f04f 0320 	mov.w	r3, #32
    4b72:	f3ef 8111 	mrs	r1, BASEPRI
    4b76:	f383 8811 	msr	BASEPRI, r3
    4b7a:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_sem, take, sem, timeout);

	if (likely(sem->count > 0U)) {
    4b7e:	6883      	ldr	r3, [r0, #8]
    4b80:	b143      	cbz	r3, 4b94 <z_impl_k_sem_take+0x2c>
		sem->count--;
    4b82:	3b01      	subs	r3, #1
    4b84:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
    4b86:	f381 8811 	msr	BASEPRI, r1
    4b8a:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    4b8e:	2000      	movs	r0, #0

out:
	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_sem, take, sem, timeout, ret);

	return ret;
}
    4b90:	b003      	add	sp, #12
    4b92:	bd30      	pop	{r4, r5, pc}
    4b94:	4614      	mov	r4, r2
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    4b96:	ea54 0305 	orrs.w	r3, r4, r5
    4b9a:	d006      	beq.n	4baa <z_impl_k_sem_take+0x42>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    4b9c:	e9cd 4500 	strd	r4, r5, [sp]
    4ba0:	4602      	mov	r2, r0
    4ba2:	4805      	ldr	r0, [pc, #20]	; (4bb8 <z_impl_k_sem_take+0x50>)
    4ba4:	f000 fa48 	bl	5038 <z_pend_curr>
	return ret;
    4ba8:	e7f2      	b.n	4b90 <z_impl_k_sem_take+0x28>
    4baa:	f381 8811 	msr	BASEPRI, r1
    4bae:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    4bb2:	f06f 000f 	mvn.w	r0, #15
    4bb6:	e7eb      	b.n	4b90 <z_impl_k_sem_take+0x28>
    4bb8:	20000a58 	.word	0x20000a58

00004bbc <submit_to_queue_locked>:
 * @retval -EINVAL if no queue is provided
 * @retval -ENODEV if the queue is not started
 */
static int submit_to_queue_locked(struct k_work *work,
				  struct k_work_q **queuep)
{
    4bbc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4bbe:	460d      	mov	r5, r1
	return (*flagp & BIT(bit)) != 0U;
    4bc0:	68c3      	ldr	r3, [r0, #12]
	int ret = 0;

	if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    4bc2:	f013 0f02 	tst.w	r3, #2
    4bc6:	d15b      	bne.n	4c80 <submit_to_queue_locked+0xc4>
    4bc8:	4604      	mov	r4, r0
		/* Disallowed */
		ret = -EBUSY;
	} else if (!flag_test(&work->flags, K_WORK_QUEUED_BIT)) {
    4bca:	f013 0f04 	tst.w	r3, #4
    4bce:	d15c      	bne.n	4c8a <submit_to_queue_locked+0xce>
		/* Not currently queued */
		ret = 1;

		/* If no queue specified resubmit to last queue.
		 */
		if (*queuep == NULL) {
    4bd0:	680b      	ldr	r3, [r1, #0]
    4bd2:	2b00      	cmp	r3, #0
    4bd4:	d037      	beq.n	4c46 <submit_to_queue_locked+0x8a>
	return (*flagp & BIT(bit)) != 0U;
    4bd6:	68e3      	ldr	r3, [r4, #12]

		/* If the work is currently running we have to use the
		 * queue it's running on to prevent handler
		 * re-entrancy.
		 */
		if (flag_test(&work->flags, K_WORK_RUNNING_BIT)) {
    4bd8:	f013 0f01 	tst.w	r3, #1
    4bdc:	d036      	beq.n	4c4c <submit_to_queue_locked+0x90>
			__ASSERT_NO_MSG(work->queue != NULL);
			*queuep = work->queue;
    4bde:	68a3      	ldr	r3, [r4, #8]
    4be0:	602b      	str	r3, [r5, #0]
			ret = 2;
    4be2:	2702      	movs	r7, #2
		}

		int rc = queue_submit_locked(*queuep, work);
    4be4:	682e      	ldr	r6, [r5, #0]
	if (queue == NULL) {
    4be6:	2e00      	cmp	r6, #0
    4be8:	d03e      	beq.n	4c68 <submit_to_queue_locked+0xac>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4bea:	4b29      	ldr	r3, [pc, #164]	; (4c90 <submit_to_queue_locked+0xd4>)
    4bec:	689b      	ldr	r3, [r3, #8]
    4bee:	42b3      	cmp	r3, r6
    4bf0:	d02e      	beq.n	4c50 <submit_to_queue_locked+0x94>
    4bf2:	2300      	movs	r3, #0
    4bf4:	461a      	mov	r2, r3
	return (*flagp & BIT(bit)) != 0U;
    4bf6:	f8d6 30c8 	ldr.w	r3, [r6, #200]	; 0xc8
    4bfa:	f3c3 0180 	ubfx	r1, r3, #2, #1
    4bfe:	f3c3 00c0 	ubfx	r0, r3, #3, #1
	if (!flag_test(&queue->flags, K_WORK_QUEUE_STARTED_BIT)) {
    4c02:	f013 0f01 	tst.w	r3, #1
    4c06:	d032      	beq.n	4c6e <submit_to_queue_locked+0xb2>
	} else if (draining && !chained) {
    4c08:	b101      	cbz	r1, 4c0c <submit_to_queue_locked+0x50>
    4c0a:	b39a      	cbz	r2, 4c74 <submit_to_queue_locked+0xb8>
	} else if (plugged && !draining) {
    4c0c:	b100      	cbz	r0, 4c10 <submit_to_queue_locked+0x54>
    4c0e:	b3a1      	cbz	r1, 4c7a <submit_to_queue_locked+0xbe>
	parent->next = child;
    4c10:	2300      	movs	r3, #0
    4c12:	6023      	str	r3, [r4, #0]
	return list->tail;
    4c14:	f8d6 30b4 	ldr.w	r3, [r6, #180]	; 0xb4
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    4c18:	b30b      	cbz	r3, 4c5e <submit_to_queue_locked+0xa2>
	parent->next = child;
    4c1a:	601c      	str	r4, [r3, #0]
	list->tail = node;
    4c1c:	f8c6 40b4 	str.w	r4, [r6, #180]	; 0xb4
		rv = z_sched_wake(&queue->notifyq, 0, NULL);
    4c20:	2200      	movs	r2, #0
    4c22:	4611      	mov	r1, r2
    4c24:	f106 00b8 	add.w	r0, r6, #184	; 0xb8
    4c28:	f002 fcf3 	bl	7612 <z_sched_wake>
		ret = 1;
    4c2c:	2001      	movs	r0, #1

		if (rc < 0) {
    4c2e:	2800      	cmp	r0, #0
    4c30:	db06      	blt.n	4c40 <submit_to_queue_locked+0x84>
	*flagp |= BIT(bit);
    4c32:	68e3      	ldr	r3, [r4, #12]
    4c34:	f043 0304 	orr.w	r3, r3, #4
    4c38:	60e3      	str	r3, [r4, #12]
			ret = rc;
		} else {
			flag_set(&work->flags, K_WORK_QUEUED_BIT);
			work->queue = *queuep;
    4c3a:	682b      	ldr	r3, [r5, #0]
    4c3c:	60a3      	str	r3, [r4, #8]
    4c3e:	4638      	mov	r0, r7
		}
	} else {
		/* Already queued, do nothing. */
	}

	if (ret <= 0) {
    4c40:	2800      	cmp	r0, #0
    4c42:	dc21      	bgt.n	4c88 <submit_to_queue_locked+0xcc>
    4c44:	e01e      	b.n	4c84 <submit_to_queue_locked+0xc8>
			*queuep = work->queue;
    4c46:	6883      	ldr	r3, [r0, #8]
    4c48:	600b      	str	r3, [r1, #0]
    4c4a:	e7c4      	b.n	4bd6 <submit_to_queue_locked+0x1a>
		ret = 1;
    4c4c:	2701      	movs	r7, #1
    4c4e:	e7c9      	b.n	4be4 <submit_to_queue_locked+0x28>
	bool chained = (_current == &queue->thread) && !k_is_in_isr();
    4c50:	f002 fb1a 	bl	7288 <k_is_in_isr>
    4c54:	b908      	cbnz	r0, 4c5a <submit_to_queue_locked+0x9e>
    4c56:	2301      	movs	r3, #1
    4c58:	e7cc      	b.n	4bf4 <submit_to_queue_locked+0x38>
    4c5a:	2300      	movs	r3, #0
    4c5c:	e7ca      	b.n	4bf4 <submit_to_queue_locked+0x38>
    4c5e:	f8c6 40b4 	str.w	r4, [r6, #180]	; 0xb4
	list->head = node;
    4c62:	f8c6 40b0 	str.w	r4, [r6, #176]	; 0xb0
}
    4c66:	e7db      	b.n	4c20 <submit_to_queue_locked+0x64>
		return -EINVAL;
    4c68:	f06f 0015 	mvn.w	r0, #21
    4c6c:	e7df      	b.n	4c2e <submit_to_queue_locked+0x72>
		ret = -ENODEV;
    4c6e:	f06f 0012 	mvn.w	r0, #18
    4c72:	e7dc      	b.n	4c2e <submit_to_queue_locked+0x72>
		ret = -EBUSY;
    4c74:	f06f 000f 	mvn.w	r0, #15
    4c78:	e7d9      	b.n	4c2e <submit_to_queue_locked+0x72>
		ret = -EBUSY;
    4c7a:	f06f 000f 	mvn.w	r0, #15
    4c7e:	e7d6      	b.n	4c2e <submit_to_queue_locked+0x72>
		ret = -EBUSY;
    4c80:	f06f 000f 	mvn.w	r0, #15
		*queuep = NULL;
    4c84:	2300      	movs	r3, #0
    4c86:	602b      	str	r3, [r5, #0]
	}

	return ret;
}
    4c88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	int ret = 0;
    4c8a:	2000      	movs	r0, #0
    4c8c:	e7fa      	b.n	4c84 <submit_to_queue_locked+0xc8>
    4c8e:	bf00      	nop
    4c90:	20000a24 	.word	0x20000a24

00004c94 <finalize_cancel_locked>:
{
    4c94:	b570      	push	{r4, r5, r6, lr}
    4c96:	4605      	mov	r5, r0
	*flagp &= ~BIT(bit);
    4c98:	68c3      	ldr	r3, [r0, #12]
    4c9a:	f023 0302 	bic.w	r3, r3, #2
    4c9e:	60c3      	str	r3, [r0, #12]
	return list->head;
    4ca0:	4b19      	ldr	r3, [pc, #100]	; (4d08 <finalize_cancel_locked+0x74>)
    4ca2:	6818      	ldr	r0, [r3, #0]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    4ca4:	b1e8      	cbz	r0, 4ce2 <finalize_cancel_locked+0x4e>
    4ca6:	4604      	mov	r4, r0
Z_GENLIST_PEEK_NEXT(slist, snode)
    4ca8:	b100      	cbz	r0, 4cac <finalize_cancel_locked+0x18>
	return node->next;
    4caa:	6804      	ldr	r4, [r0, #0]
    4cac:	2600      	movs	r6, #0
    4cae:	e01d      	b.n	4cec <finalize_cancel_locked+0x58>
 */
static inline void sys_slist_remove(sys_slist_t *list,
				    sys_snode_t *prev_node,
				    sys_snode_t *node);

Z_GENLIST_REMOVE(slist, snode)
    4cb0:	b15e      	cbz	r6, 4cca <finalize_cancel_locked+0x36>
	return node->next;
    4cb2:	6803      	ldr	r3, [r0, #0]
	parent->next = child;
    4cb4:	6033      	str	r3, [r6, #0]
	return list->tail;
    4cb6:	4b14      	ldr	r3, [pc, #80]	; (4d08 <finalize_cancel_locked+0x74>)
    4cb8:	685b      	ldr	r3, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
    4cba:	4298      	cmp	r0, r3
    4cbc:	d00e      	beq.n	4cdc <finalize_cancel_locked+0x48>
	parent->next = child;
    4cbe:	2300      	movs	r3, #0
    4cc0:	f840 3b08 	str.w	r3, [r0], #8
	z_impl_k_sem_give(sem);
    4cc4:	f7ff ff2c 	bl	4b20 <z_impl_k_sem_give>
}
    4cc8:	e015      	b.n	4cf6 <finalize_cancel_locked+0x62>
	return node->next;
    4cca:	6802      	ldr	r2, [r0, #0]
	list->head = node;
    4ccc:	4b0e      	ldr	r3, [pc, #56]	; (4d08 <finalize_cancel_locked+0x74>)
    4cce:	601a      	str	r2, [r3, #0]
	return list->tail;
    4cd0:	685b      	ldr	r3, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
    4cd2:	4298      	cmp	r0, r3
    4cd4:	d1f3      	bne.n	4cbe <finalize_cancel_locked+0x2a>
	list->tail = node;
    4cd6:	4b0c      	ldr	r3, [pc, #48]	; (4d08 <finalize_cancel_locked+0x74>)
    4cd8:	605a      	str	r2, [r3, #4]
}
    4cda:	e7f0      	b.n	4cbe <finalize_cancel_locked+0x2a>
	list->tail = node;
    4cdc:	4b0a      	ldr	r3, [pc, #40]	; (4d08 <finalize_cancel_locked+0x74>)
    4cde:	605e      	str	r6, [r3, #4]
}
    4ce0:	e7ed      	b.n	4cbe <finalize_cancel_locked+0x2a>
    4ce2:	4604      	mov	r4, r0
    4ce4:	e7e2      	b.n	4cac <finalize_cancel_locked+0x18>
    4ce6:	4623      	mov	r3, r4
    4ce8:	4620      	mov	r0, r4
    4cea:	461c      	mov	r4, r3
    4cec:	b150      	cbz	r0, 4d04 <finalize_cancel_locked+0x70>
		if (wc->work == work) {
    4cee:	6843      	ldr	r3, [r0, #4]
    4cf0:	42ab      	cmp	r3, r5
    4cf2:	d0dd      	beq.n	4cb0 <finalize_cancel_locked+0x1c>
			prev = &wc->node;
    4cf4:	4606      	mov	r6, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(&pending_cancels, wc, tmp, node) {
    4cf6:	2c00      	cmp	r4, #0
    4cf8:	d0f5      	beq.n	4ce6 <finalize_cancel_locked+0x52>
    4cfa:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
    4cfc:	2c00      	cmp	r4, #0
    4cfe:	d0f3      	beq.n	4ce8 <finalize_cancel_locked+0x54>
	return node->next;
    4d00:	6823      	ldr	r3, [r4, #0]
    4d02:	e7f1      	b.n	4ce8 <finalize_cancel_locked+0x54>
}
    4d04:	bd70      	pop	{r4, r5, r6, pc}
    4d06:	bf00      	nop
    4d08:	20000a58 	.word	0x20000a58

00004d0c <work_queue_main>:
/* Loop executed by a work queue thread.
 *
 * @param workq_ptr pointer to the work queue structure
 */
static void work_queue_main(void *workq_ptr, void *p2, void *p3)
{
    4d0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4d0e:	b085      	sub	sp, #20
    4d10:	4605      	mov	r5, r0
	struct k_work_q *queue = (struct k_work_q *)workq_ptr;
    4d12:	e016      	b.n	4d42 <work_queue_main+0x36>
	return (*flagp & BIT(bit)) != 0U;
    4d14:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
	*flagp &= ~BIT(bit);
    4d18:	f023 0204 	bic.w	r2, r3, #4
    4d1c:	f8c5 20c8 	str.w	r2, [r5, #200]	; 0xc8
			flag_set(&queue->flags, K_WORK_QUEUE_BUSY_BIT);
			work = CONTAINER_OF(node, struct k_work, node);
			flag_set(&work->flags, K_WORK_RUNNING_BIT);
			flag_clear(&work->flags, K_WORK_QUEUED_BIT);
			handler = work->handler;
		} else if (flag_test_and_clear(&queue->flags,
    4d20:	f013 0f04 	tst.w	r3, #4
    4d24:	d158      	bne.n	4dd8 <work_queue_main+0xcc>
			 * the lock, and we didn't find work nor got asked to
			 * stop.  Just go to sleep: when something happens the
			 * work thread will be woken and we can check again.
			 */

			(void)z_sched_wait(&lock, key, &queue->notifyq,
    4d26:	2300      	movs	r3, #0
    4d28:	9302      	str	r3, [sp, #8]
    4d2a:	f04f 32ff 	mov.w	r2, #4294967295
    4d2e:	f04f 33ff 	mov.w	r3, #4294967295
    4d32:	e9cd 2300 	strd	r2, r3, [sp]
    4d36:	f105 02b8 	add.w	r2, r5, #184	; 0xb8
    4d3a:	4631      	mov	r1, r6
    4d3c:	482e      	ldr	r0, [pc, #184]	; (4df8 <work_queue_main+0xec>)
    4d3e:	f000 fc9f 	bl	5680 <z_sched_wait>
	__asm__ volatile(
    4d42:	f04f 0320 	mov.w	r3, #32
    4d46:	f3ef 8611 	mrs	r6, BASEPRI
    4d4a:	f383 8811 	msr	BASEPRI, r3
    4d4e:	f3bf 8f6f 	isb	sy
	return list->head;
    4d52:	f8d5 40b0 	ldr.w	r4, [r5, #176]	; 0xb0
Z_GENLIST_GET(slist, snode)
    4d56:	2c00      	cmp	r4, #0
    4d58:	d0dc      	beq.n	4d14 <work_queue_main+0x8>
	return node->next;
    4d5a:	6823      	ldr	r3, [r4, #0]
	list->head = node;
    4d5c:	f8c5 30b0 	str.w	r3, [r5, #176]	; 0xb0
	return list->tail;
    4d60:	f8d5 20b4 	ldr.w	r2, [r5, #180]	; 0xb4
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    4d64:	4294      	cmp	r4, r2
    4d66:	d034      	beq.n	4dd2 <work_queue_main+0xc6>
	*flagp |= BIT(bit);
    4d68:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
    4d6c:	f043 0302 	orr.w	r3, r3, #2
    4d70:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
    4d74:	68e3      	ldr	r3, [r4, #12]
    4d76:	f043 0301 	orr.w	r3, r3, #1
	*flagp &= ~BIT(bit);
    4d7a:	f023 0304 	bic.w	r3, r3, #4
    4d7e:	60e3      	str	r3, [r4, #12]
			handler = work->handler;
    4d80:	6863      	ldr	r3, [r4, #4]
		if (work == NULL) {
    4d82:	2c00      	cmp	r4, #0
    4d84:	d0cf      	beq.n	4d26 <work_queue_main+0x1a>
	__asm__ volatile(
    4d86:	f386 8811 	msr	BASEPRI, r6
    4d8a:	f3bf 8f6f 	isb	sy

		if (work != NULL) {
			bool yield;

			__ASSERT_NO_MSG(handler != NULL);
			handler(work);
    4d8e:	4620      	mov	r0, r4
    4d90:	4798      	blx	r3
	__asm__ volatile(
    4d92:	f04f 0320 	mov.w	r3, #32
    4d96:	f3ef 8611 	mrs	r6, BASEPRI
    4d9a:	f383 8811 	msr	BASEPRI, r3
    4d9e:	f3bf 8f6f 	isb	sy
	*flagp &= ~BIT(bit);
    4da2:	68e3      	ldr	r3, [r4, #12]
    4da4:	f023 0301 	bic.w	r3, r3, #1
    4da8:	60e3      	str	r3, [r4, #12]
			 * starving other threads.
			 */
			key = k_spin_lock(&lock);

			flag_clear(&work->flags, K_WORK_RUNNING_BIT);
			if (flag_test(&work->flags, K_WORK_CANCELING_BIT)) {
    4daa:	f013 0f02 	tst.w	r3, #2
    4dae:	d11e      	bne.n	4dee <work_queue_main+0xe2>
	*flagp &= ~BIT(bit);
    4db0:	f8d5 30c8 	ldr.w	r3, [r5, #200]	; 0xc8
    4db4:	f023 0302 	bic.w	r3, r3, #2
    4db8:	f8c5 30c8 	str.w	r3, [r5, #200]	; 0xc8
	return (*flagp & BIT(bit)) != 0U;
    4dbc:	f3c3 2300 	ubfx	r3, r3, #8, #1
	__asm__ volatile(
    4dc0:	f386 8811 	msr	BASEPRI, r6
    4dc4:	f3bf 8f6f 	isb	sy
			k_spin_unlock(&lock, key);

			/* Optionally yield to prevent the work queue from
			 * starving other threads.
			 */
			if (yield) {
    4dc8:	2b00      	cmp	r3, #0
    4dca:	d1ba      	bne.n	4d42 <work_queue_main+0x36>
	z_impl_k_yield();
    4dcc:	f000 fb5a 	bl	5484 <z_impl_k_yield>
}
    4dd0:	e7b7      	b.n	4d42 <work_queue_main+0x36>
	list->tail = node;
    4dd2:	f8c5 30b4 	str.w	r3, [r5, #180]	; 0xb4
}
    4dd6:	e7c7      	b.n	4d68 <work_queue_main+0x5c>
			(void)z_sched_wake_all(&queue->drainq, 1, NULL);
    4dd8:	f105 07c0 	add.w	r7, r5, #192	; 0xc0
static inline bool z_sched_wake_all(_wait_q_t *wait_q, int swap_retval,
				    void *swap_data)
{
	bool woken = false;

	while (z_sched_wake(wait_q, swap_retval, swap_data)) {
    4ddc:	2200      	movs	r2, #0
    4dde:	2101      	movs	r1, #1
    4de0:	4638      	mov	r0, r7
    4de2:	f002 fc16 	bl	7612 <z_sched_wake>
    4de6:	2800      	cmp	r0, #0
    4de8:	d1f8      	bne.n	4ddc <work_queue_main+0xd0>
		k_work_handler_t handler = NULL;
    4dea:	2300      	movs	r3, #0
    4dec:	e7c9      	b.n	4d82 <work_queue_main+0x76>
				finalize_cancel_locked(work);
    4dee:	4620      	mov	r0, r4
    4df0:	f7ff ff50 	bl	4c94 <finalize_cancel_locked>
    4df4:	e7dc      	b.n	4db0 <work_queue_main+0xa4>
    4df6:	bf00      	nop
    4df8:	20000a58 	.word	0x20000a58

00004dfc <k_work_submit>:
{
    4dfc:	b508      	push	{r3, lr}
    4dfe:	4601      	mov	r1, r0
	int ret = k_work_submit_to_queue(&k_sys_work_q, work);
    4e00:	4801      	ldr	r0, [pc, #4]	; (4e08 <k_work_submit+0xc>)
    4e02:	f002 faa8 	bl	7356 <k_work_submit_to_queue>
}
    4e06:	bd08      	pop	{r3, pc}
    4e08:	200002a8 	.word	0x200002a8

00004e0c <k_work_queue_start>:
void k_work_queue_start(struct k_work_q *queue,
			k_thread_stack_t *stack,
			size_t stack_size,
			int prio,
			const struct k_work_queue_config *cfg)
{
    4e0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    4e0e:	b089      	sub	sp, #36	; 0x24
    4e10:	4604      	mov	r4, r0
    4e12:	9d0e      	ldr	r5, [sp, #56]	; 0x38
	list->head = NULL;
    4e14:	2000      	movs	r0, #0
    4e16:	f8c4 00b0 	str.w	r0, [r4, #176]	; 0xb0
	list->tail = NULL;
    4e1a:	f8c4 00b4 	str.w	r0, [r4, #180]	; 0xb4
    4e1e:	f104 00b8 	add.w	r0, r4, #184	; 0xb8
	list->head = (sys_dnode_t *)list;
    4e22:	f8c4 00b8 	str.w	r0, [r4, #184]	; 0xb8
	list->tail = (sys_dnode_t *)list;
    4e26:	f8c4 00bc 	str.w	r0, [r4, #188]	; 0xbc
    4e2a:	f104 00c0 	add.w	r0, r4, #192	; 0xc0
	list->head = (sys_dnode_t *)list;
    4e2e:	f8c4 00c0 	str.w	r0, [r4, #192]	; 0xc0
	list->tail = (sys_dnode_t *)list;
    4e32:	f8c4 00c4 	str.w	r0, [r4, #196]	; 0xc4

	sys_slist_init(&queue->pending);
	z_waitq_init(&queue->notifyq);
	z_waitq_init(&queue->drainq);

	if ((cfg != NULL) && cfg->no_yield) {
    4e36:	b1fd      	cbz	r5, 4e78 <k_work_queue_start+0x6c>
    4e38:	7928      	ldrb	r0, [r5, #4]
    4e3a:	b9f8      	cbnz	r0, 4e7c <k_work_queue_start+0x70>
	uint32_t flags = K_WORK_QUEUE_STARTED;
    4e3c:	2001      	movs	r0, #1
	*flagp = flags;
    4e3e:	f8c4 00c8 	str.w	r0, [r4, #200]	; 0xc8
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
    4e42:	f04f 36ff 	mov.w	r6, #4294967295
    4e46:	f04f 37ff 	mov.w	r7, #4294967295
    4e4a:	e9cd 6706 	strd	r6, r7, [sp, #24]
    4e4e:	2000      	movs	r0, #0
    4e50:	9004      	str	r0, [sp, #16]
    4e52:	9303      	str	r3, [sp, #12]
    4e54:	9002      	str	r0, [sp, #8]
    4e56:	9001      	str	r0, [sp, #4]
    4e58:	9400      	str	r4, [sp, #0]
    4e5a:	4b0a      	ldr	r3, [pc, #40]	; (4e84 <k_work_queue_start+0x78>)
    4e5c:	4620      	mov	r0, r4
    4e5e:	f002 fa2a 	bl	72b6 <z_impl_k_thread_create>

	(void)k_thread_create(&queue->thread, stack, stack_size,
			      work_queue_main, queue, NULL, NULL,
			      prio, 0, K_FOREVER);

	if ((cfg != NULL) && (cfg->name != NULL)) {
    4e62:	b125      	cbz	r5, 4e6e <k_work_queue_start+0x62>
    4e64:	6829      	ldr	r1, [r5, #0]
    4e66:	b111      	cbz	r1, 4e6e <k_work_queue_start+0x62>
	return z_impl_k_thread_name_set(thread, str);
    4e68:	4620      	mov	r0, r4
    4e6a:	f7ff fca7 	bl	47bc <z_impl_k_thread_name_set>
	z_impl_k_thread_start(thread);
    4e6e:	4620      	mov	r0, r4
    4e70:	f002 fa12 	bl	7298 <z_impl_k_thread_start>
	}

	k_thread_start(&queue->thread);

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_work_queue, start, queue);
}
    4e74:	b009      	add	sp, #36	; 0x24
    4e76:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uint32_t flags = K_WORK_QUEUE_STARTED;
    4e78:	2001      	movs	r0, #1
    4e7a:	e7e0      	b.n	4e3e <k_work_queue_start+0x32>
		flags |= K_WORK_QUEUE_NO_YIELD;
    4e7c:	f240 1001 	movw	r0, #257	; 0x101
    4e80:	e7dd      	b.n	4e3e <k_work_queue_start+0x32>
    4e82:	bf00      	nop
    4e84:	00004d0d 	.word	0x00004d0d

00004e88 <add_thread_timeout>:
		z_priq_wait_add(&wait_q->waitq, thread);
	}
}

static void add_thread_timeout(struct k_thread *thread, k_timeout_t timeout)
{
    4e88:	b538      	push	{r3, r4, r5, lr}
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    4e8a:	f1b3 3fff 	cmp.w	r3, #4294967295
    4e8e:	bf08      	it	eq
    4e90:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    4e94:	d100      	bne.n	4e98 <add_thread_timeout+0x10>
		z_add_thread_timeout(thread, timeout);
	}
}
    4e96:	bd38      	pop	{r3, r4, r5, pc}
    4e98:	4902      	ldr	r1, [pc, #8]	; (4ea4 <add_thread_timeout+0x1c>)
    4e9a:	3018      	adds	r0, #24
    4e9c:	f000 fc64 	bl	5768 <z_add_timeout>
    4ea0:	e7f9      	b.n	4e96 <add_thread_timeout+0xe>
    4ea2:	bf00      	nop
    4ea4:	00007507 	.word	0x00007507

00004ea8 <z_reset_time_slice>:
{
    4ea8:	b508      	push	{r3, lr}
	if (slice_time != 0) {
    4eaa:	4b08      	ldr	r3, [pc, #32]	; (4ecc <z_reset_time_slice+0x24>)
    4eac:	681b      	ldr	r3, [r3, #0]
    4eae:	b903      	cbnz	r3, 4eb2 <z_reset_time_slice+0xa>
}
    4eb0:	bd08      	pop	{r3, pc}
		_current_cpu->slice_ticks = slice_time + sys_clock_elapsed();
    4eb2:	f7fd fb95 	bl	25e0 <sys_clock_elapsed>
    4eb6:	4603      	mov	r3, r0
    4eb8:	4a04      	ldr	r2, [pc, #16]	; (4ecc <z_reset_time_slice+0x24>)
    4eba:	6810      	ldr	r0, [r2, #0]
    4ebc:	4403      	add	r3, r0
    4ebe:	4a04      	ldr	r2, [pc, #16]	; (4ed0 <z_reset_time_slice+0x28>)
    4ec0:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
    4ec2:	2100      	movs	r1, #0
    4ec4:	f002 fc27 	bl	7716 <z_set_timeout_expiry>
}
    4ec8:	e7f2      	b.n	4eb0 <z_reset_time_slice+0x8>
    4eca:	bf00      	nop
    4ecc:	20000a68 	.word	0x20000a68
    4ed0:	20000a24 	.word	0x20000a24

00004ed4 <k_sched_time_slice_set>:
{
    4ed4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4ed8:	4606      	mov	r6, r0
    4eda:	4688      	mov	r8, r1
	LOCKED(&sched_spinlock) {
    4edc:	2300      	movs	r3, #0
	__asm__ volatile(
    4ede:	f04f 0220 	mov.w	r2, #32
    4ee2:	f3ef 8711 	mrs	r7, BASEPRI
    4ee6:	f382 8811 	msr	BASEPRI, r2
    4eea:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    4eee:	e009      	b.n	4f04 <k_sched_time_slice_set+0x30>
		slice_max_prio = prio;
    4ef0:	4b13      	ldr	r3, [pc, #76]	; (4f40 <k_sched_time_slice_set+0x6c>)
    4ef2:	f8c3 8000 	str.w	r8, [r3]
		z_reset_time_slice();
    4ef6:	f7ff ffd7 	bl	4ea8 <z_reset_time_slice>
	__asm__ volatile(
    4efa:	f387 8811 	msr	BASEPRI, r7
    4efe:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    4f02:	2301      	movs	r3, #1
    4f04:	b9cb      	cbnz	r3, 4f3a <k_sched_time_slice_set+0x66>
		_current_cpu->slice_ticks = 0;
    4f06:	2300      	movs	r3, #0
    4f08:	4a0e      	ldr	r2, [pc, #56]	; (4f44 <k_sched_time_slice_set+0x70>)
    4f0a:	6113      	str	r3, [r2, #16]
			return (uint32_t)((t * to_hz + off) / from_hz);
    4f0c:	0c75      	lsrs	r5, r6, #17
    4f0e:	03f4      	lsls	r4, r6, #15
    4f10:	f240 30e7 	movw	r0, #999	; 0x3e7
    4f14:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    4f18:	2300      	movs	r3, #0
    4f1a:	1820      	adds	r0, r4, r0
    4f1c:	f04f 0100 	mov.w	r1, #0
    4f20:	eb45 0101 	adc.w	r1, r5, r1
    4f24:	f7fb f8da 	bl	dc <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    4f28:	4b07      	ldr	r3, [pc, #28]	; (4f48 <k_sched_time_slice_set+0x74>)
    4f2a:	6018      	str	r0, [r3, #0]
		if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && slice > 0) {
    4f2c:	2e00      	cmp	r6, #0
    4f2e:	dddf      	ble.n	4ef0 <k_sched_time_slice_set+0x1c>
			slice_time = MAX(2, slice_time);
    4f30:	2802      	cmp	r0, #2
    4f32:	bfb8      	it	lt
    4f34:	2002      	movlt	r0, #2
    4f36:	6018      	str	r0, [r3, #0]
    4f38:	e7da      	b.n	4ef0 <k_sched_time_slice_set+0x1c>
}
    4f3a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4f3e:	bf00      	nop
    4f40:	20000a64 	.word	0x20000a64
    4f44:	20000a24 	.word	0x20000a24
    4f48:	20000a68 	.word	0x20000a68

00004f4c <z_reschedule>:
	return new_thread != _current;
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
    4f4c:	b508      	push	{r3, lr}
	if (resched(key.key) && need_swap()) {
    4f4e:	4608      	mov	r0, r1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    4f50:	b921      	cbnz	r1, 4f5c <z_reschedule+0x10>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    4f52:	f3ef 8305 	mrs	r3, IPSR
    4f56:	b913      	cbnz	r3, 4f5e <z_reschedule+0x12>
    4f58:	2101      	movs	r1, #1
    4f5a:	e000      	b.n	4f5e <z_reschedule+0x12>
    4f5c:	2100      	movs	r1, #0
	if (resched(key.key) && need_swap()) {
    4f5e:	f011 0f01 	tst.w	r1, #1
    4f62:	d007      	beq.n	4f74 <z_reschedule+0x28>
	new_thread = _kernel.ready_q.cache;
    4f64:	4b06      	ldr	r3, [pc, #24]	; (4f80 <z_reschedule+0x34>)
    4f66:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	return new_thread != _current;
    4f68:	689b      	ldr	r3, [r3, #8]
	if (resched(key.key) && need_swap()) {
    4f6a:	429a      	cmp	r2, r3
    4f6c:	d002      	beq.n	4f74 <z_reschedule+0x28>
	ret = arch_swap(key);
    4f6e:	f7fd fb59 	bl	2624 <arch_swap>
		z_swap(lock, key);
    4f72:	e003      	b.n	4f7c <z_reschedule+0x30>
    4f74:	f380 8811 	msr	BASEPRI, r0
    4f78:	f3bf 8f6f 	isb	sy
	} else {
		k_spin_unlock(lock, key);
	}
}
    4f7c:	bd08      	pop	{r3, pc}
    4f7e:	bf00      	nop
    4f80:	20000a24 	.word	0x20000a24

00004f84 <k_sched_lock>:
	}
}

void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
    4f84:	2300      	movs	r3, #0
	__asm__ volatile(
    4f86:	f04f 0220 	mov.w	r2, #32
    4f8a:	f3ef 8111 	mrs	r1, BASEPRI
    4f8e:	f382 8811 	msr	BASEPRI, r2
    4f92:	f3bf 8f6f 	isb	sy
    4f96:	b953      	cbnz	r3, 4fae <k_sched_lock+0x2a>
	--_current->base.sched_locked;
    4f98:	4b05      	ldr	r3, [pc, #20]	; (4fb0 <k_sched_lock+0x2c>)
    4f9a:	689a      	ldr	r2, [r3, #8]
    4f9c:	7bd3      	ldrb	r3, [r2, #15]
    4f9e:	3b01      	subs	r3, #1
    4fa0:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    4fa2:	f381 8811 	msr	BASEPRI, r1
    4fa6:	f3bf 8f6f 	isb	sy
    4faa:	2301      	movs	r3, #1
    4fac:	e7f3      	b.n	4f96 <k_sched_lock+0x12>
		SYS_PORT_TRACING_FUNC(k_thread, sched_lock);

		z_sched_lock();
	}
}
    4fae:	4770      	bx	lr
    4fb0:	20000a24 	.word	0x20000a24

00004fb4 <update_cache>:
{
    4fb4:	b538      	push	{r3, r4, r5, lr}
    4fb6:	4604      	mov	r4, r0
	thread = _priq_run_best(&_kernel.ready_q.runq);
    4fb8:	480f      	ldr	r0, [pc, #60]	; (4ff8 <update_cache+0x44>)
    4fba:	f002 fa36 	bl	742a <z_priq_dumb_best>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    4fbe:	4605      	mov	r5, r0
    4fc0:	b170      	cbz	r0, 4fe0 <update_cache+0x2c>
	if (preempt_ok != 0) {
    4fc2:	b984      	cbnz	r4, 4fe6 <update_cache+0x32>
	if (z_is_thread_prevented_from_running(_current)) {
    4fc4:	4b0d      	ldr	r3, [pc, #52]	; (4ffc <update_cache+0x48>)
    4fc6:	689b      	ldr	r3, [r3, #8]
	uint8_t state = thread->base.thread_state;
    4fc8:	7b5a      	ldrb	r2, [r3, #13]
    4fca:	f012 0f1f 	tst.w	r2, #31
    4fce:	d10a      	bne.n	4fe6 <update_cache+0x32>
	return node->next != NULL;
    4fd0:	69aa      	ldr	r2, [r5, #24]
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    4fd2:	b942      	cbnz	r2, 4fe6 <update_cache+0x32>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    4fd4:	89da      	ldrh	r2, [r3, #14]
	if (is_preempt(_current) || is_metairq(thread)) {
    4fd6:	2a7f      	cmp	r2, #127	; 0x7f
    4fd8:	d905      	bls.n	4fe6 <update_cache+0x32>
		_kernel.ready_q.cache = _current;
    4fda:	4a08      	ldr	r2, [pc, #32]	; (4ffc <update_cache+0x48>)
    4fdc:	6253      	str	r3, [r2, #36]	; 0x24
    4fde:	e00a      	b.n	4ff6 <update_cache+0x42>
	return (thread != NULL) ? thread : _current_cpu->idle_thread;
    4fe0:	4b06      	ldr	r3, [pc, #24]	; (4ffc <update_cache+0x48>)
    4fe2:	68dd      	ldr	r5, [r3, #12]
    4fe4:	e7ed      	b.n	4fc2 <update_cache+0xe>
		if (thread != _current) {
    4fe6:	4b05      	ldr	r3, [pc, #20]	; (4ffc <update_cache+0x48>)
    4fe8:	689b      	ldr	r3, [r3, #8]
    4fea:	42ab      	cmp	r3, r5
    4fec:	d001      	beq.n	4ff2 <update_cache+0x3e>
			z_reset_time_slice();
    4fee:	f7ff ff5b 	bl	4ea8 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    4ff2:	4b02      	ldr	r3, [pc, #8]	; (4ffc <update_cache+0x48>)
    4ff4:	625d      	str	r5, [r3, #36]	; 0x24
}
    4ff6:	bd38      	pop	{r3, r4, r5, pc}
    4ff8:	20000a4c 	.word	0x20000a4c
    4ffc:	20000a24 	.word	0x20000a24

00005000 <unready_thread>:
{
    5000:	b510      	push	{r4, lr}
    5002:	4604      	mov	r4, r0
	return (thread->base.thread_state & state) != 0U;
    5004:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    5006:	f990 300d 	ldrsb.w	r3, [r0, #13]
    500a:	2b00      	cmp	r3, #0
    500c:	db08      	blt.n	5020 <unready_thread+0x20>
	update_cache(thread == _current);
    500e:	4b08      	ldr	r3, [pc, #32]	; (5030 <unready_thread+0x30>)
    5010:	6898      	ldr	r0, [r3, #8]
    5012:	42a0      	cmp	r0, r4
    5014:	bf14      	ite	ne
    5016:	2000      	movne	r0, #0
    5018:	2001      	moveq	r0, #1
    501a:	f7ff ffcb 	bl	4fb4 <update_cache>
}
    501e:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    5020:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    5024:	7342      	strb	r2, [r0, #13]
		_priq_run_remove(pq, thread);
    5026:	4601      	mov	r1, r0
    5028:	4802      	ldr	r0, [pc, #8]	; (5034 <unready_thread+0x34>)
    502a:	f002 f9f6 	bl	741a <z_priq_dumb_remove>
}
    502e:	e7ee      	b.n	500e <unready_thread+0xe>
    5030:	20000a24 	.word	0x20000a24
    5034:	20000a4c 	.word	0x20000a4c

00005038 <z_pend_curr>:
{
    5038:	b510      	push	{r4, lr}
    503a:	460c      	mov	r4, r1
    503c:	4611      	mov	r1, r2
	pending_current = _current;
    503e:	4b06      	ldr	r3, [pc, #24]	; (5058 <z_pend_curr+0x20>)
    5040:	6898      	ldr	r0, [r3, #8]
    5042:	4b06      	ldr	r3, [pc, #24]	; (505c <z_pend_curr+0x24>)
    5044:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
    5046:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    504a:	f002 fa1f 	bl	748c <pend>
    504e:	4620      	mov	r0, r4
    5050:	f7fd fae8 	bl	2624 <arch_swap>
}
    5054:	bd10      	pop	{r4, pc}
    5056:	bf00      	nop
    5058:	20000a24 	.word	0x20000a24
    505c:	20000a60 	.word	0x20000a60

00005060 <z_impl_k_thread_suspend>:
{
    5060:	b538      	push	{r3, r4, r5, lr}
    5062:	4604      	mov	r4, r0
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    5064:	3018      	adds	r0, #24
    5066:	f002 fb22 	bl	76ae <z_abort_timeout>
	LOCKED(&sched_spinlock) {
    506a:	2300      	movs	r3, #0
	__asm__ volatile(
    506c:	f04f 0220 	mov.w	r2, #32
    5070:	f3ef 8511 	mrs	r5, BASEPRI
    5074:	f382 8811 	msr	BASEPRI, r2
    5078:	f3bf 8f6f 	isb	sy
    507c:	e010      	b.n	50a0 <z_impl_k_thread_suspend+0x40>
	thread->base.thread_state |= _THREAD_SUSPENDED;
    507e:	7b63      	ldrb	r3, [r4, #13]
    5080:	f043 0310 	orr.w	r3, r3, #16
    5084:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    5086:	4b15      	ldr	r3, [pc, #84]	; (50dc <z_impl_k_thread_suspend+0x7c>)
    5088:	6898      	ldr	r0, [r3, #8]
    508a:	42a0      	cmp	r0, r4
    508c:	bf14      	ite	ne
    508e:	2000      	movne	r0, #0
    5090:	2001      	moveq	r0, #1
    5092:	f7ff ff8f 	bl	4fb4 <update_cache>
	__asm__ volatile(
    5096:	f385 8811 	msr	BASEPRI, r5
    509a:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    509e:	2301      	movs	r3, #1
    50a0:	b963      	cbnz	r3, 50bc <z_impl_k_thread_suspend+0x5c>
	return (thread->base.thread_state & state) != 0U;
    50a2:	7b62      	ldrb	r2, [r4, #13]
		if (z_is_thread_queued(thread)) {
    50a4:	f994 300d 	ldrsb.w	r3, [r4, #13]
    50a8:	2b00      	cmp	r3, #0
    50aa:	dae8      	bge.n	507e <z_impl_k_thread_suspend+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    50ac:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    50b0:	7362      	strb	r2, [r4, #13]
		_priq_run_remove(pq, thread);
    50b2:	4621      	mov	r1, r4
    50b4:	480a      	ldr	r0, [pc, #40]	; (50e0 <z_impl_k_thread_suspend+0x80>)
    50b6:	f002 f9b0 	bl	741a <z_priq_dumb_remove>
}
    50ba:	e7e0      	b.n	507e <z_impl_k_thread_suspend+0x1e>
	if (thread == _current) {
    50bc:	4b07      	ldr	r3, [pc, #28]	; (50dc <z_impl_k_thread_suspend+0x7c>)
    50be:	689b      	ldr	r3, [r3, #8]
    50c0:	42a3      	cmp	r3, r4
    50c2:	d000      	beq.n	50c6 <z_impl_k_thread_suspend+0x66>
}
    50c4:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    50c6:	f04f 0320 	mov.w	r3, #32
    50ca:	f3ef 8011 	mrs	r0, BASEPRI
    50ce:	f383 8811 	msr	BASEPRI, r3
    50d2:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    50d6:	f002 f98b 	bl	73f0 <z_reschedule_irqlock>
    50da:	e7f3      	b.n	50c4 <z_impl_k_thread_suspend+0x64>
    50dc:	20000a24 	.word	0x20000a24
    50e0:	20000a4c 	.word	0x20000a4c

000050e4 <k_sched_unlock>:

void k_sched_unlock(void)
{
    50e4:	b510      	push	{r4, lr}
	LOCKED(&sched_spinlock) {
    50e6:	2300      	movs	r3, #0
    50e8:	f04f 0220 	mov.w	r2, #32
    50ec:	f3ef 8411 	mrs	r4, BASEPRI
    50f0:	f382 8811 	msr	BASEPRI, r2
    50f4:	f3bf 8f6f 	isb	sy
    50f8:	b96b      	cbnz	r3, 5116 <k_sched_unlock+0x32>
		__ASSERT(_current->base.sched_locked != 0U, "");
		__ASSERT(!arch_is_in_isr(), "");

		++_current->base.sched_locked;
    50fa:	4b0c      	ldr	r3, [pc, #48]	; (512c <k_sched_unlock+0x48>)
    50fc:	689a      	ldr	r2, [r3, #8]
    50fe:	7bd3      	ldrb	r3, [r2, #15]
    5100:	3301      	adds	r3, #1
    5102:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    5104:	2000      	movs	r0, #0
    5106:	f7ff ff55 	bl	4fb4 <update_cache>
	__asm__ volatile(
    510a:	f384 8811 	msr	BASEPRI, r4
    510e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    5112:	2301      	movs	r3, #1
    5114:	e7f0      	b.n	50f8 <k_sched_unlock+0x14>
	__asm__ volatile(
    5116:	f04f 0320 	mov.w	r3, #32
    511a:	f3ef 8011 	mrs	r0, BASEPRI
    511e:	f383 8811 	msr	BASEPRI, r3
    5122:	f3bf 8f6f 	isb	sy
    5126:	f002 f963 	bl	73f0 <z_reschedule_irqlock>
		_current, _current->base.sched_locked);

	SYS_PORT_TRACING_FUNC(k_thread, sched_unlock);

	z_reschedule_unlocked();
}
    512a:	bd10      	pop	{r4, pc}
    512c:	20000a24 	.word	0x20000a24

00005130 <move_thread_to_end_of_prio_q>:
{
    5130:	b538      	push	{r3, r4, r5, lr}
    5132:	4605      	mov	r5, r0
	return (thread->base.thread_state & state) != 0U;
    5134:	7b42      	ldrb	r2, [r0, #13]
	if (z_is_thread_queued(thread)) {
    5136:	f990 300d 	ldrsb.w	r3, [r0, #13]
    513a:	2b00      	cmp	r3, #0
    513c:	db28      	blt.n	5190 <move_thread_to_end_of_prio_q+0x60>
	thread->base.thread_state |= _THREAD_QUEUED;
    513e:	7b6b      	ldrb	r3, [r5, #13]
    5140:	f063 037f 	orn	r3, r3, #127	; 0x7f
    5144:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    5146:	4b1a      	ldr	r3, [pc, #104]	; (51b0 <move_thread_to_end_of_prio_q+0x80>)
    5148:	f853 4f28 	ldr.w	r4, [r3, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    514c:	429c      	cmp	r4, r3
    514e:	d02d      	beq.n	51ac <move_thread_to_end_of_prio_q+0x7c>
{
	struct k_thread *t;

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5150:	b16c      	cbz	r4, 516e <move_thread_to_end_of_prio_q+0x3e>
		if (z_sched_prio_cmp(thread, t) > 0) {
    5152:	4621      	mov	r1, r4
    5154:	4628      	mov	r0, r5
    5156:	f002 f922 	bl	739e <z_sched_prio_cmp>
    515a:	2800      	cmp	r0, #0
    515c:	dc20      	bgt.n	51a0 <move_thread_to_end_of_prio_q+0x70>
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    515e:	b134      	cbz	r4, 516e <move_thread_to_end_of_prio_q+0x3e>
	return (node == list->tail) ? NULL : node->next;
    5160:	4b13      	ldr	r3, [pc, #76]	; (51b0 <move_thread_to_end_of_prio_q+0x80>)
    5162:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    5164:	429c      	cmp	r4, r3
    5166:	d002      	beq.n	516e <move_thread_to_end_of_prio_q+0x3e>
    5168:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    516a:	2c00      	cmp	r4, #0
    516c:	d1f0      	bne.n	5150 <move_thread_to_end_of_prio_q+0x20>
 * @return N/A
 */

static inline void sys_dlist_append(sys_dlist_t *list, sys_dnode_t *node)
{
	sys_dnode_t *const tail = list->tail;
    516e:	4b10      	ldr	r3, [pc, #64]	; (51b0 <move_thread_to_end_of_prio_q+0x80>)
    5170:	6ada      	ldr	r2, [r3, #44]	; 0x2c

	node->next = list;
    5172:	f103 0128 	add.w	r1, r3, #40	; 0x28
    5176:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    5178:	606a      	str	r2, [r5, #4]

	tail->next = node;
    517a:	6015      	str	r5, [r2, #0]
	list->tail = node;
    517c:	62dd      	str	r5, [r3, #44]	; 0x2c
	update_cache(thread == _current);
    517e:	4b0c      	ldr	r3, [pc, #48]	; (51b0 <move_thread_to_end_of_prio_q+0x80>)
    5180:	6898      	ldr	r0, [r3, #8]
    5182:	42a8      	cmp	r0, r5
    5184:	bf14      	ite	ne
    5186:	2000      	movne	r0, #0
    5188:	2001      	moveq	r0, #1
    518a:	f7ff ff13 	bl	4fb4 <update_cache>
}
    518e:	bd38      	pop	{r3, r4, r5, pc}
	thread->base.thread_state &= ~_THREAD_QUEUED;
    5190:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    5194:	7342      	strb	r2, [r0, #13]
		_priq_run_remove(pq, thread);
    5196:	4601      	mov	r1, r0
    5198:	4806      	ldr	r0, [pc, #24]	; (51b4 <move_thread_to_end_of_prio_q+0x84>)
    519a:	f002 f93e 	bl	741a <z_priq_dumb_remove>
}
    519e:	e7ce      	b.n	513e <move_thread_to_end_of_prio_q+0xe>
 * @param successor the position before which "node" will be inserted
 * @param node the element to insert
 */
static inline void sys_dlist_insert(sys_dnode_t *successor, sys_dnode_t *node)
{
	sys_dnode_t *const prev = successor->prev;
    51a0:	6863      	ldr	r3, [r4, #4]

	node->prev = prev;
    51a2:	606b      	str	r3, [r5, #4]
	node->next = successor;
    51a4:	602c      	str	r4, [r5, #0]
	prev->next = node;
    51a6:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    51a8:	6065      	str	r5, [r4, #4]
}
    51aa:	e7e8      	b.n	517e <move_thread_to_end_of_prio_q+0x4e>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    51ac:	2400      	movs	r4, #0
    51ae:	e7cf      	b.n	5150 <move_thread_to_end_of_prio_q+0x20>
    51b0:	20000a24 	.word	0x20000a24
    51b4:	20000a4c 	.word	0x20000a4c

000051b8 <z_time_slice>:
{
    51b8:	b510      	push	{r4, lr}
    51ba:	f04f 0320 	mov.w	r3, #32
    51be:	f3ef 8411 	mrs	r4, BASEPRI
    51c2:	f383 8811 	msr	BASEPRI, r3
    51c6:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
    51ca:	4b1c      	ldr	r3, [pc, #112]	; (523c <z_time_slice+0x84>)
    51cc:	689b      	ldr	r3, [r3, #8]
    51ce:	4a1c      	ldr	r2, [pc, #112]	; (5240 <z_time_slice+0x88>)
    51d0:	6812      	ldr	r2, [r2, #0]
    51d2:	4293      	cmp	r3, r2
    51d4:	d01d      	beq.n	5212 <z_time_slice+0x5a>
	pending_current = NULL;
    51d6:	4a1a      	ldr	r2, [pc, #104]	; (5240 <z_time_slice+0x88>)
    51d8:	2100      	movs	r1, #0
    51da:	6011      	str	r1, [r2, #0]
	if (slice_time && sliceable(_current)) {
    51dc:	4a19      	ldr	r2, [pc, #100]	; (5244 <z_time_slice+0x8c>)
    51de:	6812      	ldr	r2, [r2, #0]
    51e0:	b322      	cbz	r2, 522c <z_time_slice+0x74>
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    51e2:	89da      	ldrh	r2, [r3, #14]
		&& !z_is_idle_thread_object(thread);
    51e4:	2a7f      	cmp	r2, #127	; 0x7f
    51e6:	d821      	bhi.n	522c <z_time_slice+0x74>
	uint8_t state = thread->base.thread_state;
    51e8:	7b5a      	ldrb	r2, [r3, #13]
		&& !z_is_thread_prevented_from_running(thread)
    51ea:	f012 0f1f 	tst.w	r2, #31
    51ee:	d11d      	bne.n	522c <z_time_slice+0x74>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    51f0:	f993 100e 	ldrsb.w	r1, [r3, #14]
    51f4:	4a14      	ldr	r2, [pc, #80]	; (5248 <z_time_slice+0x90>)
    51f6:	6812      	ldr	r2, [r2, #0]
    51f8:	4291      	cmp	r1, r2
    51fa:	db17      	blt.n	522c <z_time_slice+0x74>
		&& !z_is_idle_thread_object(thread);
    51fc:	4a13      	ldr	r2, [pc, #76]	; (524c <z_time_slice+0x94>)
    51fe:	4293      	cmp	r3, r2
    5200:	d014      	beq.n	522c <z_time_slice+0x74>
		if (ticks >= _current_cpu->slice_ticks) {
    5202:	4a0e      	ldr	r2, [pc, #56]	; (523c <z_time_slice+0x84>)
    5204:	6912      	ldr	r2, [r2, #16]
    5206:	4282      	cmp	r2, r0
    5208:	dd0a      	ble.n	5220 <z_time_slice+0x68>
			_current_cpu->slice_ticks -= ticks;
    520a:	1a10      	subs	r0, r2, r0
    520c:	4b0b      	ldr	r3, [pc, #44]	; (523c <z_time_slice+0x84>)
    520e:	6118      	str	r0, [r3, #16]
    5210:	e00f      	b.n	5232 <z_time_slice+0x7a>
		z_reset_time_slice();
    5212:	f7ff fe49 	bl	4ea8 <z_reset_time_slice>
	__asm__ volatile(
    5216:	f384 8811 	msr	BASEPRI, r4
    521a:	f3bf 8f6f 	isb	sy
		return;
    521e:	e00c      	b.n	523a <z_time_slice+0x82>
			move_thread_to_end_of_prio_q(_current);
    5220:	4618      	mov	r0, r3
    5222:	f7ff ff85 	bl	5130 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
    5226:	f7ff fe3f 	bl	4ea8 <z_reset_time_slice>
    522a:	e002      	b.n	5232 <z_time_slice+0x7a>
		_current_cpu->slice_ticks = 0;
    522c:	4b03      	ldr	r3, [pc, #12]	; (523c <z_time_slice+0x84>)
    522e:	2200      	movs	r2, #0
    5230:	611a      	str	r2, [r3, #16]
    5232:	f384 8811 	msr	BASEPRI, r4
    5236:	f3bf 8f6f 	isb	sy
}
    523a:	bd10      	pop	{r4, pc}
    523c:	20000a24 	.word	0x20000a24
    5240:	20000a60 	.word	0x20000a60
    5244:	20000a68 	.word	0x20000a68
    5248:	20000a64 	.word	0x20000a64
    524c:	20000140 	.word	0x20000140

00005250 <ready_thread>:
{
    5250:	b538      	push	{r3, r4, r5, lr}
	return (thread->base.thread_state & state) != 0U;
    5252:	7b43      	ldrb	r3, [r0, #13]
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    5254:	f990 200d 	ldrsb.w	r2, [r0, #13]
    5258:	2a00      	cmp	r2, #0
    525a:	db2d      	blt.n	52b8 <ready_thread+0x68>
    525c:	4604      	mov	r4, r0
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    525e:	f013 0f1f 	tst.w	r3, #31
    5262:	d105      	bne.n	5270 <ready_thread+0x20>
	return node->next != NULL;
    5264:	6982      	ldr	r2, [r0, #24]
    5266:	b10a      	cbz	r2, 526c <ready_thread+0x1c>
    5268:	2200      	movs	r2, #0
    526a:	e002      	b.n	5272 <ready_thread+0x22>
    526c:	2201      	movs	r2, #1
    526e:	e000      	b.n	5272 <ready_thread+0x22>
    5270:	2200      	movs	r2, #0
    5272:	b30a      	cbz	r2, 52b8 <ready_thread+0x68>
	thread->base.thread_state |= _THREAD_QUEUED;
    5274:	f063 037f 	orn	r3, r3, #127	; 0x7f
    5278:	7363      	strb	r3, [r4, #13]
	return list->head == list;
    527a:	4b14      	ldr	r3, [pc, #80]	; (52cc <ready_thread+0x7c>)
    527c:	f853 5f28 	ldr.w	r5, [r3, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    5280:	429d      	cmp	r5, r3
    5282:	d020      	beq.n	52c6 <ready_thread+0x76>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5284:	b16d      	cbz	r5, 52a2 <ready_thread+0x52>
		if (z_sched_prio_cmp(thread, t) > 0) {
    5286:	4629      	mov	r1, r5
    5288:	4620      	mov	r0, r4
    528a:	f002 f888 	bl	739e <z_sched_prio_cmp>
    528e:	2800      	cmp	r0, #0
    5290:	dc13      	bgt.n	52ba <ready_thread+0x6a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    5292:	b135      	cbz	r5, 52a2 <ready_thread+0x52>
	return (node == list->tail) ? NULL : node->next;
    5294:	4b0d      	ldr	r3, [pc, #52]	; (52cc <ready_thread+0x7c>)
    5296:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    5298:	429d      	cmp	r5, r3
    529a:	d002      	beq.n	52a2 <ready_thread+0x52>
    529c:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    529e:	2d00      	cmp	r5, #0
    52a0:	d1f0      	bne.n	5284 <ready_thread+0x34>
	sys_dnode_t *const tail = list->tail;
    52a2:	4b0a      	ldr	r3, [pc, #40]	; (52cc <ready_thread+0x7c>)
    52a4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	node->next = list;
    52a6:	f103 0128 	add.w	r1, r3, #40	; 0x28
    52aa:	6021      	str	r1, [r4, #0]
	node->prev = tail;
    52ac:	6062      	str	r2, [r4, #4]
	tail->next = node;
    52ae:	6014      	str	r4, [r2, #0]
	list->tail = node;
    52b0:	62dc      	str	r4, [r3, #44]	; 0x2c
		update_cache(0);
    52b2:	2000      	movs	r0, #0
    52b4:	f7ff fe7e 	bl	4fb4 <update_cache>
}
    52b8:	bd38      	pop	{r3, r4, r5, pc}
	sys_dnode_t *const prev = successor->prev;
    52ba:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
    52bc:	6063      	str	r3, [r4, #4]
	node->next = successor;
    52be:	6025      	str	r5, [r4, #0]
	prev->next = node;
    52c0:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    52c2:	606c      	str	r4, [r5, #4]
}
    52c4:	e7f5      	b.n	52b2 <ready_thread+0x62>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    52c6:	2500      	movs	r5, #0
    52c8:	e7dc      	b.n	5284 <ready_thread+0x34>
    52ca:	bf00      	nop
    52cc:	20000a24 	.word	0x20000a24

000052d0 <z_sched_start>:
{
    52d0:	b510      	push	{r4, lr}
	__asm__ volatile(
    52d2:	f04f 0320 	mov.w	r3, #32
    52d6:	f3ef 8411 	mrs	r4, BASEPRI
    52da:	f383 8811 	msr	BASEPRI, r3
    52de:	f3bf 8f6f 	isb	sy
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
    52e2:	7b43      	ldrb	r3, [r0, #13]
	if (z_has_thread_started(thread)) {
    52e4:	f013 0f04 	tst.w	r3, #4
    52e8:	d104      	bne.n	52f4 <z_sched_start+0x24>
	__asm__ volatile(
    52ea:	f384 8811 	msr	BASEPRI, r4
    52ee:	f3bf 8f6f 	isb	sy
}
    52f2:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    52f4:	f023 0304 	bic.w	r3, r3, #4
    52f8:	7343      	strb	r3, [r0, #13]
	ready_thread(thread);
    52fa:	f7ff ffa9 	bl	5250 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    52fe:	4621      	mov	r1, r4
    5300:	4801      	ldr	r0, [pc, #4]	; (5308 <z_sched_start+0x38>)
    5302:	f7ff fe23 	bl	4f4c <z_reschedule>
    5306:	e7f4      	b.n	52f2 <z_sched_start+0x22>
    5308:	20000a64 	.word	0x20000a64

0000530c <z_set_prio>:
{
    530c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5310:	4604      	mov	r4, r0
    5312:	460f      	mov	r7, r1
	LOCKED(&sched_spinlock) {
    5314:	2300      	movs	r3, #0
	__asm__ volatile(
    5316:	f04f 0220 	mov.w	r2, #32
    531a:	f3ef 8611 	mrs	r6, BASEPRI
    531e:	f382 8811 	msr	BASEPRI, r2
    5322:	f3bf 8f6f 	isb	sy
	bool need_sched = 0;
    5326:	4698      	mov	r8, r3
    5328:	e008      	b.n	533c <z_set_prio+0x30>
		if (need_sched) {
    532a:	f012 0801 	ands.w	r8, r2, #1
    532e:	d111      	bne.n	5354 <z_set_prio+0x48>
			thread->base.prio = prio;
    5330:	73a7      	strb	r7, [r4, #14]
	__asm__ volatile(
    5332:	f386 8811 	msr	BASEPRI, r6
    5336:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    533a:	2301      	movs	r3, #1
    533c:	461a      	mov	r2, r3
    533e:	2b00      	cmp	r3, #0
    5340:	d13d      	bne.n	53be <z_set_prio+0xb2>
	uint8_t state = thread->base.thread_state;
    5342:	7b63      	ldrb	r3, [r4, #13]
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    5344:	f013 0f1f 	tst.w	r3, #31
    5348:	d1ef      	bne.n	532a <z_set_prio+0x1e>
	return node->next != NULL;
    534a:	69a1      	ldr	r1, [r4, #24]
    534c:	2900      	cmp	r1, #0
    534e:	d1ec      	bne.n	532a <z_set_prio+0x1e>
    5350:	2201      	movs	r2, #1
    5352:	e7ea      	b.n	532a <z_set_prio+0x1e>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    5354:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    5358:	7363      	strb	r3, [r4, #13]
		_priq_run_remove(pq, thread);
    535a:	f8df 906c 	ldr.w	r9, [pc, #108]	; 53c8 <z_set_prio+0xbc>
    535e:	4621      	mov	r1, r4
    5360:	4648      	mov	r0, r9
    5362:	f002 f85a 	bl	741a <z_priq_dumb_remove>
				thread->base.prio = prio;
    5366:	73a7      	strb	r7, [r4, #14]
	thread->base.thread_state |= _THREAD_QUEUED;
    5368:	7b63      	ldrb	r3, [r4, #13]
    536a:	f063 037f 	orn	r3, r3, #127	; 0x7f
    536e:	7363      	strb	r3, [r4, #13]
	return list->head == list;
    5370:	f8d9 5000 	ldr.w	r5, [r9]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    5374:	454d      	cmp	r5, r9
    5376:	d020      	beq.n	53ba <z_set_prio+0xae>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5378:	b16d      	cbz	r5, 5396 <z_set_prio+0x8a>
		if (z_sched_prio_cmp(thread, t) > 0) {
    537a:	4629      	mov	r1, r5
    537c:	4620      	mov	r0, r4
    537e:	f002 f80e 	bl	739e <z_sched_prio_cmp>
    5382:	2800      	cmp	r0, #0
    5384:	dc13      	bgt.n	53ae <z_set_prio+0xa2>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    5386:	b135      	cbz	r5, 5396 <z_set_prio+0x8a>
	return (node == list->tail) ? NULL : node->next;
    5388:	4b0e      	ldr	r3, [pc, #56]	; (53c4 <z_set_prio+0xb8>)
    538a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    538c:	429d      	cmp	r5, r3
    538e:	d002      	beq.n	5396 <z_set_prio+0x8a>
    5390:	682d      	ldr	r5, [r5, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5392:	2d00      	cmp	r5, #0
    5394:	d1f0      	bne.n	5378 <z_set_prio+0x6c>
	sys_dnode_t *const tail = list->tail;
    5396:	4b0b      	ldr	r3, [pc, #44]	; (53c4 <z_set_prio+0xb8>)
    5398:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	node->next = list;
    539a:	f103 0128 	add.w	r1, r3, #40	; 0x28
    539e:	6021      	str	r1, [r4, #0]
	node->prev = tail;
    53a0:	6062      	str	r2, [r4, #4]
	tail->next = node;
    53a2:	6014      	str	r4, [r2, #0]
	list->tail = node;
    53a4:	62dc      	str	r4, [r3, #44]	; 0x2c
			update_cache(1);
    53a6:	2001      	movs	r0, #1
    53a8:	f7ff fe04 	bl	4fb4 <update_cache>
    53ac:	e7c1      	b.n	5332 <z_set_prio+0x26>
	sys_dnode_t *const prev = successor->prev;
    53ae:	686b      	ldr	r3, [r5, #4]
	node->prev = prev;
    53b0:	6063      	str	r3, [r4, #4]
	node->next = successor;
    53b2:	6025      	str	r5, [r4, #0]
	prev->next = node;
    53b4:	601c      	str	r4, [r3, #0]
	successor->prev = node;
    53b6:	606c      	str	r4, [r5, #4]
}
    53b8:	e7f5      	b.n	53a6 <z_set_prio+0x9a>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    53ba:	2500      	movs	r5, #0
    53bc:	e7dc      	b.n	5378 <z_set_prio+0x6c>
}
    53be:	4640      	mov	r0, r8
    53c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    53c4:	20000a24 	.word	0x20000a24
    53c8:	20000a4c 	.word	0x20000a4c

000053cc <end_thread>:
		ready_thread(thread);
	}
}

static void end_thread(struct k_thread *thread)
{
    53cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* We hold the lock, and the thread is known not to be running
	 * anywhere.
	 */
	if ((thread->base.thread_state & _THREAD_DEAD) == 0U) {
    53ce:	7b43      	ldrb	r3, [r0, #13]
    53d0:	f013 0f08 	tst.w	r3, #8
    53d4:	d145      	bne.n	5462 <end_thread+0x96>
    53d6:	4605      	mov	r5, r0
		thread->base.thread_state |= _THREAD_DEAD;
    53d8:	f043 0308 	orr.w	r3, r3, #8
		thread->base.thread_state &= ~_THREAD_ABORTING;
    53dc:	f003 03df 	and.w	r3, r3, #223	; 0xdf
    53e0:	7343      	strb	r3, [r0, #13]
		if (z_is_thread_queued(thread)) {
    53e2:	f013 0f80 	tst.w	r3, #128	; 0x80
    53e6:	d114      	bne.n	5412 <end_thread+0x46>
			dequeue_thread(&_kernel.ready_q.runq, thread);
		}
		if (thread->base.pended_on != NULL) {
    53e8:	68ab      	ldr	r3, [r5, #8]
    53ea:	b15b      	cbz	r3, 5404 <end_thread+0x38>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    53ec:	4628      	mov	r0, r5
    53ee:	f001 ffd4 	bl	739a <pended_on_thread>
    53f2:	4629      	mov	r1, r5
    53f4:	f002 f811 	bl	741a <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    53f8:	7b6b      	ldrb	r3, [r5, #13]
    53fa:	f023 0302 	bic.w	r3, r3, #2
    53fe:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
    5400:	2300      	movs	r3, #0
    5402:	60ab      	str	r3, [r5, #8]
    5404:	f105 0018 	add.w	r0, r5, #24
    5408:	f002 f951 	bl	76ae <z_abort_timeout>
			unpend_thread_no_timeout(thread);
		}
		(void)z_abort_thread_timeout(thread);
		unpend_all(&thread->join_queue);
    540c:	f105 0758 	add.w	r7, r5, #88	; 0x58
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    5410:	e01c      	b.n	544c <end_thread+0x80>
	thread->base.thread_state &= ~_THREAD_QUEUED;
    5412:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    5416:	7343      	strb	r3, [r0, #13]
		_priq_run_remove(pq, thread);
    5418:	4601      	mov	r1, r0
    541a:	4812      	ldr	r0, [pc, #72]	; (5464 <end_thread+0x98>)
    541c:	f001 fffd 	bl	741a <z_priq_dumb_remove>
}
    5420:	e7e2      	b.n	53e8 <end_thread+0x1c>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    5422:	4620      	mov	r0, r4
    5424:	f001 ffb9 	bl	739a <pended_on_thread>
    5428:	4621      	mov	r1, r4
    542a:	f001 fff6 	bl	741a <z_priq_dumb_remove>
    542e:	7b63      	ldrb	r3, [r4, #13]
    5430:	f023 0302 	bic.w	r3, r3, #2
    5434:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    5436:	2600      	movs	r6, #0
    5438:	60a6      	str	r6, [r4, #8]
    543a:	f104 0018 	add.w	r0, r4, #24
    543e:	f002 f936 	bl	76ae <z_abort_timeout>
    5442:	f8c4 60ac 	str.w	r6, [r4, #172]	; 0xac
		ready_thread(thread);
    5446:	4620      	mov	r0, r4
    5448:	f7ff ff02 	bl	5250 <ready_thread>
	return list->head == list;
    544c:	683c      	ldr	r4, [r7, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    544e:	42bc      	cmp	r4, r7
    5450:	d001      	beq.n	5456 <end_thread+0x8a>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
    5452:	2c00      	cmp	r4, #0
    5454:	d1e5      	bne.n	5422 <end_thread+0x56>
		update_cache(1);
    5456:	2001      	movs	r0, #1
    5458:	f7ff fdac 	bl	4fb4 <update_cache>

		SYS_PORT_TRACING_FUNC(k_thread, sched_abort, thread);

		z_thread_monitor_exit(thread);
    545c:	4628      	mov	r0, r5
    545e:	f7ff f98d 	bl	477c <z_thread_monitor_exit>
		z_thread_perms_all_clear(thread);
		z_object_uninit(thread->stack_obj);
		z_object_uninit(thread);
#endif
	}
}
    5462:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5464:	20000a4c 	.word	0x20000a4c

00005468 <z_sched_init>:
{
    5468:	b508      	push	{r3, lr}
	list->head = (sys_dnode_t *)list;
    546a:	4b05      	ldr	r3, [pc, #20]	; (5480 <z_sched_init+0x18>)
    546c:	f103 0228 	add.w	r2, r3, #40	; 0x28
    5470:	629a      	str	r2, [r3, #40]	; 0x28
	list->tail = (sys_dnode_t *)list;
    5472:	62da      	str	r2, [r3, #44]	; 0x2c
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    5474:	2100      	movs	r1, #0
    5476:	4608      	mov	r0, r1
    5478:	f7ff fd2c 	bl	4ed4 <k_sched_time_slice_set>
}
    547c:	bd08      	pop	{r3, pc}
    547e:	bf00      	nop
    5480:	20000a24 	.word	0x20000a24

00005484 <z_impl_k_yield>:
{
    5484:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
    5486:	f04f 0320 	mov.w	r3, #32
    548a:	f3ef 8611 	mrs	r6, BASEPRI
    548e:	f383 8811 	msr	BASEPRI, r3
    5492:	f3bf 8f6f 	isb	sy
		dequeue_thread(&_kernel.ready_q.runq,
    5496:	4c1c      	ldr	r4, [pc, #112]	; (5508 <z_impl_k_yield+0x84>)
    5498:	68a1      	ldr	r1, [r4, #8]
	thread->base.thread_state &= ~_THREAD_QUEUED;
    549a:	7b4b      	ldrb	r3, [r1, #13]
    549c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    54a0:	734b      	strb	r3, [r1, #13]
		_priq_run_remove(pq, thread);
    54a2:	f104 0728 	add.w	r7, r4, #40	; 0x28
    54a6:	4638      	mov	r0, r7
    54a8:	f001 ffb7 	bl	741a <z_priq_dumb_remove>
	queue_thread(&_kernel.ready_q.runq, _current);
    54ac:	68a5      	ldr	r5, [r4, #8]
	thread->base.thread_state |= _THREAD_QUEUED;
    54ae:	7b6b      	ldrb	r3, [r5, #13]
    54b0:	f063 037f 	orn	r3, r3, #127	; 0x7f
    54b4:	736b      	strb	r3, [r5, #13]
	return list->head == list;
    54b6:	6aa4      	ldr	r4, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
    54b8:	42bc      	cmp	r4, r7
    54ba:	d023      	beq.n	5504 <z_impl_k_yield+0x80>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    54bc:	b16c      	cbz	r4, 54da <z_impl_k_yield+0x56>
		if (z_sched_prio_cmp(thread, t) > 0) {
    54be:	4621      	mov	r1, r4
    54c0:	4628      	mov	r0, r5
    54c2:	f001 ff6c 	bl	739e <z_sched_prio_cmp>
    54c6:	2800      	cmp	r0, #0
    54c8:	dc16      	bgt.n	54f8 <z_impl_k_yield+0x74>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    54ca:	b134      	cbz	r4, 54da <z_impl_k_yield+0x56>
	return (node == list->tail) ? NULL : node->next;
    54cc:	4b0e      	ldr	r3, [pc, #56]	; (5508 <z_impl_k_yield+0x84>)
    54ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    54d0:	429c      	cmp	r4, r3
    54d2:	d002      	beq.n	54da <z_impl_k_yield+0x56>
    54d4:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    54d6:	2c00      	cmp	r4, #0
    54d8:	d1f0      	bne.n	54bc <z_impl_k_yield+0x38>
	sys_dnode_t *const tail = list->tail;
    54da:	4b0b      	ldr	r3, [pc, #44]	; (5508 <z_impl_k_yield+0x84>)
    54dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	node->next = list;
    54de:	f103 0128 	add.w	r1, r3, #40	; 0x28
    54e2:	6029      	str	r1, [r5, #0]
	node->prev = tail;
    54e4:	606a      	str	r2, [r5, #4]
	tail->next = node;
    54e6:	6015      	str	r5, [r2, #0]
	list->tail = node;
    54e8:	62dd      	str	r5, [r3, #44]	; 0x2c
	update_cache(1);
    54ea:	2001      	movs	r0, #1
    54ec:	f7ff fd62 	bl	4fb4 <update_cache>
    54f0:	4630      	mov	r0, r6
    54f2:	f7fd f897 	bl	2624 <arch_swap>
}
    54f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	sys_dnode_t *const prev = successor->prev;
    54f8:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    54fa:	606b      	str	r3, [r5, #4]
	node->next = successor;
    54fc:	602c      	str	r4, [r5, #0]
	prev->next = node;
    54fe:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    5500:	6065      	str	r5, [r4, #4]
}
    5502:	e7f2      	b.n	54ea <z_impl_k_yield+0x66>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    5504:	2400      	movs	r4, #0
    5506:	e7d9      	b.n	54bc <z_impl_k_yield+0x38>
    5508:	20000a24 	.word	0x20000a24

0000550c <z_tick_sleep>:
{
    550c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5510:	4604      	mov	r4, r0
    5512:	460d      	mov	r5, r1
	if (ticks == 0) {
    5514:	ea54 0105 	orrs.w	r1, r4, r5
    5518:	d037      	beq.n	558a <z_tick_sleep+0x7e>
	if (Z_TICK_ABS(ticks) <= 0) {
    551a:	f06f 0101 	mvn.w	r1, #1
    551e:	1a0a      	subs	r2, r1, r0
    5520:	f04f 31ff 	mov.w	r1, #4294967295
    5524:	eb61 0305 	sbc.w	r3, r1, r5
    5528:	2a01      	cmp	r2, #1
    552a:	f173 0300 	sbcs.w	r3, r3, #0
    552e:	db30      	blt.n	5592 <z_tick_sleep+0x86>
		expected_wakeup_ticks = Z_TICK_ABS(ticks);
    5530:	f06f 0601 	mvn.w	r6, #1
    5534:	1a36      	subs	r6, r6, r0
    5536:	f04f 0320 	mov.w	r3, #32
    553a:	f3ef 8811 	mrs	r8, BASEPRI
    553e:	f383 8811 	msr	BASEPRI, r3
    5542:	f3bf 8f6f 	isb	sy
	pending_current = _current;
    5546:	4f16      	ldr	r7, [pc, #88]	; (55a0 <z_tick_sleep+0x94>)
    5548:	68b8      	ldr	r0, [r7, #8]
    554a:	4b16      	ldr	r3, [pc, #88]	; (55a4 <z_tick_sleep+0x98>)
    554c:	6018      	str	r0, [r3, #0]
	unready_thread(_current);
    554e:	f7ff fd57 	bl	5000 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    5552:	68b8      	ldr	r0, [r7, #8]
	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
    5554:	4622      	mov	r2, r4
    5556:	462b      	mov	r3, r5
    5558:	4913      	ldr	r1, [pc, #76]	; (55a8 <z_tick_sleep+0x9c>)
    555a:	3018      	adds	r0, #24
    555c:	f000 f904 	bl	5768 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    5560:	68ba      	ldr	r2, [r7, #8]
	thread->base.thread_state |= _THREAD_SUSPENDED;
    5562:	7b53      	ldrb	r3, [r2, #13]
    5564:	f043 0310 	orr.w	r3, r3, #16
    5568:	7353      	strb	r3, [r2, #13]
    556a:	4640      	mov	r0, r8
    556c:	f7fd f85a 	bl	2624 <arch_swap>
	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
    5570:	2500      	movs	r5, #0
    5572:	f002 f8fb 	bl	776c <sys_clock_tick_get_32>
    5576:	1a34      	subs	r4, r6, r0
    5578:	f165 0500 	sbc.w	r5, r5, #0
	if (ticks > 0) {
    557c:	2c01      	cmp	r4, #1
    557e:	f175 0300 	sbcs.w	r3, r5, #0
    5582:	da0a      	bge.n	559a <z_tick_sleep+0x8e>
	return 0;
    5584:	2000      	movs	r0, #0
}
    5586:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	z_impl_k_yield();
    558a:	f7ff ff7b 	bl	5484 <z_impl_k_yield>
		return 0;
    558e:	2000      	movs	r0, #0
    5590:	e7f9      	b.n	5586 <z_tick_sleep+0x7a>
		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
    5592:	f002 f8eb 	bl	776c <sys_clock_tick_get_32>
    5596:	1906      	adds	r6, r0, r4
    5598:	e7cd      	b.n	5536 <z_tick_sleep+0x2a>
		return ticks;
    559a:	4620      	mov	r0, r4
    559c:	e7f3      	b.n	5586 <z_tick_sleep+0x7a>
    559e:	bf00      	nop
    55a0:	20000a24 	.word	0x20000a24
    55a4:	20000a60 	.word	0x20000a60
    55a8:	00007507 	.word	0x00007507

000055ac <z_impl_k_sleep>:
{
    55ac:	b538      	push	{r3, r4, r5, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    55ae:	f1b1 3fff 	cmp.w	r1, #4294967295
    55b2:	bf08      	it	eq
    55b4:	f1b0 3fff 	cmpeq.w	r0, #4294967295
    55b8:	d01a      	beq.n	55f0 <z_impl_k_sleep+0x44>
	ticks = z_tick_sleep(ticks);
    55ba:	f7ff ffa7 	bl	550c <z_tick_sleep>
	int32_t ret = k_ticks_to_ms_floor64(ticks);
    55be:	4604      	mov	r4, r0
    55c0:	17c5      	asrs	r5, r0, #31
			return (t * to_hz + off) / from_hz;
    55c2:	0169      	lsls	r1, r5, #5
    55c4:	0143      	lsls	r3, r0, #5
    55c6:	ea41 62d0 	orr.w	r2, r1, r0, lsr #27
    55ca:	1a18      	subs	r0, r3, r0
    55cc:	eb62 0305 	sbc.w	r3, r2, r5
    55d0:	009a      	lsls	r2, r3, #2
    55d2:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
    55d6:	0081      	lsls	r1, r0, #2
    55d8:	4613      	mov	r3, r2
    55da:	1908      	adds	r0, r1, r4
    55dc:	eb45 0303 	adc.w	r3, r5, r3
    55e0:	00da      	lsls	r2, r3, #3
    55e2:	ea42 7250 	orr.w	r2, r2, r0, lsr #29
    55e6:	00c1      	lsls	r1, r0, #3
    55e8:	0bc8      	lsrs	r0, r1, #15
    55ea:	ea40 4042 	orr.w	r0, r0, r2, lsl #17
}
    55ee:	bd38      	pop	{r3, r4, r5, pc}
		k_thread_suspend(_current);
    55f0:	4b03      	ldr	r3, [pc, #12]	; (5600 <z_impl_k_sleep+0x54>)
    55f2:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    55f4:	f7ff fd34 	bl	5060 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    55f8:	f04f 30ff 	mov.w	r0, #4294967295
    55fc:	e7f7      	b.n	55ee <z_impl_k_sleep+0x42>
    55fe:	bf00      	nop
    5600:	20000a24 	.word	0x20000a24

00005604 <z_impl_k_current_get>:
}
    5604:	4b01      	ldr	r3, [pc, #4]	; (560c <z_impl_k_current_get+0x8>)
    5606:	6898      	ldr	r0, [r3, #8]
    5608:	4770      	bx	lr
    560a:	bf00      	nop
    560c:	20000a24 	.word	0x20000a24

00005610 <z_impl_k_is_preempt_thread>:
    5610:	f3ef 8305 	mrs	r3, IPSR
	return !arch_is_in_isr() && is_preempt(_current);
    5614:	b933      	cbnz	r3, 5624 <z_impl_k_is_preempt_thread+0x14>
    5616:	4b05      	ldr	r3, [pc, #20]	; (562c <z_impl_k_is_preempt_thread+0x1c>)
    5618:	689b      	ldr	r3, [r3, #8]
	return thread->base.preempt <= _PREEMPT_THRESHOLD;
    561a:	89db      	ldrh	r3, [r3, #14]
	return !arch_is_in_isr() && is_preempt(_current);
    561c:	2b7f      	cmp	r3, #127	; 0x7f
    561e:	d803      	bhi.n	5628 <z_impl_k_is_preempt_thread+0x18>
    5620:	2001      	movs	r0, #1
    5622:	4770      	bx	lr
    5624:	2000      	movs	r0, #0
    5626:	4770      	bx	lr
    5628:	2000      	movs	r0, #0
}
    562a:	4770      	bx	lr
    562c:	20000a24 	.word	0x20000a24

00005630 <z_thread_abort>:

void z_thread_abort(struct k_thread *thread)
{
    5630:	b538      	push	{r3, r4, r5, lr}
    5632:	f04f 0320 	mov.w	r3, #32
    5636:	f3ef 8511 	mrs	r5, BASEPRI
    563a:	f383 8811 	msr	BASEPRI, r3
    563e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
    5642:	7b43      	ldrb	r3, [r0, #13]
    5644:	f013 0f08 	tst.w	r3, #8
    5648:	d004      	beq.n	5654 <z_thread_abort+0x24>
	__asm__ volatile(
    564a:	f385 8811 	msr	BASEPRI, r5
    564e:	f3bf 8f6f 	isb	sy
	if (thread == _current && !arch_is_in_isr()) {
		z_swap(&sched_spinlock, key);
		__ASSERT(false, "aborted _current back from dead");
	}
	k_spin_unlock(&sched_spinlock, key);
}
    5652:	bd38      	pop	{r3, r4, r5, pc}
    5654:	4604      	mov	r4, r0
	end_thread(thread);
    5656:	f7ff feb9 	bl	53cc <end_thread>
	if (thread == _current && !arch_is_in_isr()) {
    565a:	4b08      	ldr	r3, [pc, #32]	; (567c <z_thread_abort+0x4c>)
    565c:	689b      	ldr	r3, [r3, #8]
    565e:	42a3      	cmp	r3, r4
    5660:	d004      	beq.n	566c <z_thread_abort+0x3c>
    5662:	f385 8811 	msr	BASEPRI, r5
    5666:	f3bf 8f6f 	isb	sy
    566a:	e7f2      	b.n	5652 <z_thread_abort+0x22>
    566c:	f3ef 8305 	mrs	r3, IPSR
    5670:	2b00      	cmp	r3, #0
    5672:	d1f6      	bne.n	5662 <z_thread_abort+0x32>
    5674:	4628      	mov	r0, r5
    5676:	f7fc ffd5 	bl	2624 <arch_swap>
	return ret;
    567a:	e7f2      	b.n	5662 <z_thread_abort+0x32>
    567c:	20000a24 	.word	0x20000a24

00005680 <z_sched_wait>:
	return ret;
}

int z_sched_wait(struct k_spinlock *lock, k_spinlock_key_t key,
		 _wait_q_t *wait_q, k_timeout_t timeout, void **data)
{
    5680:	b5d0      	push	{r4, r6, r7, lr}
    5682:	b082      	sub	sp, #8
    5684:	9c08      	ldr	r4, [sp, #32]
	int ret = z_pend_curr(lock, key, wait_q, timeout);
    5686:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
    568a:	e9cd 6700 	strd	r6, r7, [sp]
    568e:	f7ff fcd3 	bl	5038 <z_pend_curr>

	if (data != NULL) {
    5692:	b11c      	cbz	r4, 569c <z_sched_wait+0x1c>
		*data = _current->base.swap_data;
    5694:	4b02      	ldr	r3, [pc, #8]	; (56a0 <z_sched_wait+0x20>)
    5696:	689b      	ldr	r3, [r3, #8]
    5698:	695b      	ldr	r3, [r3, #20]
    569a:	6023      	str	r3, [r4, #0]
	}
	return ret;
}
    569c:	b002      	add	sp, #8
    569e:	bdd0      	pop	{r4, r6, r7, pc}
    56a0:	20000a24 	.word	0x20000a24

000056a4 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    56a4:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    56a6:	4806      	ldr	r0, [pc, #24]	; (56c0 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    56a8:	4a06      	ldr	r2, [pc, #24]	; (56c4 <z_data_copy+0x20>)
    56aa:	1a12      	subs	r2, r2, r0
    56ac:	4906      	ldr	r1, [pc, #24]	; (56c8 <z_data_copy+0x24>)
    56ae:	f001 f9d0 	bl	6a52 <memcpy>
#ifdef CONFIG_ARCH_HAS_RAMFUNC_SUPPORT
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    56b2:	4a06      	ldr	r2, [pc, #24]	; (56cc <z_data_copy+0x28>)
    56b4:	4906      	ldr	r1, [pc, #24]	; (56d0 <z_data_copy+0x2c>)
    56b6:	4807      	ldr	r0, [pc, #28]	; (56d4 <z_data_copy+0x30>)
    56b8:	f001 f9cb 	bl	6a52 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    56bc:	bd08      	pop	{r3, pc}
    56be:	bf00      	nop
    56c0:	20000000 	.word	0x20000000
    56c4:	20000054 	.word	0x20000054
    56c8:	000083fc 	.word	0x000083fc
    56cc:	00000000 	.word	0x00000000
    56d0:	000083fc 	.word	0x000083fc
    56d4:	20000000 	.word	0x20000000

000056d8 <first>:
	return list->head == list;
    56d8:	4b03      	ldr	r3, [pc, #12]	; (56e8 <first+0x10>)
    56da:	6818      	ldr	r0, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    56dc:	4298      	cmp	r0, r3
    56de:	d000      	beq.n	56e2 <first+0xa>
static struct _timeout *first(void)
{
	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);

	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
}
    56e0:	4770      	bx	lr
    56e2:	2000      	movs	r0, #0
	return t == NULL ? NULL : CONTAINER_OF(t, struct _timeout, node);
    56e4:	e7fc      	b.n	56e0 <first+0x8>
    56e6:	bf00      	nop
    56e8:	20000028 	.word	0x20000028

000056ec <next>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    56ec:	b130      	cbz	r0, 56fc <next+0x10>
	return (node == list->tail) ? NULL : node->next;
    56ee:	4a04      	ldr	r2, [pc, #16]	; (5700 <next+0x14>)
    56f0:	6852      	ldr	r2, [r2, #4]
    56f2:	4290      	cmp	r0, r2
    56f4:	d001      	beq.n	56fa <next+0xe>
    56f6:	6800      	ldr	r0, [r0, #0]
    56f8:	4770      	bx	lr
    56fa:	2000      	movs	r0, #0
static struct _timeout *next(struct _timeout *t)
{
	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);

	return n == NULL ? NULL : CONTAINER_OF(n, struct _timeout, node);
}
    56fc:	4770      	bx	lr
    56fe:	bf00      	nop
    5700:	20000028 	.word	0x20000028

00005704 <elapsed>:

	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
    5704:	b508      	push	{r3, lr}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    5706:	4b04      	ldr	r3, [pc, #16]	; (5718 <elapsed+0x14>)
    5708:	681b      	ldr	r3, [r3, #0]
    570a:	b10b      	cbz	r3, 5710 <elapsed+0xc>
    570c:	2000      	movs	r0, #0
}
    570e:	bd08      	pop	{r3, pc}
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    5710:	f7fc ff66 	bl	25e0 <sys_clock_elapsed>
    5714:	e7fb      	b.n	570e <elapsed+0xa>
    5716:	bf00      	nop
    5718:	20000a6c 	.word	0x20000a6c

0000571c <next_timeout>:

static int32_t next_timeout(void)
{
    571c:	b510      	push	{r4, lr}
	struct _timeout *to = first();
    571e:	f7ff ffdb 	bl	56d8 <first>
    5722:	4604      	mov	r4, r0
	int32_t ticks_elapsed = elapsed();
    5724:	f7ff ffee 	bl	5704 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
    5728:	b18c      	cbz	r4, 574e <next_timeout+0x32>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    572a:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    572e:	1a12      	subs	r2, r2, r0
    5730:	eb63 73e0 	sbc.w	r3, r3, r0, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
    5734:	2a01      	cmp	r2, #1
    5736:	f173 0100 	sbcs.w	r1, r3, #0
    573a:	db11      	blt.n	5760 <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    573c:	4610      	mov	r0, r2
    573e:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
    5742:	f173 0300 	sbcs.w	r3, r3, #0
    5746:	db04      	blt.n	5752 <next_timeout+0x36>
    5748:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    574c:	e001      	b.n	5752 <next_timeout+0x36>
	int32_t ret = to == NULL ? MAX_WAIT
    574e:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    5752:	4b04      	ldr	r3, [pc, #16]	; (5764 <next_timeout+0x48>)
    5754:	691b      	ldr	r3, [r3, #16]
    5756:	b113      	cbz	r3, 575e <next_timeout+0x42>
    5758:	4283      	cmp	r3, r0
    575a:	da00      	bge.n	575e <next_timeout+0x42>
		ret = _current_cpu->slice_ticks;
    575c:	4618      	mov	r0, r3
	}
#endif
	return ret;
}
    575e:	bd10      	pop	{r4, pc}
	int32_t ret = to == NULL ? MAX_WAIT
    5760:	2000      	movs	r0, #0
    5762:	e7f6      	b.n	5752 <next_timeout+0x36>
    5764:	20000a24 	.word	0x20000a24

00005768 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    5768:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    576c:	b083      	sub	sp, #12
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    576e:	f1b3 3fff 	cmp.w	r3, #4294967295
    5772:	bf08      	it	eq
    5774:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    5778:	f000 8096 	beq.w	58a8 <z_add_timeout+0x140>
    577c:	4682      	mov	sl, r0
    577e:	4614      	mov	r4, r2
    5780:	461d      	mov	r5, r3
#ifdef CONFIG_KERNEL_COHERENCE
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    5782:	6081      	str	r1, [r0, #8]

	LOCKED(&timeout_lock) {
    5784:	2300      	movs	r3, #0
	__asm__ volatile(
    5786:	f04f 0220 	mov.w	r2, #32
    578a:	f3ef 8b11 	mrs	fp, BASEPRI
    578e:	f382 8811 	msr	BASEPRI, r2
    5792:	f3bf 8f6f 	isb	sy
    5796:	e02e      	b.n	57f6 <z_add_timeout+0x8e>

		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
		    Z_TICK_ABS(timeout.ticks) >= 0) {
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;

			to->dticks = MAX(1, ticks);
    5798:	2201      	movs	r2, #1
    579a:	2300      	movs	r3, #0
    579c:	e04b      	b.n	5836 <z_add_timeout+0xce>
		} else {
			to->dticks = timeout.ticks + 1 + elapsed();
    579e:	f7ff ffb1 	bl	5704 <elapsed>
    57a2:	1822      	adds	r2, r4, r0
    57a4:	eb45 73e0 	adc.w	r3, r5, r0, asr #31
    57a8:	3201      	adds	r2, #1
    57aa:	f143 0300 	adc.w	r3, r3, #0
    57ae:	f8ca 2010 	str.w	r2, [sl, #16]
    57b2:	f8ca 3014 	str.w	r3, [sl, #20]
    57b6:	e042      	b.n	583e <z_add_timeout+0xd6>
		}

		for (t = first(); t != NULL; t = next(t)) {
			if (t->dticks > to->dticks) {
				t->dticks -= to->dticks;
    57b8:	9b00      	ldr	r3, [sp, #0]
    57ba:	1ac2      	subs	r2, r0, r3
    57bc:	9b01      	ldr	r3, [sp, #4]
    57be:	eb61 0303 	sbc.w	r3, r1, r3
    57c2:	f8cc 2010 	str.w	r2, [ip, #16]
    57c6:	f8cc 3014 	str.w	r3, [ip, #20]
	sys_dnode_t *const prev = successor->prev;
    57ca:	f8dc 3004 	ldr.w	r3, [ip, #4]
	node->prev = prev;
    57ce:	f8ca 3004 	str.w	r3, [sl, #4]
	node->next = successor;
    57d2:	f8ca c000 	str.w	ip, [sl]
	prev->next = node;
    57d6:	f8c3 a000 	str.w	sl, [r3]
	successor->prev = node;
    57da:	f8cc a004 	str.w	sl, [ip, #4]
				break;
			}
			to->dticks -= t->dticks;
		}

		if (t == NULL) {
    57de:	f1bc 0f00 	cmp.w	ip, #0
    57e2:	d049      	beq.n	5878 <z_add_timeout+0x110>
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    57e4:	f7ff ff78 	bl	56d8 <first>
    57e8:	4582      	cmp	sl, r0
    57ea:	d050      	beq.n	588e <z_add_timeout+0x126>
	__asm__ volatile(
    57ec:	f38b 8811 	msr	BASEPRI, fp
    57f0:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    57f4:	2301      	movs	r3, #1
    57f6:	2b00      	cmp	r3, #0
    57f8:	d156      	bne.n	58a8 <z_add_timeout+0x140>
		    Z_TICK_ABS(timeout.ticks) >= 0) {
    57fa:	f06f 0301 	mvn.w	r3, #1
    57fe:	ebb3 0804 	subs.w	r8, r3, r4
    5802:	f04f 30ff 	mov.w	r0, #4294967295
    5806:	eb60 0905 	sbc.w	r9, r0, r5
		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
    580a:	f1b8 0f00 	cmp.w	r8, #0
    580e:	f179 0300 	sbcs.w	r3, r9, #0
    5812:	dbc4      	blt.n	579e <z_add_timeout+0x36>
			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
    5814:	4a26      	ldr	r2, [pc, #152]	; (58b0 <z_add_timeout+0x148>)
    5816:	6813      	ldr	r3, [r2, #0]
    5818:	6852      	ldr	r2, [r2, #4]
    581a:	18e3      	adds	r3, r4, r3
    581c:	eb45 0202 	adc.w	r2, r5, r2
    5820:	f06f 0101 	mvn.w	r1, #1
    5824:	1ace      	subs	r6, r1, r3
    5826:	eb60 0702 	sbc.w	r7, r0, r2
			to->dticks = MAX(1, ticks);
    582a:	4632      	mov	r2, r6
    582c:	463b      	mov	r3, r7
    582e:	2e01      	cmp	r6, #1
    5830:	f177 0100 	sbcs.w	r1, r7, #0
    5834:	dbb0      	blt.n	5798 <z_add_timeout+0x30>
    5836:	f8ca 2010 	str.w	r2, [sl, #16]
    583a:	f8ca 3014 	str.w	r3, [sl, #20]
		for (t = first(); t != NULL; t = next(t)) {
    583e:	f7ff ff4b 	bl	56d8 <first>
    5842:	4684      	mov	ip, r0
    5844:	f1bc 0f00 	cmp.w	ip, #0
    5848:	d0c9      	beq.n	57de <z_add_timeout+0x76>
			if (t->dticks > to->dticks) {
    584a:	e9dc 0104 	ldrd	r0, r1, [ip, #16]
    584e:	e9da 2304 	ldrd	r2, r3, [sl, #16]
    5852:	e9cd 2300 	strd	r2, r3, [sp]
    5856:	4282      	cmp	r2, r0
    5858:	418b      	sbcs	r3, r1
    585a:	dbad      	blt.n	57b8 <z_add_timeout+0x50>
			to->dticks -= t->dticks;
    585c:	9b00      	ldr	r3, [sp, #0]
    585e:	1a1a      	subs	r2, r3, r0
    5860:	9b01      	ldr	r3, [sp, #4]
    5862:	eb63 0301 	sbc.w	r3, r3, r1
    5866:	f8ca 2010 	str.w	r2, [sl, #16]
    586a:	f8ca 3014 	str.w	r3, [sl, #20]
		for (t = first(); t != NULL; t = next(t)) {
    586e:	4660      	mov	r0, ip
    5870:	f7ff ff3c 	bl	56ec <next>
    5874:	4684      	mov	ip, r0
    5876:	e7e5      	b.n	5844 <z_add_timeout+0xdc>
	sys_dnode_t *const tail = list->tail;
    5878:	4b0e      	ldr	r3, [pc, #56]	; (58b4 <z_add_timeout+0x14c>)
    587a:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    587c:	f8ca 3000 	str.w	r3, [sl]
	node->prev = tail;
    5880:	f8ca 2004 	str.w	r2, [sl, #4]
	tail->next = node;
    5884:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
    5888:	f8c3 a004 	str.w	sl, [r3, #4]
}
    588c:	e7aa      	b.n	57e4 <z_add_timeout+0x7c>
			 * last announcement, and slice_ticks is based
			 * on that. It means that the time remaining for
			 * the next announcement can be less than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    588e:	f7ff ff45 	bl	571c <next_timeout>

			if (next_time == 0 ||
    5892:	4603      	mov	r3, r0
    5894:	b118      	cbz	r0, 589e <z_add_timeout+0x136>
			    _current_cpu->slice_ticks != next_time) {
    5896:	4a08      	ldr	r2, [pc, #32]	; (58b8 <z_add_timeout+0x150>)
    5898:	6912      	ldr	r2, [r2, #16]
			if (next_time == 0 ||
    589a:	4282      	cmp	r2, r0
    589c:	d0a6      	beq.n	57ec <z_add_timeout+0x84>
				sys_clock_set_timeout(next_time, false);
    589e:	2100      	movs	r1, #0
    58a0:	4618      	mov	r0, r3
    58a2:	f7fc fe6d 	bl	2580 <sys_clock_set_timeout>
    58a6:	e7a1      	b.n	57ec <z_add_timeout+0x84>
#else
			sys_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    58a8:	b003      	add	sp, #12
    58aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    58ae:	bf00      	nop
    58b0:	200002a0 	.word	0x200002a0
    58b4:	20000028 	.word	0x20000028
    58b8:	20000a24 	.word	0x20000a24

000058bc <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
    58bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    58be:	4604      	mov	r4, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    58c0:	f7ff fc7a 	bl	51b8 <z_time_slice>
	__asm__ volatile(
    58c4:	f04f 0320 	mov.w	r3, #32
    58c8:	f3ef 8511 	mrs	r5, BASEPRI
    58cc:	f383 8811 	msr	BASEPRI, r3
    58d0:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    58d4:	4b28      	ldr	r3, [pc, #160]	; (5978 <sys_clock_announce+0xbc>)
    58d6:	601c      	str	r4, [r3, #0]

	while (first() != NULL && first()->dticks <= announce_remaining) {
    58d8:	f7ff fefe 	bl	56d8 <first>
    58dc:	4604      	mov	r4, r0
    58de:	b350      	cbz	r0, 5936 <sys_clock_announce+0x7a>
    58e0:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
    58e4:	4b24      	ldr	r3, [pc, #144]	; (5978 <sys_clock_announce+0xbc>)
    58e6:	681b      	ldr	r3, [r3, #0]
    58e8:	17d9      	asrs	r1, r3, #31
    58ea:	42b3      	cmp	r3, r6
    58ec:	eb71 0207 	sbcs.w	r2, r1, r7
    58f0:	db21      	blt.n	5936 <sys_clock_announce+0x7a>
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    58f2:	4a22      	ldr	r2, [pc, #136]	; (597c <sys_clock_announce+0xc0>)
    58f4:	e9d2 0100 	ldrd	r0, r1, [r2]
    58f8:	1980      	adds	r0, r0, r6
    58fa:	eb41 71e6 	adc.w	r1, r1, r6, asr #31
    58fe:	e9c2 0100 	strd	r0, r1, [r2]
		announce_remaining -= dt;
    5902:	1b9b      	subs	r3, r3, r6
    5904:	4a1c      	ldr	r2, [pc, #112]	; (5978 <sys_clock_announce+0xbc>)
    5906:	6013      	str	r3, [r2, #0]
		t->dticks = 0;
    5908:	2200      	movs	r2, #0
    590a:	2300      	movs	r3, #0
    590c:	e9c4 2304 	strd	r2, r3, [r4, #16]
		remove_timeout(t);
    5910:	4620      	mov	r0, r4
    5912:	f001 feb5 	bl	7680 <remove_timeout>
	__asm__ volatile(
    5916:	f385 8811 	msr	BASEPRI, r5
    591a:	f3bf 8f6f 	isb	sy

		k_spin_unlock(&timeout_lock, key);
		t->fn(t);
    591e:	68a3      	ldr	r3, [r4, #8]
    5920:	4620      	mov	r0, r4
    5922:	4798      	blx	r3
	__asm__ volatile(
    5924:	f04f 0320 	mov.w	r3, #32
    5928:	f3ef 8511 	mrs	r5, BASEPRI
    592c:	f383 8811 	msr	BASEPRI, r3
    5930:	f3bf 8f6f 	isb	sy
    5934:	e7d0      	b.n	58d8 <sys_clock_announce+0x1c>
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
    5936:	b144      	cbz	r4, 594a <sys_clock_announce+0x8e>
		first()->dticks -= announce_remaining;
    5938:	4b0f      	ldr	r3, [pc, #60]	; (5978 <sys_clock_announce+0xbc>)
    593a:	6819      	ldr	r1, [r3, #0]
    593c:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    5940:	1a52      	subs	r2, r2, r1
    5942:	eb63 73e1 	sbc.w	r3, r3, r1, asr #31
    5946:	e9c4 2304 	strd	r2, r3, [r4, #16]
	}

	curr_tick += announce_remaining;
    594a:	480c      	ldr	r0, [pc, #48]	; (597c <sys_clock_announce+0xc0>)
    594c:	490a      	ldr	r1, [pc, #40]	; (5978 <sys_clock_announce+0xbc>)
    594e:	680c      	ldr	r4, [r1, #0]
    5950:	e9d0 2300 	ldrd	r2, r3, [r0]
    5954:	1912      	adds	r2, r2, r4
    5956:	eb43 73e4 	adc.w	r3, r3, r4, asr #31
    595a:	e9c0 2300 	strd	r2, r3, [r0]
	announce_remaining = 0;
    595e:	2400      	movs	r4, #0
    5960:	600c      	str	r4, [r1, #0]

	sys_clock_set_timeout(next_timeout(), false);
    5962:	f7ff fedb 	bl	571c <next_timeout>
    5966:	4621      	mov	r1, r4
    5968:	f7fc fe0a 	bl	2580 <sys_clock_set_timeout>
	__asm__ volatile(
    596c:	f385 8811 	msr	BASEPRI, r5
    5970:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    5974:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    5976:	bf00      	nop
    5978:	20000a6c 	.word	0x20000a6c
    597c:	200002a0 	.word	0x200002a0

00005980 <sys_clock_tick_get>:

int64_t sys_clock_tick_get(void)
{
    5980:	b510      	push	{r4, lr}
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
    5982:	2100      	movs	r1, #0
	__asm__ volatile(
    5984:	f04f 0320 	mov.w	r3, #32
    5988:	f3ef 8411 	mrs	r4, BASEPRI
    598c:	f383 8811 	msr	BASEPRI, r3
    5990:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;
    5994:	2200      	movs	r2, #0
    5996:	2300      	movs	r3, #0
	LOCKED(&timeout_lock) {
    5998:	b969      	cbnz	r1, 59b6 <sys_clock_tick_get+0x36>
		t = curr_tick + sys_clock_elapsed();
    599a:	f7fc fe21 	bl	25e0 <sys_clock_elapsed>
    599e:	4b07      	ldr	r3, [pc, #28]	; (59bc <sys_clock_tick_get+0x3c>)
    59a0:	e9d3 2300 	ldrd	r2, r3, [r3]
    59a4:	1812      	adds	r2, r2, r0
    59a6:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
    59aa:	f384 8811 	msr	BASEPRI, r4
    59ae:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    59b2:	2101      	movs	r1, #1
    59b4:	e7f0      	b.n	5998 <sys_clock_tick_get+0x18>
	}
	return t;
}
    59b6:	4610      	mov	r0, r2
    59b8:	4619      	mov	r1, r3
    59ba:	bd10      	pop	{r4, pc}
    59bc:	200002a0 	.word	0x200002a0

000059c0 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
    59c0:	b510      	push	{r4, lr}
    59c2:	4604      	mov	r4, r0

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
    59c4:	e9d0 230a 	ldrd	r2, r3, [r0, #40]	; 0x28
    59c8:	ea52 0103 	orrs.w	r1, r2, r3
    59cc:	d005      	beq.n	59da <z_timer_expiration_handler+0x1a>
    59ce:	f1b3 3fff 	cmp.w	r3, #4294967295
    59d2:	bf08      	it	eq
    59d4:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    59d8:	d116      	bne.n	5a08 <z_timer_expiration_handler+0x48>
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
    59da:	6b23      	ldr	r3, [r4, #48]	; 0x30
    59dc:	3301      	adds	r3, #1
    59de:	6323      	str	r3, [r4, #48]	; 0x30

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
    59e0:	6a23      	ldr	r3, [r4, #32]
    59e2:	b10b      	cbz	r3, 59e8 <z_timer_expiration_handler+0x28>
		timer->expiry_fn(timer);
    59e4:	4620      	mov	r0, r4
    59e6:	4798      	blx	r3
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    59e8:	f104 0318 	add.w	r3, r4, #24
	return list->head == list;
    59ec:	69a4      	ldr	r4, [r4, #24]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    59ee:	42a3      	cmp	r3, r4
    59f0:	d009      	beq.n	5a06 <z_timer_expiration_handler+0x46>
		return;
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
    59f2:	b144      	cbz	r4, 5a06 <z_timer_expiration_handler+0x46>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
    59f4:	4620      	mov	r0, r4
    59f6:	f001 fcdc 	bl	73b2 <z_unpend_thread_no_timeout>
    59fa:	2300      	movs	r3, #0
    59fc:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac

	arch_thread_return_value_set(thread, 0);

	z_ready_thread(thread);
    5a00:	4620      	mov	r0, r4
    5a02:	f001 fd64 	bl	74ce <z_ready_thread>
}
    5a06:	bd10      	pop	{r4, pc}
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    5a08:	4901      	ldr	r1, [pc, #4]	; (5a10 <z_timer_expiration_handler+0x50>)
    5a0a:	f7ff fead 	bl	5768 <z_add_timeout>
    5a0e:	e7e4      	b.n	59da <z_timer_expiration_handler+0x1a>
    5a10:	000059c1 	.word	0x000059c1

00005a14 <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
    5a14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5a18:	b087      	sub	sp, #28
    5a1a:	4614      	mov	r4, r2
    5a1c:	461d      	mov	r5, r3
    5a1e:	e9dd 8910 	ldrd	r8, r9, [sp, #64]	; 0x40
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, start, timer);

	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
    5a22:	f1b3 3fff 	cmp.w	r3, #4294967295
    5a26:	bf08      	it	eq
    5a28:	f1b2 3fff 	cmpeq.w	r2, #4294967295
    5a2c:	d035      	beq.n	5a9a <z_impl_k_timer_start+0x86>
    5a2e:	4606      	mov	r6, r0
    5a30:	4613      	mov	r3, r2
    5a32:	462a      	mov	r2, r5
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    5a34:	f1b9 3fff 	cmp.w	r9, #4294967295
    5a38:	bf08      	it	eq
    5a3a:	f1b8 3fff 	cmpeq.w	r8, #4294967295
    5a3e:	d012      	beq.n	5a66 <z_impl_k_timer_start+0x52>
    5a40:	ea58 0109 	orrs.w	r1, r8, r9
    5a44:	d00f      	beq.n	5a66 <z_impl_k_timer_start+0x52>
	    Z_TICK_ABS(period.ticks) < 0) {
    5a46:	f06f 0701 	mvn.w	r7, #1
    5a4a:	ebb7 0708 	subs.w	r7, r7, r8
    5a4e:	9702      	str	r7, [sp, #8]
    5a50:	f04f 31ff 	mov.w	r1, #4294967295
    5a54:	eb61 0709 	sbc.w	r7, r1, r9
    5a58:	9703      	str	r7, [sp, #12]
	if (!K_TIMEOUT_EQ(period, K_FOREVER) && period.ticks != 0 &&
    5a5a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    5a5e:	2800      	cmp	r0, #0
    5a60:	f171 0100 	sbcs.w	r1, r1, #0
    5a64:	db1c      	blt.n	5aa0 <z_impl_k_timer_start+0x8c>
		period.ticks = MAX(period.ticks - 1, 1);
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
    5a66:	f06f 0101 	mvn.w	r1, #1
    5a6a:	ebb1 0a03 	subs.w	sl, r1, r3
    5a6e:	f04f 31ff 	mov.w	r1, #4294967295
    5a72:	eb61 0b02 	sbc.w	fp, r1, r2
    5a76:	f1ba 0f00 	cmp.w	sl, #0
    5a7a:	f17b 0100 	sbcs.w	r1, fp, #0
    5a7e:	db23      	blt.n	5ac8 <z_impl_k_timer_start+0xb4>
		duration.ticks = MAX(duration.ticks - 1, 0);
	}

	(void)z_abort_timeout(&timer->timeout);
    5a80:	4630      	mov	r0, r6
    5a82:	f001 fe14 	bl	76ae <z_abort_timeout>
	timer->period = period;
    5a86:	e9c6 890a 	strd	r8, r9, [r6, #40]	; 0x28
	timer->status = 0U;
    5a8a:	2300      	movs	r3, #0
    5a8c:	6333      	str	r3, [r6, #48]	; 0x30

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
    5a8e:	4622      	mov	r2, r4
    5a90:	462b      	mov	r3, r5
    5a92:	4917      	ldr	r1, [pc, #92]	; (5af0 <z_impl_k_timer_start+0xdc>)
    5a94:	4630      	mov	r0, r6
    5a96:	f7ff fe67 	bl	5768 <z_add_timeout>
		     duration);
}
    5a9a:	b007      	add	sp, #28
    5a9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		period.ticks = MAX(period.ticks - 1, 1);
    5aa0:	f118 31ff 	adds.w	r1, r8, #4294967295
    5aa4:	9104      	str	r1, [sp, #16]
    5aa6:	f149 31ff 	adc.w	r1, r9, #4294967295
    5aaa:	9105      	str	r1, [sp, #20]
    5aac:	e9dd 7804 	ldrd	r7, r8, [sp, #16]
    5ab0:	4638      	mov	r0, r7
    5ab2:	4641      	mov	r1, r8
    5ab4:	2f01      	cmp	r7, #1
    5ab6:	f178 0700 	sbcs.w	r7, r8, #0
    5aba:	db02      	blt.n	5ac2 <z_impl_k_timer_start+0xae>
    5abc:	4680      	mov	r8, r0
    5abe:	4689      	mov	r9, r1
    5ac0:	e7d1      	b.n	5a66 <z_impl_k_timer_start+0x52>
    5ac2:	2001      	movs	r0, #1
    5ac4:	2100      	movs	r1, #0
    5ac6:	e7f9      	b.n	5abc <z_impl_k_timer_start+0xa8>
		duration.ticks = MAX(duration.ticks - 1, 0);
    5ac8:	f113 33ff 	adds.w	r3, r3, #4294967295
    5acc:	9300      	str	r3, [sp, #0]
    5ace:	f142 33ff 	adc.w	r3, r2, #4294967295
    5ad2:	9301      	str	r3, [sp, #4]
    5ad4:	e9dd 0100 	ldrd	r0, r1, [sp]
    5ad8:	4602      	mov	r2, r0
    5ada:	460b      	mov	r3, r1
    5adc:	2800      	cmp	r0, #0
    5ade:	f171 0100 	sbcs.w	r1, r1, #0
    5ae2:	db02      	blt.n	5aea <z_impl_k_timer_start+0xd6>
    5ae4:	4614      	mov	r4, r2
    5ae6:	461d      	mov	r5, r3
    5ae8:	e7ca      	b.n	5a80 <z_impl_k_timer_start+0x6c>
    5aea:	2200      	movs	r2, #0
    5aec:	4613      	mov	r3, r2
    5aee:	e7f9      	b.n	5ae4 <z_impl_k_timer_start+0xd0>
    5af0:	000059c1 	.word	0x000059c1

00005af4 <boot_banner>:
#define BOOT_DELAY_BANNER ""
#endif

#if defined(CONFIG_BOOT_DELAY) || CONFIG_BOOT_DELAY > 0
void boot_banner(void)
{
    5af4:	b508      	push	{r3, lr}
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    5af6:	4a03      	ldr	r2, [pc, #12]	; (5b04 <boot_banner+0x10>)
    5af8:	4903      	ldr	r1, [pc, #12]	; (5b08 <boot_banner+0x14>)
    5afa:	4804      	ldr	r0, [pc, #16]	; (5b0c <boot_banner+0x18>)
    5afc:	f000 f860 	bl	5bc0 <printk>
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
    5b00:	bd08      	pop	{r3, pc}
    5b02:	bf00      	nop
    5b04:	00007ac0 	.word	0x00007ac0
    5b08:	000083b8 	.word	0x000083b8
    5b0c:	000083c8 	.word	0x000083c8

00005b10 <k_sys_work_q_init>:
			     CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(const struct device *dev)
{
    5b10:	b510      	push	{r4, lr}
    5b12:	b084      	sub	sp, #16
	ARG_UNUSED(dev);
	struct k_work_queue_config cfg = {
    5b14:	4b08      	ldr	r3, [pc, #32]	; (5b38 <k_sys_work_q_init+0x28>)
    5b16:	9302      	str	r3, [sp, #8]
    5b18:	2400      	movs	r4, #0
    5b1a:	f88d 400c 	strb.w	r4, [sp, #12]
		.name = "sysworkq",
		.no_yield = IS_ENABLED(CONFIG_SYSTEM_WORKQUEUE_NO_YIELD),
	};

	k_work_queue_start(&k_sys_work_q,
    5b1e:	ab02      	add	r3, sp, #8
    5b20:	9300      	str	r3, [sp, #0]
    5b22:	f04f 33ff 	mov.w	r3, #4294967295
    5b26:	f44f 6280 	mov.w	r2, #1024	; 0x400
    5b2a:	4904      	ldr	r1, [pc, #16]	; (5b3c <k_sys_work_q_init+0x2c>)
    5b2c:	4804      	ldr	r0, [pc, #16]	; (5b40 <k_sys_work_q_init+0x30>)
    5b2e:	f7ff f96d 	bl	4e0c <k_work_queue_start>
			    sys_work_q_stack,
			    K_KERNEL_STACK_SIZEOF(sys_work_q_stack),
			    CONFIG_SYSTEM_WORKQUEUE_PRIORITY, &cfg);
	return 0;
}
    5b32:	4620      	mov	r0, r4
    5b34:	b004      	add	sp, #16
    5b36:	bd10      	pop	{r4, pc}
    5b38:	000083f0 	.word	0x000083f0
    5b3c:	20001b40 	.word	0x20001b40
    5b40:	200002a8 	.word	0x200002a8

00005b44 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    5b44:	4602      	mov	r2, r0
    5b46:	b158      	cbz	r0, 5b60 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    5b48:	6843      	ldr	r3, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    5b4a:	f003 0303 	and.w	r3, r3, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    5b4e:	2b01      	cmp	r3, #1
    5b50:	d003      	beq.n	5b5a <sys_notify_validate+0x16>
    5b52:	2b03      	cmp	r3, #3
    5b54:	d107      	bne.n	5b66 <sys_notify_validate+0x22>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
    5b56:	6803      	ldr	r3, [r0, #0]
    5b58:	b143      	cbz	r3, 5b6c <sys_notify_validate+0x28>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
    5b5a:	2000      	movs	r0, #0
    5b5c:	6090      	str	r0, [r2, #8]
    5b5e:	4770      	bx	lr
		return -EINVAL;
    5b60:	f06f 0015 	mvn.w	r0, #21
    5b64:	4770      	bx	lr
	switch (sys_notify_get_method(notify)) {
    5b66:	f06f 0015 	mvn.w	r0, #21
    5b6a:	4770      	bx	lr
			rv = -EINVAL;
    5b6c:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
    5b70:	4770      	bx	lr

00005b72 <sys_notify_finalize>:

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
    5b72:	4603      	mov	r3, r0
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    5b74:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    5b76:	f002 0203 	and.w	r2, r2, #3
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
    5b7a:	6081      	str	r1, [r0, #8]
	switch (method) {
    5b7c:	2a03      	cmp	r2, #3
    5b7e:	d103      	bne.n	5b88 <sys_notify_finalize+0x16>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    5b80:	6800      	ldr	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    5b82:	2200      	movs	r2, #0
    5b84:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    5b86:	4770      	bx	lr
	sys_notify_generic_callback rv = NULL;
    5b88:	2000      	movs	r0, #0
    5b8a:	e7fa      	b.n	5b82 <sys_notify_finalize+0x10>

00005b8c <arch_printk_char_out>:
}
    5b8c:	2000      	movs	r0, #0
    5b8e:	4770      	bx	lr

00005b90 <str_out>:
{
    5b90:	b410      	push	{r4}
	if (ctx->str == NULL || ctx->count >= ctx->max) {
    5b92:	680c      	ldr	r4, [r1, #0]
    5b94:	b154      	cbz	r4, 5bac <str_out+0x1c>
    5b96:	688a      	ldr	r2, [r1, #8]
    5b98:	684b      	ldr	r3, [r1, #4]
    5b9a:	429a      	cmp	r2, r3
    5b9c:	da06      	bge.n	5bac <str_out+0x1c>
	if (ctx->count == ctx->max - 1) {
    5b9e:	3b01      	subs	r3, #1
    5ba0:	429a      	cmp	r2, r3
    5ba2:	d008      	beq.n	5bb6 <str_out+0x26>
		ctx->str[ctx->count++] = c;
    5ba4:	1c53      	adds	r3, r2, #1
    5ba6:	608b      	str	r3, [r1, #8]
    5ba8:	54a0      	strb	r0, [r4, r2]
    5baa:	e002      	b.n	5bb2 <str_out+0x22>
		ctx->count++;
    5bac:	688b      	ldr	r3, [r1, #8]
    5bae:	3301      	adds	r3, #1
    5bb0:	608b      	str	r3, [r1, #8]
}
    5bb2:	bc10      	pop	{r4}
    5bb4:	4770      	bx	lr
		ctx->str[ctx->count++] = '\0';
    5bb6:	1c53      	adds	r3, r2, #1
    5bb8:	608b      	str	r3, [r1, #8]
    5bba:	2300      	movs	r3, #0
    5bbc:	54a3      	strb	r3, [r4, r2]
    5bbe:	e7f8      	b.n	5bb2 <str_out+0x22>

00005bc0 <printk>:
{
    5bc0:	b40f      	push	{r0, r1, r2, r3}
    5bc2:	b500      	push	{lr}
    5bc4:	b083      	sub	sp, #12
    5bc6:	a904      	add	r1, sp, #16
    5bc8:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
    5bcc:	9101      	str	r1, [sp, #4]
	z_log_printk(fmt, ap);
    5bce:	f7fb fdfd 	bl	17cc <z_log_printk>
}
    5bd2:	b003      	add	sp, #12
    5bd4:	f85d eb04 	ldr.w	lr, [sp], #4
    5bd8:	b004      	add	sp, #16
    5bda:	4770      	bx	lr

00005bdc <snprintk>:
{
    5bdc:	b40c      	push	{r2, r3}
    5bde:	b500      	push	{lr}
    5be0:	b083      	sub	sp, #12
    5be2:	ab04      	add	r3, sp, #16
    5be4:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
    5be8:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
    5bea:	f7fa fcd9 	bl	5a0 <vsnprintk>
}
    5bee:	b003      	add	sp, #12
    5bf0:	f85d eb04 	ldr.w	lr, [sp], #4
    5bf4:	b002      	add	sp, #8
    5bf6:	4770      	bx	lr

00005bf8 <set_state>:
	mgr->flags = (state & ONOFF_STATE_MASK)
    5bf8:	f001 0307 	and.w	r3, r1, #7
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    5bfc:	8b01      	ldrh	r1, [r0, #24]
    5bfe:	f021 0107 	bic.w	r1, r1, #7
    5c02:	4319      	orrs	r1, r3
	mgr->flags = (state & ONOFF_STATE_MASK)
    5c04:	8301      	strh	r1, [r0, #24]
}
    5c06:	4770      	bx	lr

00005c08 <notify_monitors>:
{
    5c08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5c0c:	4606      	mov	r6, r0
    5c0e:	460f      	mov	r7, r1
    5c10:	4690      	mov	r8, r2
	return list->head;
    5c12:	6881      	ldr	r1, [r0, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    5c14:	b119      	cbz	r1, 5c1e <notify_monitors+0x16>
    5c16:	460c      	mov	r4, r1
Z_GENLIST_PEEK_NEXT(slist, snode)
    5c18:	b131      	cbz	r1, 5c28 <notify_monitors+0x20>
	return node->next;
    5c1a:	680c      	ldr	r4, [r1, #0]
    5c1c:	e004      	b.n	5c28 <notify_monitors+0x20>
    5c1e:	460c      	mov	r4, r1
    5c20:	e002      	b.n	5c28 <notify_monitors+0x20>
    5c22:	4623      	mov	r3, r4
    5c24:	4621      	mov	r1, r4
    5c26:	461c      	mov	r4, r3
    5c28:	b159      	cbz	r1, 5c42 <notify_monitors+0x3a>
		mon->callback(mgr, mon, state, res);
    5c2a:	684d      	ldr	r5, [r1, #4]
    5c2c:	4643      	mov	r3, r8
    5c2e:	463a      	mov	r2, r7
    5c30:	4630      	mov	r0, r6
    5c32:	47a8      	blx	r5
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    5c34:	2c00      	cmp	r4, #0
    5c36:	d0f4      	beq.n	5c22 <notify_monitors+0x1a>
    5c38:	4623      	mov	r3, r4
Z_GENLIST_PEEK_NEXT(slist, snode)
    5c3a:	2c00      	cmp	r4, #0
    5c3c:	d0f2      	beq.n	5c24 <notify_monitors+0x1c>
	return node->next;
    5c3e:	6823      	ldr	r3, [r4, #0]
    5c40:	e7f0      	b.n	5c24 <notify_monitors+0x1c>
}
    5c42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005c46 <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    5c46:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
    5c48:	f013 0307 	ands.w	r3, r3, #7
    5c4c:	d103      	bne.n	5c56 <process_recheck+0x10>
	return list->head;
    5c4e:	6802      	ldr	r2, [r0, #0]
	    && !sys_slist_is_empty(&mgr->clients)) {
    5c50:	b10a      	cbz	r2, 5c56 <process_recheck+0x10>
		evt = EVT_START;
    5c52:	2003      	movs	r0, #3
    5c54:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
    5c56:	2b02      	cmp	r3, #2
    5c58:	d003      	beq.n	5c62 <process_recheck+0x1c>
	} else if ((state == ONOFF_STATE_ERROR)
    5c5a:	2b01      	cmp	r3, #1
    5c5c:	d006      	beq.n	5c6c <process_recheck+0x26>
	int evt = EVT_NOP;
    5c5e:	2000      	movs	r0, #0
    5c60:	4770      	bx	lr
		   && (mgr->refs == 0U)) {
    5c62:	8b42      	ldrh	r2, [r0, #26]
    5c64:	2a00      	cmp	r2, #0
    5c66:	d1f8      	bne.n	5c5a <process_recheck+0x14>
		evt = EVT_STOP;
    5c68:	2004      	movs	r0, #4
    5c6a:	4770      	bx	lr
    5c6c:	6803      	ldr	r3, [r0, #0]
		   && !sys_slist_is_empty(&mgr->clients)) {
    5c6e:	b10b      	cbz	r3, 5c74 <process_recheck+0x2e>
		evt = EVT_RESET;
    5c70:	2005      	movs	r0, #5
}
    5c72:	4770      	bx	lr
	int evt = EVT_NOP;
    5c74:	2000      	movs	r0, #0
    5c76:	4770      	bx	lr

00005c78 <process_complete>:
{
    5c78:	b538      	push	{r3, r4, r5, lr}
    5c7a:	4604      	mov	r4, r0
    5c7c:	460d      	mov	r5, r1
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    5c7e:	8b03      	ldrh	r3, [r0, #24]
	if (res < 0) {
    5c80:	2a00      	cmp	r2, #0
    5c82:	db07      	blt.n	5c94 <process_complete+0x1c>
    5c84:	f003 0307 	and.w	r3, r3, #7
		   || (state == ONOFF_STATE_RESETTING)) {
    5c88:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    5c8a:	2a01      	cmp	r2, #1
    5c8c:	d90e      	bls.n	5cac <process_complete+0x34>
	} else if (state == ONOFF_STATE_TO_OFF) {
    5c8e:	2b04      	cmp	r3, #4
    5c90:	d032      	beq.n	5cf8 <process_complete+0x80>
}
    5c92:	bd38      	pop	{r3, r4, r5, pc}
		*clients = mgr->clients;
    5c94:	e9d0 0100 	ldrd	r0, r1, [r0]
    5c98:	e885 0003 	stmia.w	r5, {r0, r1}
	list->head = NULL;
    5c9c:	2300      	movs	r3, #0
    5c9e:	6023      	str	r3, [r4, #0]
	list->tail = NULL;
    5ca0:	6063      	str	r3, [r4, #4]
		set_state(mgr, ONOFF_STATE_ERROR);
    5ca2:	2101      	movs	r1, #1
    5ca4:	4620      	mov	r0, r4
    5ca6:	f7ff ffa7 	bl	5bf8 <set_state>
    5caa:	e7f2      	b.n	5c92 <process_complete+0x1a>
		*clients = mgr->clients;
    5cac:	e9d0 0100 	ldrd	r0, r1, [r0]
    5cb0:	e885 0003 	stmia.w	r5, {r0, r1}
	list->head = NULL;
    5cb4:	2200      	movs	r2, #0
    5cb6:	6022      	str	r2, [r4, #0]
	list->tail = NULL;
    5cb8:	6062      	str	r2, [r4, #4]
		if (state == ONOFF_STATE_TO_ON) {
    5cba:	2b06      	cmp	r3, #6
    5cbc:	d117      	bne.n	5cee <process_complete+0x76>
	return list->head;
    5cbe:	682b      	ldr	r3, [r5, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    5cc0:	b13b      	cbz	r3, 5cd2 <process_complete+0x5a>
				mgr->refs += 1U;
    5cc2:	8b62      	ldrh	r2, [r4, #26]
    5cc4:	3201      	adds	r2, #1
    5cc6:	8362      	strh	r2, [r4, #26]
Z_GENLIST_PEEK_NEXT(slist, snode)
    5cc8:	2b00      	cmp	r3, #0
    5cca:	d0f9      	beq.n	5cc0 <process_complete+0x48>
	return node->next;
    5ccc:	681b      	ldr	r3, [r3, #0]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    5cce:	2b00      	cmp	r3, #0
    5cd0:	d1f6      	bne.n	5cc0 <process_complete+0x48>
			set_state(mgr, ONOFF_STATE_ON);
    5cd2:	2102      	movs	r1, #2
    5cd4:	4620      	mov	r0, r4
    5cd6:	f7ff ff8f 	bl	5bf8 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    5cda:	4620      	mov	r0, r4
    5cdc:	f7ff ffb3 	bl	5c46 <process_recheck>
    5ce0:	2800      	cmp	r0, #0
    5ce2:	d0d6      	beq.n	5c92 <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    5ce4:	8b23      	ldrh	r3, [r4, #24]
    5ce6:	f043 0320 	orr.w	r3, r3, #32
    5cea:	8323      	strh	r3, [r4, #24]
    5cec:	e7d1      	b.n	5c92 <process_complete+0x1a>
			set_state(mgr, ONOFF_STATE_OFF);
    5cee:	2100      	movs	r1, #0
    5cf0:	4620      	mov	r0, r4
    5cf2:	f7ff ff81 	bl	5bf8 <set_state>
    5cf6:	e7f0      	b.n	5cda <process_complete+0x62>
		set_state(mgr, ONOFF_STATE_OFF);
    5cf8:	2100      	movs	r1, #0
    5cfa:	f7ff ff7d 	bl	5bf8 <set_state>
		if (process_recheck(mgr) != EVT_NOP) {
    5cfe:	4620      	mov	r0, r4
    5d00:	f7ff ffa1 	bl	5c46 <process_recheck>
    5d04:	2800      	cmp	r0, #0
    5d06:	d0c4      	beq.n	5c92 <process_complete+0x1a>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    5d08:	8b23      	ldrh	r3, [r4, #24]
    5d0a:	f043 0320 	orr.w	r3, r3, #32
    5d0e:	8323      	strh	r3, [r4, #24]
}
    5d10:	e7bf      	b.n	5c92 <process_complete+0x1a>

00005d12 <validate_args>:
	if ((mgr == NULL) || (cli == NULL)) {
    5d12:	b158      	cbz	r0, 5d2c <validate_args+0x1a>
{
    5d14:	b510      	push	{r4, lr}
    5d16:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    5d18:	b159      	cbz	r1, 5d32 <validate_args+0x20>
	int rv = sys_notify_validate(&cli->notify);
    5d1a:	1d08      	adds	r0, r1, #4
    5d1c:	f7ff ff12 	bl	5b44 <sys_notify_validate>
	if ((rv == 0)
    5d20:	b918      	cbnz	r0, 5d2a <validate_args+0x18>
	    && ((cli->notify.flags
    5d22:	68a3      	ldr	r3, [r4, #8]
    5d24:	f033 0303 	bics.w	r3, r3, #3
    5d28:	d106      	bne.n	5d38 <validate_args+0x26>
}
    5d2a:	bd10      	pop	{r4, pc}
		return -EINVAL;
    5d2c:	f06f 0015 	mvn.w	r0, #21
}
    5d30:	4770      	bx	lr
		return -EINVAL;
    5d32:	f06f 0015 	mvn.w	r0, #21
    5d36:	e7f8      	b.n	5d2a <validate_args+0x18>
		rv = -EINVAL;
    5d38:	f06f 0015 	mvn.w	r0, #21
    5d3c:	e7f5      	b.n	5d2a <validate_args+0x18>

00005d3e <notify_one>:
{
    5d3e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5d42:	4607      	mov	r7, r0
    5d44:	460c      	mov	r4, r1
    5d46:	4616      	mov	r6, r2
    5d48:	461d      	mov	r5, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    5d4a:	4619      	mov	r1, r3
    5d4c:	1d20      	adds	r0, r4, #4
    5d4e:	f7ff ff10 	bl	5b72 <sys_notify_finalize>
	if (cb) {
    5d52:	b128      	cbz	r0, 5d60 <notify_one+0x22>
    5d54:	4680      	mov	r8, r0
		cb(mgr, cli, state, res);
    5d56:	462b      	mov	r3, r5
    5d58:	4632      	mov	r2, r6
    5d5a:	4621      	mov	r1, r4
    5d5c:	4638      	mov	r0, r7
    5d5e:	47c0      	blx	r8
}
    5d60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005d64 <notify_all>:
{
    5d64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    5d68:	4681      	mov	r9, r0
    5d6a:	460c      	mov	r4, r1
    5d6c:	4690      	mov	r8, r2
    5d6e:	461f      	mov	r7, r3
	while (!sys_slist_is_empty(list)) {
    5d70:	e005      	b.n	5d7e <notify_all+0x1a>
	list->tail = node;
    5d72:	6065      	str	r5, [r4, #4]
		notify_one(mgr, cli, state, res);
    5d74:	463b      	mov	r3, r7
    5d76:	4642      	mov	r2, r8
    5d78:	4648      	mov	r0, r9
    5d7a:	f7ff ffe0 	bl	5d3e <notify_one>
	return list->head;
    5d7e:	6821      	ldr	r1, [r4, #0]
	while (!sys_slist_is_empty(list)) {
    5d80:	b129      	cbz	r1, 5d8e <notify_all+0x2a>
	return node->next;
    5d82:	680d      	ldr	r5, [r1, #0]
	list->head = node;
    5d84:	6025      	str	r5, [r4, #0]
	return list->tail;
    5d86:	6866      	ldr	r6, [r4, #4]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    5d88:	428e      	cmp	r6, r1
    5d8a:	d1f3      	bne.n	5d74 <notify_all+0x10>
    5d8c:	e7f1      	b.n	5d72 <notify_all+0xe>
}
    5d8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00005d92 <transition_complete>:
{
    5d92:	b510      	push	{r4, lr}
	__asm__ volatile(
    5d94:	f04f 0420 	mov.w	r4, #32
    5d98:	f3ef 8211 	mrs	r2, BASEPRI
    5d9c:	f384 8811 	msr	BASEPRI, r4
    5da0:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
    5da4:	6141      	str	r1, [r0, #20]
	process_event(mgr, EVT_COMPLETE, key);
    5da6:	2101      	movs	r1, #1
    5da8:	f7fa fc10 	bl	5cc <process_event>
}
    5dac:	bd10      	pop	{r4, pc}

00005dae <onoff_manager_init>:
	if ((mgr == NULL)
    5dae:	4603      	mov	r3, r0
    5db0:	b168      	cbz	r0, 5dce <onoff_manager_init+0x20>
	    || (transitions == NULL)
    5db2:	b179      	cbz	r1, 5dd4 <onoff_manager_init+0x26>
	    || (transitions->start == NULL)
    5db4:	680a      	ldr	r2, [r1, #0]
    5db6:	b182      	cbz	r2, 5dda <onoff_manager_init+0x2c>
	    || (transitions->stop == NULL)) {
    5db8:	684a      	ldr	r2, [r1, #4]
    5dba:	b18a      	cbz	r2, 5de0 <onoff_manager_init+0x32>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    5dbc:	2000      	movs	r0, #0
    5dbe:	6018      	str	r0, [r3, #0]
    5dc0:	6058      	str	r0, [r3, #4]
    5dc2:	6098      	str	r0, [r3, #8]
    5dc4:	60d8      	str	r0, [r3, #12]
    5dc6:	6158      	str	r0, [r3, #20]
    5dc8:	6198      	str	r0, [r3, #24]
    5dca:	6119      	str	r1, [r3, #16]
	return 0;
    5dcc:	4770      	bx	lr
		return -EINVAL;
    5dce:	f06f 0015 	mvn.w	r0, #21
    5dd2:	4770      	bx	lr
    5dd4:	f06f 0015 	mvn.w	r0, #21
    5dd8:	4770      	bx	lr
    5dda:	f06f 0015 	mvn.w	r0, #21
    5dde:	4770      	bx	lr
    5de0:	f06f 0015 	mvn.w	r0, #21
}
    5de4:	4770      	bx	lr

00005de6 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
    5de6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5de8:	4604      	mov	r4, r0
    5dea:	460f      	mov	r7, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
    5dec:	f7ff ff91 	bl	5d12 <validate_args>

	if (rv < 0) {
    5df0:	1e06      	subs	r6, r0, #0
    5df2:	db37      	blt.n	5e64 <onoff_request+0x7e>
    5df4:	f04f 0320 	mov.w	r3, #32
    5df8:	f3ef 8211 	mrs	r2, BASEPRI
    5dfc:	f383 8811 	msr	BASEPRI, r3
    5e00:	f3bf 8f6f 	isb	sy
		return rv;
	}

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    5e04:	8b25      	ldrh	r5, [r4, #24]
    5e06:	f005 0507 	and.w	r5, r5, #7

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
    5e0a:	8b63      	ldrh	r3, [r4, #26]
    5e0c:	f64f 71ff 	movw	r1, #65535	; 0xffff
    5e10:	428b      	cmp	r3, r1
    5e12:	d02f      	beq.n	5e74 <onoff_request+0x8e>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
    5e14:	462e      	mov	r6, r5
	if (state == ONOFF_STATE_ON) {
    5e16:	2d02      	cmp	r5, #2
    5e18:	d00c      	beq.n	5e34 <onoff_request+0x4e>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
	} else if ((state == ONOFF_STATE_OFF)
    5e1a:	b18d      	cbz	r5, 5e40 <onoff_request+0x5a>
		   || (state == ONOFF_STATE_TO_OFF)
    5e1c:	2d04      	cmp	r5, #4
    5e1e:	d00f      	beq.n	5e40 <onoff_request+0x5a>
		   || (state == ONOFF_STATE_TO_ON)) {
    5e20:	2d06      	cmp	r5, #6
    5e22:	d00d      	beq.n	5e40 <onoff_request+0x5a>
		/* Start if OFF, queue client */
		start = (state == ONOFF_STATE_OFF);
		add_client = true;
	} else if (state == ONOFF_STATE_RESETTING) {
    5e24:	2d05      	cmp	r5, #5
    5e26:	d01f      	beq.n	5e68 <onoff_request+0x82>
		rv = -ENOTSUP;
	} else {
		__ASSERT_NO_MSG(state == ONOFF_STATE_ERROR);
		rv = -EIO;
    5e28:	f06f 0604 	mvn.w	r6, #4
	bool notify = false;            /* do client notification */
    5e2c:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
    5e2e:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
    5e30:	4608      	mov	r0, r1
    5e32:	e00a      	b.n	5e4a <onoff_request+0x64>
		mgr->refs += 1U;
    5e34:	3301      	adds	r3, #1
    5e36:	8363      	strh	r3, [r4, #26]
		notify = true;
    5e38:	2101      	movs	r1, #1
	bool start = false;             /* trigger a start transition */
    5e3a:	2300      	movs	r3, #0
	bool add_client = false;        /* add client to pending list */
    5e3c:	4618      	mov	r0, r3
    5e3e:	e004      	b.n	5e4a <onoff_request+0x64>
		start = (state == ONOFF_STATE_OFF);
    5e40:	fab5 f385 	clz	r3, r5
    5e44:	095b      	lsrs	r3, r3, #5
	bool notify = false;            /* do client notification */
    5e46:	2100      	movs	r1, #0
		add_client = true;
    5e48:	2001      	movs	r0, #1
	}

out:
	if (add_client) {
    5e4a:	b128      	cbz	r0, 5e58 <onoff_request+0x72>
	parent->next = child;
    5e4c:	2000      	movs	r0, #0
    5e4e:	6038      	str	r0, [r7, #0]
	return list->tail;
    5e50:	6860      	ldr	r0, [r4, #4]
Z_GENLIST_APPEND(slist, snode)
    5e52:	b1a8      	cbz	r0, 5e80 <onoff_request+0x9a>
	parent->next = child;
    5e54:	6007      	str	r7, [r0, #0]
	list->tail = node;
    5e56:	6067      	str	r7, [r4, #4]
		sys_slist_append(&mgr->clients, &cli->node);
	}

	if (start) {
    5e58:	b9ab      	cbnz	r3, 5e86 <onoff_request+0xa0>
	__asm__ volatile(
    5e5a:	f382 8811 	msr	BASEPRI, r2
    5e5e:	f3bf 8f6f 	isb	sy
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
    5e62:	b9a9      	cbnz	r1, 5e90 <onoff_request+0xaa>
			notify_one(mgr, cli, state, 0);
		}
	}

	return rv;
}
    5e64:	4630      	mov	r0, r6
    5e66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		rv = -ENOTSUP;
    5e68:	f06f 0685 	mvn.w	r6, #133	; 0x85
	bool notify = false;            /* do client notification */
    5e6c:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
    5e6e:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
    5e70:	4608      	mov	r0, r1
    5e72:	e7ea      	b.n	5e4a <onoff_request+0x64>
		rv = -EAGAIN;
    5e74:	f06f 060a 	mvn.w	r6, #10
	bool notify = false;            /* do client notification */
    5e78:	2100      	movs	r1, #0
	bool start = false;             /* trigger a start transition */
    5e7a:	460b      	mov	r3, r1
	bool add_client = false;        /* add client to pending list */
    5e7c:	4608      	mov	r0, r1
    5e7e:	e7e4      	b.n	5e4a <onoff_request+0x64>
    5e80:	6067      	str	r7, [r4, #4]
	list->head = node;
    5e82:	6027      	str	r7, [r4, #0]
}
    5e84:	e7e8      	b.n	5e58 <onoff_request+0x72>
		process_event(mgr, EVT_RECHECK, key);
    5e86:	2102      	movs	r1, #2
    5e88:	4620      	mov	r0, r4
    5e8a:	f7fa fb9f 	bl	5cc <process_event>
    5e8e:	e7e9      	b.n	5e64 <onoff_request+0x7e>
			notify_one(mgr, cli, state, 0);
    5e90:	2300      	movs	r3, #0
    5e92:	462a      	mov	r2, r5
    5e94:	4639      	mov	r1, r7
    5e96:	4620      	mov	r0, r4
    5e98:	f7ff ff51 	bl	5d3e <notify_one>
    5e9c:	e7e2      	b.n	5e64 <onoff_request+0x7e>

00005e9e <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
    5e9e:	b508      	push	{r3, lr}
    5ea0:	4604      	mov	r4, r0
    5ea2:	4608      	mov	r0, r1
    5ea4:	4611      	mov	r1, r2
	entry(p1, p2, p3);
    5ea6:	461a      	mov	r2, r3
    5ea8:	47a0      	blx	r4
	return z_impl_k_current_get();
    5eaa:	f7ff fbab 	bl	5604 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
    5eae:	f7fd f971 	bl	3194 <z_impl_k_thread_abort>

00005eb2 <extract_decimal>:
{
    5eb2:	b410      	push	{r4}
    5eb4:	4604      	mov	r4, r0
	const char *sp = *str;
    5eb6:	6802      	ldr	r2, [r0, #0]
	size_t val = 0;
    5eb8:	2000      	movs	r0, #0
	while (isdigit((int)(unsigned char)*sp)) {
    5eba:	7813      	ldrb	r3, [r2, #0]
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    5ebc:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
    5ec0:	2909      	cmp	r1, #9
    5ec2:	d806      	bhi.n	5ed2 <extract_decimal+0x20>
		val = 10U * val + *sp++ - '0';
    5ec4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
    5ec8:	3201      	adds	r2, #1
    5eca:	eb03 0040 	add.w	r0, r3, r0, lsl #1
    5ece:	3830      	subs	r0, #48	; 0x30
    5ed0:	e7f3      	b.n	5eba <extract_decimal+0x8>
	*str = sp;
    5ed2:	6022      	str	r2, [r4, #0]
}
    5ed4:	bc10      	pop	{r4}
    5ed6:	4770      	bx	lr

00005ed8 <encode_uint>:
{
    5ed8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    5edc:	b083      	sub	sp, #12
    5ede:	4604      	mov	r4, r0
    5ee0:	460d      	mov	r5, r1
    5ee2:	9201      	str	r2, [sp, #4]
    5ee4:	469a      	mov	sl, r3
    5ee6:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
	bool upcase = isupper((int)conv->specifier);
    5eea:	78d3      	ldrb	r3, [r2, #3]
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
    5eec:	f1a3 0b41 	sub.w	fp, r3, #65	; 0x41
	switch (specifier) {
    5ef0:	2b6f      	cmp	r3, #111	; 0x6f
    5ef2:	d00f      	beq.n	5f14 <encode_uint+0x3c>
    5ef4:	d906      	bls.n	5f04 <encode_uint+0x2c>
    5ef6:	2b70      	cmp	r3, #112	; 0x70
    5ef8:	d00f      	beq.n	5f1a <encode_uint+0x42>
    5efa:	2b78      	cmp	r3, #120	; 0x78
    5efc:	d110      	bne.n	5f20 <encode_uint+0x48>
		return 16;
    5efe:	f04f 0910 	mov.w	r9, #16
    5f02:	e026      	b.n	5f52 <encode_uint+0x7a>
	switch (specifier) {
    5f04:	2b58      	cmp	r3, #88	; 0x58
    5f06:	d002      	beq.n	5f0e <encode_uint+0x36>
    5f08:	f04f 090a 	mov.w	r9, #10
    5f0c:	e021      	b.n	5f52 <encode_uint+0x7a>
		return 16;
    5f0e:	f04f 0910 	mov.w	r9, #16
    5f12:	e01e      	b.n	5f52 <encode_uint+0x7a>
		return 8;
    5f14:	f04f 0908 	mov.w	r9, #8
    5f18:	e01b      	b.n	5f52 <encode_uint+0x7a>
		return 16;
    5f1a:	f04f 0910 	mov.w	r9, #16
    5f1e:	e018      	b.n	5f52 <encode_uint+0x7a>
	switch (specifier) {
    5f20:	f04f 090a 	mov.w	r9, #10
	char *bp = bps + (bpe - bps);
    5f24:	e015      	b.n	5f52 <encode_uint+0x7a>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5f26:	f1bb 0f19 	cmp.w	fp, #25
    5f2a:	d820      	bhi.n	5f6e <encode_uint+0x96>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    5f2c:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5f2e:	3237      	adds	r2, #55	; 0x37
    5f30:	b2d2      	uxtb	r2, r2
    5f32:	f808 2d01 	strb.w	r2, [r8, #-1]!
		value /= radix;
    5f36:	4632      	mov	r2, r6
    5f38:	463b      	mov	r3, r7
    5f3a:	4620      	mov	r0, r4
    5f3c:	4629      	mov	r1, r5
    5f3e:	f7fa f8cd 	bl	dc <__aeabi_uldivmod>
	} while ((value != 0) && (bps < bp));
    5f42:	42bd      	cmp	r5, r7
    5f44:	bf08      	it	eq
    5f46:	42b4      	cmpeq	r4, r6
    5f48:	d315      	bcc.n	5f76 <encode_uint+0x9e>
    5f4a:	45d0      	cmp	r8, sl
    5f4c:	d913      	bls.n	5f76 <encode_uint+0x9e>
		value /= radix;
    5f4e:	4604      	mov	r4, r0
    5f50:	460d      	mov	r5, r1
		unsigned int lsv = (unsigned int)(value % radix);
    5f52:	464e      	mov	r6, r9
    5f54:	2700      	movs	r7, #0
    5f56:	464a      	mov	r2, r9
    5f58:	463b      	mov	r3, r7
    5f5a:	4620      	mov	r0, r4
    5f5c:	4629      	mov	r1, r5
    5f5e:	f7fa f8bd 	bl	dc <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5f62:	2a09      	cmp	r2, #9
    5f64:	d8df      	bhi.n	5f26 <encode_uint+0x4e>
    5f66:	b2d2      	uxtb	r2, r2
    5f68:	3230      	adds	r2, #48	; 0x30
    5f6a:	b2d2      	uxtb	r2, r2
    5f6c:	e7e1      	b.n	5f32 <encode_uint+0x5a>
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
    5f6e:	b2d2      	uxtb	r2, r2
		*--bp = (lsv <= 9) ? ('0' + lsv)
    5f70:	3257      	adds	r2, #87	; 0x57
    5f72:	b2d2      	uxtb	r2, r2
    5f74:	e7dd      	b.n	5f32 <encode_uint+0x5a>
	if (conv->flag_hash) {
    5f76:	9b01      	ldr	r3, [sp, #4]
    5f78:	781b      	ldrb	r3, [r3, #0]
    5f7a:	f013 0f20 	tst.w	r3, #32
    5f7e:	d005      	beq.n	5f8c <encode_uint+0xb4>
		if (radix == 8) {
    5f80:	f1b9 0f08 	cmp.w	r9, #8
    5f84:	d006      	beq.n	5f94 <encode_uint+0xbc>
		} else if (radix == 16) {
    5f86:	f1b9 0f10 	cmp.w	r9, #16
    5f8a:	d009      	beq.n	5fa0 <encode_uint+0xc8>
}
    5f8c:	4640      	mov	r0, r8
    5f8e:	b003      	add	sp, #12
    5f90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			conv->altform_0 = true;
    5f94:	9a01      	ldr	r2, [sp, #4]
    5f96:	7893      	ldrb	r3, [r2, #2]
    5f98:	f043 0308 	orr.w	r3, r3, #8
    5f9c:	7093      	strb	r3, [r2, #2]
    5f9e:	e7f5      	b.n	5f8c <encode_uint+0xb4>
			conv->altform_0c = true;
    5fa0:	9a01      	ldr	r2, [sp, #4]
    5fa2:	7893      	ldrb	r3, [r2, #2]
    5fa4:	f043 0310 	orr.w	r3, r3, #16
    5fa8:	7093      	strb	r3, [r2, #2]
    5faa:	e7ef      	b.n	5f8c <encode_uint+0xb4>

00005fac <outs>:
{
    5fac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5fb0:	4607      	mov	r7, r0
    5fb2:	460e      	mov	r6, r1
    5fb4:	4614      	mov	r4, r2
    5fb6:	4698      	mov	r8, r3
	size_t count = 0;
    5fb8:	2500      	movs	r5, #0
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    5fba:	e006      	b.n	5fca <outs+0x1e>
		int rc = out((int)*sp++, ctx);
    5fbc:	4631      	mov	r1, r6
    5fbe:	f814 0b01 	ldrb.w	r0, [r4], #1
    5fc2:	47b8      	blx	r7
		if (rc < 0) {
    5fc4:	2800      	cmp	r0, #0
    5fc6:	db09      	blt.n	5fdc <outs+0x30>
		++count;
    5fc8:	3501      	adds	r5, #1
	while ((sp < ep) || ((ep == NULL) && *sp)) {
    5fca:	4544      	cmp	r4, r8
    5fcc:	d3f6      	bcc.n	5fbc <outs+0x10>
    5fce:	f1b8 0f00 	cmp.w	r8, #0
    5fd2:	d102      	bne.n	5fda <outs+0x2e>
    5fd4:	7823      	ldrb	r3, [r4, #0]
    5fd6:	2b00      	cmp	r3, #0
    5fd8:	d1f0      	bne.n	5fbc <outs+0x10>
	return (int)count;
    5fda:	4628      	mov	r0, r5
}
    5fdc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005fe0 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
    5fe0:	4770      	bx	lr

00005fe2 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
    5fe2:	2300      	movs	r3, #0
    5fe4:	6043      	str	r3, [r0, #4]
	list->head = NULL;
    5fe6:	6003      	str	r3, [r0, #0]
}
    5fe8:	4770      	bx	lr

00005fea <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
    5fea:	6803      	ldr	r3, [r0, #0]
    5fec:	b12b      	cbz	r3, 5ffa <log_list_add_tail+0x10>
		list->head = msg;
	} else {
		list->tail->next = msg;
    5fee:	6843      	ldr	r3, [r0, #4]
    5ff0:	6019      	str	r1, [r3, #0]
	}

	list->tail = msg;
    5ff2:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
    5ff4:	2300      	movs	r3, #0
    5ff6:	600b      	str	r3, [r1, #0]
}
    5ff8:	4770      	bx	lr
		list->head = msg;
    5ffa:	6001      	str	r1, [r0, #0]
    5ffc:	e7f9      	b.n	5ff2 <log_list_add_tail+0x8>

00005ffe <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
    5ffe:	6800      	ldr	r0, [r0, #0]
    6000:	4770      	bx	lr

00006002 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
    6002:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
    6004:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
    6006:	b108      	cbz	r0, 600c <log_list_head_get+0xa>
		list->head = list->head->next;
    6008:	6802      	ldr	r2, [r0, #0]
    600a:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
    600c:	4770      	bx	lr

0000600e <dummy_timestamp>:
}
    600e:	2000      	movs	r0, #0
    6010:	4770      	bx	lr

00006012 <msg_filter_check>:
}
    6012:	2001      	movs	r0, #1
    6014:	4770      	bx	lr

00006016 <default_get_timestamp>:
{
    6016:	b508      	push	{r3, lr}
#ifndef _ASMLANGUAGE
extern uint32_t sys_clock_cycle_get_32(void);

static inline uint32_t arch_k_cycle_get_32(void)
{
	return sys_clock_cycle_get_32();
    6018:	f7fc faec 	bl	25f4 <sys_clock_cycle_get_32>
}
    601c:	bd08      	pop	{r3, pc}

0000601e <z_log_get_s_mask>:
{
    601e:	b470      	push	{r4, r5, r6}
    6020:	4603      	mov	r3, r0
	uint32_t mask = 0U;
    6022:	2000      	movs	r0, #0
	uint32_t arg = 0U;
    6024:	4605      	mov	r5, r0
	bool arm = false;
    6026:	4604      	mov	r4, r0
	while ((curr = *str++) && arg < nargs) {
    6028:	e001      	b.n	602e <z_log_get_s_mask+0x10>
			arm = !arm;
    602a:	f084 0401 	eor.w	r4, r4, #1
	while ((curr = *str++) && arg < nargs) {
    602e:	f813 2b01 	ldrb.w	r2, [r3], #1
    6032:	b19a      	cbz	r2, 605c <z_log_get_s_mask+0x3e>
    6034:	428d      	cmp	r5, r1
    6036:	d211      	bcs.n	605c <z_log_get_s_mask+0x3e>
		if (curr == '%') {
    6038:	2a25      	cmp	r2, #37	; 0x25
    603a:	d0f6      	beq.n	602a <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
    603c:	2c00      	cmp	r4, #0
    603e:	d0f6      	beq.n	602e <z_log_get_s_mask+0x10>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
    6040:	f042 0620 	orr.w	r6, r2, #32
    6044:	3e61      	subs	r6, #97	; 0x61
    6046:	2e19      	cmp	r6, #25
    6048:	d8f1      	bhi.n	602e <z_log_get_s_mask+0x10>
			if (curr == 's') {
    604a:	2a73      	cmp	r2, #115	; 0x73
    604c:	d002      	beq.n	6054 <z_log_get_s_mask+0x36>
			arg++;
    604e:	3501      	adds	r5, #1
			arm = false;
    6050:	2400      	movs	r4, #0
    6052:	e7ec      	b.n	602e <z_log_get_s_mask+0x10>
				mask |= BIT(arg);
    6054:	2201      	movs	r2, #1
    6056:	40aa      	lsls	r2, r5
    6058:	4310      	orrs	r0, r2
    605a:	e7f8      	b.n	604e <z_log_get_s_mask+0x30>
}
    605c:	bc70      	pop	{r4, r5, r6}
    605e:	4770      	bx	lr

00006060 <block_on_alloc>:
}
    6060:	2000      	movs	r0, #0
    6062:	4770      	bx	lr

00006064 <cont_arg_get>:

static log_arg_t cont_arg_get(struct log_msg *msg, uint32_t arg_idx)
{
	struct log_msg_cont *cont;

	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
    6064:	2901      	cmp	r1, #1
    6066:	d906      	bls.n	6076 <cont_arg_get+0x12>
		return msg->payload.ext.data.args[arg_idx];
	}


	cont = msg->payload.ext.next;
    6068:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
    606a:	3902      	subs	r1, #2

	while (arg_idx >= ARGS_CONT_MSG) {
    606c:	2906      	cmp	r1, #6
    606e:	d907      	bls.n	6080 <cont_arg_get+0x1c>
		arg_idx -= ARGS_CONT_MSG;
    6070:	3907      	subs	r1, #7
		cont = cont->next;
    6072:	681b      	ldr	r3, [r3, #0]
    6074:	e7fa      	b.n	606c <cont_arg_get+0x8>
		return msg->payload.ext.data.args[arg_idx];
    6076:	3104      	adds	r1, #4
    6078:	eb00 0181 	add.w	r1, r0, r1, lsl #2
    607c:	6888      	ldr	r0, [r1, #8]
    607e:	4770      	bx	lr
	}

	return cont->payload.args[arg_idx];
    6080:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    6084:	6848      	ldr	r0, [r1, #4]
}
    6086:	4770      	bx	lr

00006088 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    uint8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
    6088:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    608c:	461c      	mov	r4, r3
    608e:	f89d 9020 	ldrb.w	r9, [sp, #32]
	uint32_t available_len = msg->hdr.params.hexdump.length;
    6092:	8903      	ldrh	r3, [r0, #8]
    6094:	f3c3 038d 	ubfx	r3, r3, #2, #14
	uint8_t *head_data;
	uint32_t chunk_len;
	uint32_t req_len;
	uint32_t cpy_len;

	if (offset >= available_len) {
    6098:	42a3      	cmp	r3, r4
    609a:	d91f      	bls.n	60dc <log_msg_hexdump_data_op+0x54>
    609c:	4688      	mov	r8, r1
		*length = 0;
		return;
	}

	if ((offset + *length) > available_len) {
    609e:	6811      	ldr	r1, [r2, #0]
    60a0:	4421      	add	r1, r4
    60a2:	4299      	cmp	r1, r3
    60a4:	d901      	bls.n	60aa <log_msg_hexdump_data_op+0x22>
		*length = available_len - offset;
    60a6:	1b19      	subs	r1, r3, r4
    60a8:	6011      	str	r1, [r2, #0]
	}

	req_len = *length;
    60aa:	6817      	ldr	r7, [r2, #0]

	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    60ac:	2b0c      	cmp	r3, #12
    60ae:	d919      	bls.n	60e4 <log_msg_hexdump_data_op+0x5c>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
		head_data = msg->payload.ext.data.bytes;
    60b0:	f100 0c18 	add.w	ip, r0, #24
		cont = msg->payload.ext.next;
    60b4:	6946      	ldr	r6, [r0, #20]
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    60b6:	2308      	movs	r3, #8
		head_data = msg->payload.single.bytes;
		chunk_len = available_len;

	}

	if (offset < chunk_len) {
    60b8:	42a3      	cmp	r3, r4
    60ba:	d91e      	bls.n	60fa <log_msg_hexdump_data_op+0x72>
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    60bc:	42bb      	cmp	r3, r7
    60be:	bf28      	it	cs
    60c0:	463b      	movcs	r3, r7
    60c2:	461d      	mov	r5, r3

		if (put_op) {
    60c4:	f1b9 0f00 	cmp.w	r9, #0
    60c8:	d010      	beq.n	60ec <log_msg_hexdump_data_op+0x64>
			(void)memcpy(&head_data[offset], data, cpy_len);
    60ca:	461a      	mov	r2, r3
    60cc:	4641      	mov	r1, r8
    60ce:	eb0c 0004 	add.w	r0, ip, r4
    60d2:	f000 fcbe 	bl	6a52 <memcpy>
		} else {
			(void)memcpy(data, &head_data[offset], cpy_len);
		}

		req_len -= cpy_len;
    60d6:	1b7f      	subs	r7, r7, r5
		data += cpy_len;
    60d8:	44a8      	add	r8, r5
    60da:	e021      	b.n	6120 <log_msg_hexdump_data_op+0x98>
		*length = 0;
    60dc:	2300      	movs	r3, #0
    60de:	6013      	str	r3, [r2, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
    60e0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		head_data = msg->payload.single.bytes;
    60e4:	f100 0c14 	add.w	ip, r0, #20
	struct log_msg_cont *cont = NULL;
    60e8:	2600      	movs	r6, #0
    60ea:	e7e5      	b.n	60b8 <log_msg_hexdump_data_op+0x30>
			(void)memcpy(data, &head_data[offset], cpy_len);
    60ec:	461a      	mov	r2, r3
    60ee:	eb0c 0104 	add.w	r1, ip, r4
    60f2:	4640      	mov	r0, r8
    60f4:	f000 fcad 	bl	6a52 <memcpy>
    60f8:	e7ed      	b.n	60d6 <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
    60fa:	1ae4      	subs	r4, r4, r3
		if (cont == NULL) {
    60fc:	b91e      	cbnz	r6, 6106 <log_msg_hexdump_data_op+0x7e>
			cont = msg->payload.ext.next;
    60fe:	6946      	ldr	r6, [r0, #20]
    6100:	e001      	b.n	6106 <log_msg_hexdump_data_op+0x7e>
			cont = cont->next;
    6102:	6836      	ldr	r6, [r6, #0]
			offset -= chunk_len;
    6104:	3c1c      	subs	r4, #28
		while (offset >= chunk_len) {
    6106:	2c1b      	cmp	r4, #27
    6108:	d8fb      	bhi.n	6102 <log_msg_hexdump_data_op+0x7a>
    610a:	e009      	b.n	6120 <log_msg_hexdump_data_op+0x98>
			(void)memcpy(data, &cont->payload.bytes[offset],
    610c:	1931      	adds	r1, r6, r4
    610e:	462a      	mov	r2, r5
    6110:	3104      	adds	r1, #4
    6112:	4640      	mov	r0, r8
    6114:	f000 fc9d 	bl	6a52 <memcpy>
		cont = cont->next;
    6118:	6836      	ldr	r6, [r6, #0]
		req_len -= cpy_len;
    611a:	1b7f      	subs	r7, r7, r5
		data += cpy_len;
    611c:	44a8      	add	r8, r5
		offset = 0;
    611e:	2400      	movs	r4, #0
	while ((req_len > 0) && (cont != NULL)) {
    6120:	2f00      	cmp	r7, #0
    6122:	d0dd      	beq.n	60e0 <log_msg_hexdump_data_op+0x58>
    6124:	2e00      	cmp	r6, #0
    6126:	d0db      	beq.n	60e0 <log_msg_hexdump_data_op+0x58>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
    6128:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
    612c:	42bd      	cmp	r5, r7
    612e:	bf28      	it	cs
    6130:	463d      	movcs	r5, r7
		if (put_op) {
    6132:	f1b9 0f00 	cmp.w	r9, #0
    6136:	d0e9      	beq.n	610c <log_msg_hexdump_data_op+0x84>
			(void)memcpy(&cont->payload.bytes[offset],
    6138:	1930      	adds	r0, r6, r4
    613a:	462a      	mov	r2, r5
    613c:	4641      	mov	r1, r8
    613e:	3004      	adds	r0, #4
    6140:	f000 fc87 	bl	6a52 <memcpy>
    6144:	e7e8      	b.n	6118 <log_msg_hexdump_data_op+0x90>

00006146 <log_msg_get>:
	atomic_inc(&msg->hdr.ref_cnt);
    6146:	3004      	adds	r0, #4
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    6148:	f3bf 8f5b 	dmb	ish
    614c:	e850 3f00 	ldrex	r3, [r0]
    6150:	3301      	adds	r3, #1
    6152:	e840 3200 	strex	r2, r3, [r0]
    6156:	2a00      	cmp	r2, #0
    6158:	d1f8      	bne.n	614c <log_msg_get+0x6>
    615a:	f3bf 8f5b 	dmb	ish
}
    615e:	4770      	bx	lr

00006160 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
    6160:	7a40      	ldrb	r0, [r0, #9]
}
    6162:	0900      	lsrs	r0, r0, #4
    6164:	4770      	bx	lr

00006166 <log_msg_arg_get>:
{
    6166:	b508      	push	{r3, lr}
	if (arg_idx >= msg->hdr.params.std.nargs) {
    6168:	7a43      	ldrb	r3, [r0, #9]
    616a:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
    616e:	d20a      	bcs.n	6186 <log_msg_arg_get+0x20>
    6170:	091a      	lsrs	r2, r3, #4
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
    6172:	2a03      	cmp	r2, #3
    6174:	d804      	bhi.n	6180 <log_msg_arg_get+0x1a>
		arg = msg->payload.single.args[arg_idx];
    6176:	3104      	adds	r1, #4
    6178:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    617c:	6840      	ldr	r0, [r0, #4]
    617e:	e003      	b.n	6188 <log_msg_arg_get+0x22>
		arg = cont_arg_get(msg, arg_idx);
    6180:	f7ff ff70 	bl	6064 <cont_arg_get>
    6184:	e000      	b.n	6188 <log_msg_arg_get+0x22>
		return 0;
    6186:	2000      	movs	r0, #0
}
    6188:	bd08      	pop	{r3, pc}

0000618a <log_msg_str_get>:
}
    618a:	6900      	ldr	r0, [r0, #16]
    618c:	4770      	bx	lr

0000618e <log_msg_put>:
{
    618e:	b508      	push	{r3, lr}
	atomic_dec(&msg->hdr.ref_cnt);
    6190:	1d03      	adds	r3, r0, #4
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
    6192:	f3bf 8f5b 	dmb	ish
    6196:	e853 2f00 	ldrex	r2, [r3]
    619a:	3a01      	subs	r2, #1
    619c:	e843 2100 	strex	r1, r2, [r3]
    61a0:	2900      	cmp	r1, #0
    61a2:	d1f8      	bne.n	6196 <log_msg_put+0x8>
    61a4:	f3bf 8f5b 	dmb	ish
	if (msg->hdr.ref_cnt == 0) {
    61a8:	6843      	ldr	r3, [r0, #4]
    61aa:	b103      	cbz	r3, 61ae <log_msg_put+0x20>
}
    61ac:	bd08      	pop	{r3, pc}
		msg_free(msg);
    61ae:	f7fb fbed 	bl	198c <msg_free>
}
    61b2:	e7fb      	b.n	61ac <log_msg_put+0x1e>

000061b4 <log_msg_hexdump_create>:
{
    61b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    61b8:	4606      	mov	r6, r0
    61ba:	460f      	mov	r7, r1
    61bc:	4614      	mov	r4, r2
	length = (length > LOG_MSG_HEXDUMP_MAX_LENGTH) ?
    61be:	f643 75ff 	movw	r5, #16383	; 0x3fff
    61c2:	4295      	cmp	r5, r2
    61c4:	bf28      	it	cs
    61c6:	4615      	movcs	r5, r2
	msg = (struct log_msg *)log_msg_chunk_alloc();
    61c8:	f7fb fbc4 	bl	1954 <log_msg_chunk_alloc>
	if (msg == NULL) {
    61cc:	4681      	mov	r9, r0
    61ce:	2800      	cmp	r0, #0
    61d0:	d045      	beq.n	625e <log_msg_hexdump_create+0xaa>
	msg->hdr.ref_cnt = 1;
    61d2:	2301      	movs	r3, #1
    61d4:	6043      	str	r3, [r0, #4]
	msg->hdr.params.hexdump.type = LOG_MSG_TYPE_HEXDUMP;
    61d6:	7a03      	ldrb	r3, [r0, #8]
    61d8:	f043 0301 	orr.w	r3, r3, #1
    61dc:	7203      	strb	r3, [r0, #8]
	msg->hdr.params.hexdump.length = length;
    61de:	8903      	ldrh	r3, [r0, #8]
    61e0:	f365 038f 	bfi	r3, r5, #2, #14
    61e4:	8103      	strh	r3, [r0, #8]
	msg->str = str;
    61e6:	6106      	str	r6, [r0, #16]
	if (length > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
    61e8:	2c0c      	cmp	r4, #12
    61ea:	d927      	bls.n	623c <log_msg_hexdump_create+0x88>
		(void)memcpy(msg->payload.ext.data.bytes,
    61ec:	2208      	movs	r2, #8
    61ee:	4639      	mov	r1, r7
    61f0:	3018      	adds	r0, #24
    61f2:	f000 fc2e 	bl	6a52 <memcpy>
		msg->payload.ext.next = NULL;
    61f6:	2300      	movs	r3, #0
    61f8:	f8c9 3014 	str.w	r3, [r9, #20]
		msg->hdr.params.generic.ext = 1;
    61fc:	f899 3008 	ldrb.w	r3, [r9, #8]
    6200:	f043 0302 	orr.w	r3, r3, #2
    6204:	f889 3008 	strb.w	r3, [r9, #8]
		data += LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    6208:	3708      	adds	r7, #8
		length -= LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
    620a:	3d08      	subs	r5, #8
	prev_cont = &msg->payload.ext.next;
    620c:	f109 0814 	add.w	r8, r9, #20
	while (length > 0) {
    6210:	b32d      	cbz	r5, 625e <log_msg_hexdump_create+0xaa>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
    6212:	f7fb fb9f 	bl	1954 <log_msg_chunk_alloc>
		if (cont == NULL) {
    6216:	4604      	mov	r4, r0
    6218:	b1e8      	cbz	r0, 6256 <log_msg_hexdump_create+0xa2>
		*prev_cont = cont;
    621a:	f8c8 0000 	str.w	r0, [r8]
		cont->next = NULL;
    621e:	2300      	movs	r3, #0
    6220:	6003      	str	r3, [r0, #0]
		prev_cont = &cont->next;
    6222:	4680      	mov	r8, r0
		chunk_length = (length > HEXDUMP_BYTES_CONT_MSG) ?
    6224:	462e      	mov	r6, r5
    6226:	2d1c      	cmp	r5, #28
    6228:	bf28      	it	cs
    622a:	261c      	movcs	r6, #28
		(void)memcpy(cont->payload.bytes, data, chunk_length);
    622c:	4632      	mov	r2, r6
    622e:	4639      	mov	r1, r7
    6230:	3004      	adds	r0, #4
    6232:	f000 fc0e 	bl	6a52 <memcpy>
		data += chunk_length;
    6236:	4437      	add	r7, r6
		length -= chunk_length;
    6238:	1bad      	subs	r5, r5, r6
    623a:	e7e9      	b.n	6210 <log_msg_hexdump_create+0x5c>
		(void)memcpy(msg->payload.single.bytes, data, length);
    623c:	462a      	mov	r2, r5
    623e:	4639      	mov	r1, r7
    6240:	3014      	adds	r0, #20
    6242:	f000 fc06 	bl	6a52 <memcpy>
		msg->hdr.params.generic.ext = 0;
    6246:	f899 3008 	ldrb.w	r3, [r9, #8]
    624a:	f36f 0341 	bfc	r3, #1, #1
    624e:	f889 3008 	strb.w	r3, [r9, #8]
		length = 0U;
    6252:	2500      	movs	r5, #0
    6254:	e7da      	b.n	620c <log_msg_hexdump_create+0x58>
			msg_free(msg);
    6256:	4648      	mov	r0, r9
    6258:	f7fb fb98 	bl	198c <msg_free>
			return NULL;
    625c:	46a1      	mov	r9, r4
}
    625e:	4648      	mov	r0, r9
    6260:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00006264 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      uint8_t *data,
			      size_t *length,
			      size_t offset)
{
    6264:	b510      	push	{r4, lr}
    6266:	b082      	sub	sp, #8
	log_msg_hexdump_data_op(msg, data, length, offset, false);
    6268:	2400      	movs	r4, #0
    626a:	9400      	str	r4, [sp, #0]
    626c:	f7ff ff0c 	bl	6088 <log_msg_hexdump_data_op>
}
    6270:	b002      	add	sp, #8
    6272:	bd10      	pop	{r4, pc}

00006274 <buffer_write>:
{
    6274:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6276:	4607      	mov	r7, r0
    6278:	460d      	mov	r5, r1
    627a:	4614      	mov	r4, r2
    627c:	461e      	mov	r6, r3
		processed = outf(buf, len, ctx);
    627e:	4632      	mov	r2, r6
    6280:	4621      	mov	r1, r4
    6282:	4628      	mov	r0, r5
    6284:	47b8      	blx	r7
		buf += processed;
    6286:	4405      	add	r5, r0
	} while (len != 0);
    6288:	1a24      	subs	r4, r4, r0
    628a:	d1f8      	bne.n	627e <buffer_write+0xa>
}
    628c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000628e <color_prefix>:
{
    628e:	b508      	push	{r3, lr}
    6290:	4613      	mov	r3, r2
	color_print(output, color, true, level);
    6292:	2201      	movs	r2, #1
    6294:	f7fb fc12 	bl	1abc <color_print>
}
    6298:	bd08      	pop	{r3, pc}

0000629a <color_postfix>:
{
    629a:	b508      	push	{r3, lr}
    629c:	4613      	mov	r3, r2
	color_print(output, color, false, level);
    629e:	2200      	movs	r2, #0
    62a0:	f7fb fc0c 	bl	1abc <color_print>
}
    62a4:	bd08      	pop	{r3, pc}

000062a6 <postfix_print>:
{
    62a6:	b538      	push	{r3, r4, r5, lr}
    62a8:	4605      	mov	r5, r0
    62aa:	460c      	mov	r4, r1
	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
    62ac:	f001 0101 	and.w	r1, r1, #1
    62b0:	f7ff fff3 	bl	629a <color_postfix>
	newline_print(output, flags);
    62b4:	4621      	mov	r1, r4
    62b6:	4628      	mov	r0, r5
    62b8:	f7fb fc16 	bl	1ae8 <newline_print>
}
    62bc:	bd38      	pop	{r3, r4, r5, pc}

000062be <prefix_print>:
{
    62be:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    62c2:	b083      	sub	sp, #12
    62c4:	4604      	mov	r4, r0
    62c6:	4615      	mov	r5, r2
    62c8:	f89d 6028 	ldrb.w	r6, [sp, #40]	; 0x28
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
    62cc:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
    62d0:	f3c1 08c0 	ubfx	r8, r1, #3, #1
	if (stamp) {
    62d4:	f011 0702 	ands.w	r7, r1, #2
    62d8:	d113      	bne.n	6302 <prefix_print+0x44>
		color_prefix(output, colors_on, level);
    62da:	4632      	mov	r2, r6
    62dc:	4649      	mov	r1, r9
    62de:	4620      	mov	r0, r4
    62e0:	f7ff ffd5 	bl	628e <color_prefix>
	length += ids_print(output, level_on, func_on,
    62e4:	9601      	str	r6, [sp, #4]
    62e6:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
    62ea:	9300      	str	r3, [sp, #0]
    62ec:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
    62f0:	462a      	mov	r2, r5
    62f2:	4641      	mov	r1, r8
    62f4:	4620      	mov	r0, r4
    62f6:	f7fb fc69 	bl	1bcc <ids_print>
}
    62fa:	4438      	add	r0, r7
    62fc:	b003      	add	sp, #12
    62fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		length += timestamp_print(output, flags, timestamp);
    6302:	461a      	mov	r2, r3
    6304:	f7fb fb94 	bl	1a30 <timestamp_print>
    6308:	4607      	mov	r7, r0
    630a:	e7e6      	b.n	62da <prefix_print+0x1c>

0000630c <std_print>:
{
    630c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6310:	b08e      	sub	sp, #56	; 0x38
    6312:	af0e      	add	r7, sp, #56	; 0x38
    6314:	4606      	mov	r6, r0
    6316:	4689      	mov	r9, r1
	const char *str = log_msg_str_get(msg);
    6318:	f7ff ff37 	bl	618a <log_msg_str_get>
    631c:	4682      	mov	sl, r0
	uint32_t nargs = log_msg_nargs_get(msg);
    631e:	4630      	mov	r0, r6
    6320:	f7ff ff1e 	bl	6160 <log_msg_nargs_get>
    6324:	4680      	mov	r8, r0
	log_arg_t *args = alloca(sizeof(log_arg_t)*nargs);
    6326:	0083      	lsls	r3, r0, #2
    6328:	3307      	adds	r3, #7
    632a:	f023 0307 	bic.w	r3, r3, #7
    632e:	ebad 0d03 	sub.w	sp, sp, r3
    6332:	ad0e      	add	r5, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
    6334:	2400      	movs	r4, #0
    6336:	4544      	cmp	r4, r8
    6338:	d207      	bcs.n	634a <std_print+0x3e>
		args[i] = log_msg_arg_get(msg, i);
    633a:	4621      	mov	r1, r4
    633c:	4630      	mov	r0, r6
    633e:	f7ff ff12 	bl	6166 <log_msg_arg_get>
    6342:	f845 0024 	str.w	r0, [r5, r4, lsl #2]
	for (i = 0; i < nargs; i++) {
    6346:	3401      	adds	r4, #1
    6348:	e7f5      	b.n	6336 <std_print+0x2a>
	switch (log_msg_nargs_get(msg)) {
    634a:	4630      	mov	r0, r6
    634c:	f7ff ff08 	bl	6160 <log_msg_nargs_get>
    6350:	280f      	cmp	r0, #15
    6352:	d815      	bhi.n	6380 <std_print+0x74>
    6354:	e8df f010 	tbh	[pc, r0, lsl #1]
    6358:	00170010 	.word	0x00170010
    635c:	0024001d 	.word	0x0024001d
    6360:	0038002d 	.word	0x0038002d
    6364:	00540045 	.word	0x00540045
    6368:	00780065 	.word	0x00780065
    636c:	00a4008d 	.word	0x00a4008d
    6370:	00d800bd 	.word	0x00d800bd
    6374:	011400f5 	.word	0x011400f5
		print_formatted(output, str);
    6378:	4651      	mov	r1, sl
    637a:	4648      	mov	r0, r9
    637c:	f7fb fb46 	bl	1a0c <print_formatted>
}
    6380:	46bd      	mov	sp, r7
    6382:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(output, str, args[0]);
    6386:	682a      	ldr	r2, [r5, #0]
    6388:	4651      	mov	r1, sl
    638a:	4648      	mov	r0, r9
    638c:	f7fb fb3e 	bl	1a0c <print_formatted>
		break;
    6390:	e7f6      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1]);
    6392:	686b      	ldr	r3, [r5, #4]
    6394:	682a      	ldr	r2, [r5, #0]
    6396:	4651      	mov	r1, sl
    6398:	4648      	mov	r0, r9
    639a:	f7fb fb37 	bl	1a0c <print_formatted>
		break;
    639e:	e7ef      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2]);
    63a0:	686b      	ldr	r3, [r5, #4]
    63a2:	682a      	ldr	r2, [r5, #0]
    63a4:	68a9      	ldr	r1, [r5, #8]
    63a6:	9100      	str	r1, [sp, #0]
    63a8:	4651      	mov	r1, sl
    63aa:	4648      	mov	r0, r9
    63ac:	f7fb fb2e 	bl	1a0c <print_formatted>
		break;
    63b0:	e7e6      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    63b2:	686b      	ldr	r3, [r5, #4]
    63b4:	682a      	ldr	r2, [r5, #0]
    63b6:	68e9      	ldr	r1, [r5, #12]
    63b8:	9101      	str	r1, [sp, #4]
    63ba:	68a9      	ldr	r1, [r5, #8]
    63bc:	9100      	str	r1, [sp, #0]
    63be:	4651      	mov	r1, sl
    63c0:	4648      	mov	r0, r9
    63c2:	f7fb fb23 	bl	1a0c <print_formatted>
		break;
    63c6:	e7db      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    63c8:	686b      	ldr	r3, [r5, #4]
    63ca:	682a      	ldr	r2, [r5, #0]
    63cc:	6929      	ldr	r1, [r5, #16]
    63ce:	9102      	str	r1, [sp, #8]
    63d0:	68e9      	ldr	r1, [r5, #12]
    63d2:	9101      	str	r1, [sp, #4]
    63d4:	68a9      	ldr	r1, [r5, #8]
    63d6:	9100      	str	r1, [sp, #0]
    63d8:	4651      	mov	r1, sl
    63da:	4648      	mov	r0, r9
    63dc:	f7fb fb16 	bl	1a0c <print_formatted>
		break;
    63e0:	e7ce      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    63e2:	686b      	ldr	r3, [r5, #4]
    63e4:	682a      	ldr	r2, [r5, #0]
    63e6:	6969      	ldr	r1, [r5, #20]
    63e8:	9103      	str	r1, [sp, #12]
    63ea:	6929      	ldr	r1, [r5, #16]
    63ec:	9102      	str	r1, [sp, #8]
    63ee:	68e9      	ldr	r1, [r5, #12]
    63f0:	9101      	str	r1, [sp, #4]
    63f2:	68a9      	ldr	r1, [r5, #8]
    63f4:	9100      	str	r1, [sp, #0]
    63f6:	4651      	mov	r1, sl
    63f8:	4648      	mov	r0, r9
    63fa:	f7fb fb07 	bl	1a0c <print_formatted>
		break;
    63fe:	e7bf      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    6400:	686b      	ldr	r3, [r5, #4]
    6402:	682a      	ldr	r2, [r5, #0]
    6404:	69a9      	ldr	r1, [r5, #24]
    6406:	9104      	str	r1, [sp, #16]
    6408:	6969      	ldr	r1, [r5, #20]
    640a:	9103      	str	r1, [sp, #12]
    640c:	6929      	ldr	r1, [r5, #16]
    640e:	9102      	str	r1, [sp, #8]
    6410:	68e9      	ldr	r1, [r5, #12]
    6412:	9101      	str	r1, [sp, #4]
    6414:	68a9      	ldr	r1, [r5, #8]
    6416:	9100      	str	r1, [sp, #0]
    6418:	4651      	mov	r1, sl
    641a:	4648      	mov	r0, r9
    641c:	f7fb faf6 	bl	1a0c <print_formatted>
		break;
    6420:	e7ae      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    6422:	686b      	ldr	r3, [r5, #4]
    6424:	682a      	ldr	r2, [r5, #0]
    6426:	69e9      	ldr	r1, [r5, #28]
    6428:	9105      	str	r1, [sp, #20]
    642a:	69a9      	ldr	r1, [r5, #24]
    642c:	9104      	str	r1, [sp, #16]
    642e:	6969      	ldr	r1, [r5, #20]
    6430:	9103      	str	r1, [sp, #12]
    6432:	6929      	ldr	r1, [r5, #16]
    6434:	9102      	str	r1, [sp, #8]
    6436:	68e9      	ldr	r1, [r5, #12]
    6438:	9101      	str	r1, [sp, #4]
    643a:	68a9      	ldr	r1, [r5, #8]
    643c:	9100      	str	r1, [sp, #0]
    643e:	4651      	mov	r1, sl
    6440:	4648      	mov	r0, r9
    6442:	f7fb fae3 	bl	1a0c <print_formatted>
		break;
    6446:	e79b      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    6448:	686b      	ldr	r3, [r5, #4]
    644a:	682a      	ldr	r2, [r5, #0]
    644c:	6a29      	ldr	r1, [r5, #32]
    644e:	9106      	str	r1, [sp, #24]
    6450:	69e9      	ldr	r1, [r5, #28]
    6452:	9105      	str	r1, [sp, #20]
    6454:	69a9      	ldr	r1, [r5, #24]
    6456:	9104      	str	r1, [sp, #16]
    6458:	6969      	ldr	r1, [r5, #20]
    645a:	9103      	str	r1, [sp, #12]
    645c:	6929      	ldr	r1, [r5, #16]
    645e:	9102      	str	r1, [sp, #8]
    6460:	68e9      	ldr	r1, [r5, #12]
    6462:	9101      	str	r1, [sp, #4]
    6464:	68a9      	ldr	r1, [r5, #8]
    6466:	9100      	str	r1, [sp, #0]
    6468:	4651      	mov	r1, sl
    646a:	4648      	mov	r0, r9
    646c:	f7fb face 	bl	1a0c <print_formatted>
		break;
    6470:	e786      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    6472:	686b      	ldr	r3, [r5, #4]
    6474:	682a      	ldr	r2, [r5, #0]
    6476:	6a69      	ldr	r1, [r5, #36]	; 0x24
    6478:	9107      	str	r1, [sp, #28]
    647a:	6a29      	ldr	r1, [r5, #32]
    647c:	9106      	str	r1, [sp, #24]
    647e:	69e9      	ldr	r1, [r5, #28]
    6480:	9105      	str	r1, [sp, #20]
    6482:	69a9      	ldr	r1, [r5, #24]
    6484:	9104      	str	r1, [sp, #16]
    6486:	6969      	ldr	r1, [r5, #20]
    6488:	9103      	str	r1, [sp, #12]
    648a:	6929      	ldr	r1, [r5, #16]
    648c:	9102      	str	r1, [sp, #8]
    648e:	68e9      	ldr	r1, [r5, #12]
    6490:	9101      	str	r1, [sp, #4]
    6492:	68a9      	ldr	r1, [r5, #8]
    6494:	9100      	str	r1, [sp, #0]
    6496:	4651      	mov	r1, sl
    6498:	4648      	mov	r0, r9
    649a:	f7fb fab7 	bl	1a0c <print_formatted>
		break;
    649e:	e76f      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    64a0:	686b      	ldr	r3, [r5, #4]
    64a2:	682a      	ldr	r2, [r5, #0]
    64a4:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    64a6:	9108      	str	r1, [sp, #32]
    64a8:	6a69      	ldr	r1, [r5, #36]	; 0x24
    64aa:	9107      	str	r1, [sp, #28]
    64ac:	6a29      	ldr	r1, [r5, #32]
    64ae:	9106      	str	r1, [sp, #24]
    64b0:	69e9      	ldr	r1, [r5, #28]
    64b2:	9105      	str	r1, [sp, #20]
    64b4:	69a9      	ldr	r1, [r5, #24]
    64b6:	9104      	str	r1, [sp, #16]
    64b8:	6969      	ldr	r1, [r5, #20]
    64ba:	9103      	str	r1, [sp, #12]
    64bc:	6929      	ldr	r1, [r5, #16]
    64be:	9102      	str	r1, [sp, #8]
    64c0:	68e9      	ldr	r1, [r5, #12]
    64c2:	9101      	str	r1, [sp, #4]
    64c4:	68a9      	ldr	r1, [r5, #8]
    64c6:	9100      	str	r1, [sp, #0]
    64c8:	4651      	mov	r1, sl
    64ca:	4648      	mov	r0, r9
    64cc:	f7fb fa9e 	bl	1a0c <print_formatted>
		break;
    64d0:	e756      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    64d2:	686b      	ldr	r3, [r5, #4]
    64d4:	682a      	ldr	r2, [r5, #0]
    64d6:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    64d8:	9109      	str	r1, [sp, #36]	; 0x24
    64da:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    64dc:	9108      	str	r1, [sp, #32]
    64de:	6a69      	ldr	r1, [r5, #36]	; 0x24
    64e0:	9107      	str	r1, [sp, #28]
    64e2:	6a29      	ldr	r1, [r5, #32]
    64e4:	9106      	str	r1, [sp, #24]
    64e6:	69e9      	ldr	r1, [r5, #28]
    64e8:	9105      	str	r1, [sp, #20]
    64ea:	69a9      	ldr	r1, [r5, #24]
    64ec:	9104      	str	r1, [sp, #16]
    64ee:	6969      	ldr	r1, [r5, #20]
    64f0:	9103      	str	r1, [sp, #12]
    64f2:	6929      	ldr	r1, [r5, #16]
    64f4:	9102      	str	r1, [sp, #8]
    64f6:	68e9      	ldr	r1, [r5, #12]
    64f8:	9101      	str	r1, [sp, #4]
    64fa:	68a9      	ldr	r1, [r5, #8]
    64fc:	9100      	str	r1, [sp, #0]
    64fe:	4651      	mov	r1, sl
    6500:	4648      	mov	r0, r9
    6502:	f7fb fa83 	bl	1a0c <print_formatted>
		break;
    6506:	e73b      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    6508:	686b      	ldr	r3, [r5, #4]
    650a:	682a      	ldr	r2, [r5, #0]
    650c:	6b29      	ldr	r1, [r5, #48]	; 0x30
    650e:	910a      	str	r1, [sp, #40]	; 0x28
    6510:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    6512:	9109      	str	r1, [sp, #36]	; 0x24
    6514:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    6516:	9108      	str	r1, [sp, #32]
    6518:	6a69      	ldr	r1, [r5, #36]	; 0x24
    651a:	9107      	str	r1, [sp, #28]
    651c:	6a29      	ldr	r1, [r5, #32]
    651e:	9106      	str	r1, [sp, #24]
    6520:	69e9      	ldr	r1, [r5, #28]
    6522:	9105      	str	r1, [sp, #20]
    6524:	69a9      	ldr	r1, [r5, #24]
    6526:	9104      	str	r1, [sp, #16]
    6528:	6969      	ldr	r1, [r5, #20]
    652a:	9103      	str	r1, [sp, #12]
    652c:	6929      	ldr	r1, [r5, #16]
    652e:	9102      	str	r1, [sp, #8]
    6530:	68e9      	ldr	r1, [r5, #12]
    6532:	9101      	str	r1, [sp, #4]
    6534:	68a9      	ldr	r1, [r5, #8]
    6536:	9100      	str	r1, [sp, #0]
    6538:	4651      	mov	r1, sl
    653a:	4648      	mov	r0, r9
    653c:	f7fb fa66 	bl	1a0c <print_formatted>
		break;
    6540:	e71e      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    6542:	686b      	ldr	r3, [r5, #4]
    6544:	682a      	ldr	r2, [r5, #0]
    6546:	6b69      	ldr	r1, [r5, #52]	; 0x34
    6548:	910b      	str	r1, [sp, #44]	; 0x2c
    654a:	6b29      	ldr	r1, [r5, #48]	; 0x30
    654c:	910a      	str	r1, [sp, #40]	; 0x28
    654e:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    6550:	9109      	str	r1, [sp, #36]	; 0x24
    6552:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    6554:	9108      	str	r1, [sp, #32]
    6556:	6a69      	ldr	r1, [r5, #36]	; 0x24
    6558:	9107      	str	r1, [sp, #28]
    655a:	6a29      	ldr	r1, [r5, #32]
    655c:	9106      	str	r1, [sp, #24]
    655e:	69e9      	ldr	r1, [r5, #28]
    6560:	9105      	str	r1, [sp, #20]
    6562:	69a9      	ldr	r1, [r5, #24]
    6564:	9104      	str	r1, [sp, #16]
    6566:	6969      	ldr	r1, [r5, #20]
    6568:	9103      	str	r1, [sp, #12]
    656a:	6929      	ldr	r1, [r5, #16]
    656c:	9102      	str	r1, [sp, #8]
    656e:	68e9      	ldr	r1, [r5, #12]
    6570:	9101      	str	r1, [sp, #4]
    6572:	68a9      	ldr	r1, [r5, #8]
    6574:	9100      	str	r1, [sp, #0]
    6576:	4651      	mov	r1, sl
    6578:	4648      	mov	r0, r9
    657a:	f7fb fa47 	bl	1a0c <print_formatted>
		break;
    657e:	e6ff      	b.n	6380 <std_print+0x74>
		print_formatted(output, str, args[0], args[1], args[2],
    6580:	686b      	ldr	r3, [r5, #4]
    6582:	682a      	ldr	r2, [r5, #0]
    6584:	6ba9      	ldr	r1, [r5, #56]	; 0x38
    6586:	910c      	str	r1, [sp, #48]	; 0x30
    6588:	6b69      	ldr	r1, [r5, #52]	; 0x34
    658a:	910b      	str	r1, [sp, #44]	; 0x2c
    658c:	6b29      	ldr	r1, [r5, #48]	; 0x30
    658e:	910a      	str	r1, [sp, #40]	; 0x28
    6590:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
    6592:	9109      	str	r1, [sp, #36]	; 0x24
    6594:	6aa9      	ldr	r1, [r5, #40]	; 0x28
    6596:	9108      	str	r1, [sp, #32]
    6598:	6a69      	ldr	r1, [r5, #36]	; 0x24
    659a:	9107      	str	r1, [sp, #28]
    659c:	6a29      	ldr	r1, [r5, #32]
    659e:	9106      	str	r1, [sp, #24]
    65a0:	69e9      	ldr	r1, [r5, #28]
    65a2:	9105      	str	r1, [sp, #20]
    65a4:	69a9      	ldr	r1, [r5, #24]
    65a6:	9104      	str	r1, [sp, #16]
    65a8:	6969      	ldr	r1, [r5, #20]
    65aa:	9103      	str	r1, [sp, #12]
    65ac:	6929      	ldr	r1, [r5, #16]
    65ae:	9102      	str	r1, [sp, #8]
    65b0:	68e9      	ldr	r1, [r5, #12]
    65b2:	9101      	str	r1, [sp, #4]
    65b4:	68a9      	ldr	r1, [r5, #8]
    65b6:	9100      	str	r1, [sp, #0]
    65b8:	4651      	mov	r1, sl
    65ba:	4648      	mov	r0, r9
    65bc:	f7fb fa26 	bl	1a0c <print_formatted>
}
    65c0:	e6de      	b.n	6380 <std_print+0x74>

000065c2 <log_output_flush>:
{
    65c2:	b510      	push	{r4, lr}
    65c4:	4604      	mov	r4, r0
		     output->control_block->offset,
    65c6:	6842      	ldr	r2, [r0, #4]
	buffer_write(output->func, output->buf,
    65c8:	6853      	ldr	r3, [r2, #4]
    65ca:	6812      	ldr	r2, [r2, #0]
    65cc:	6881      	ldr	r1, [r0, #8]
    65ce:	6800      	ldr	r0, [r0, #0]
    65d0:	f7ff fe50 	bl	6274 <buffer_write>
	output->control_block->offset = 0;
    65d4:	6863      	ldr	r3, [r4, #4]
    65d6:	2200      	movs	r2, #0
    65d8:	601a      	str	r2, [r3, #0]
}
    65da:	bd10      	pop	{r4, pc}

000065dc <out_func>:
{
    65dc:	b538      	push	{r3, r4, r5, lr}
    65de:	4605      	mov	r5, r0
    65e0:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
    65e2:	684b      	ldr	r3, [r1, #4]
    65e4:	681a      	ldr	r2, [r3, #0]
    65e6:	68cb      	ldr	r3, [r1, #12]
    65e8:	429a      	cmp	r2, r3
    65ea:	d00f      	beq.n	660c <out_func+0x30>
	idx = atomic_inc(&out_ctx->control_block->offset);
    65ec:	6863      	ldr	r3, [r4, #4]
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
    65ee:	f3bf 8f5b 	dmb	ish
    65f2:	e853 2f00 	ldrex	r2, [r3]
    65f6:	1c51      	adds	r1, r2, #1
    65f8:	e843 1000 	strex	r0, r1, [r3]
    65fc:	2800      	cmp	r0, #0
    65fe:	d1f8      	bne.n	65f2 <out_func+0x16>
    6600:	f3bf 8f5b 	dmb	ish
	out_ctx->buf[idx] = (uint8_t)c;
    6604:	68a3      	ldr	r3, [r4, #8]
    6606:	549d      	strb	r5, [r3, r2]
}
    6608:	2000      	movs	r0, #0
    660a:	bd38      	pop	{r3, r4, r5, pc}
		log_output_flush(out_ctx);
    660c:	4608      	mov	r0, r1
    660e:	f7ff ffd8 	bl	65c2 <log_output_flush>
    6612:	e7eb      	b.n	65ec <out_func+0x10>

00006614 <log_output_msg_process>:
{
    6614:	b5f0      	push	{r4, r5, r6, r7, lr}
    6616:	b085      	sub	sp, #20
    6618:	4606      	mov	r6, r0
    661a:	460c      	mov	r4, r1
    661c:	4617      	mov	r7, r2
    661e:	7a0b      	ldrb	r3, [r1, #8]
    6620:	f083 0301 	eor.w	r3, r3, #1
    6624:	f003 0201 	and.w	r2, r3, #1
	return msg->hdr.timestamp;
    6628:	68cb      	ldr	r3, [r1, #12]
	return msg->hdr.ids.level;
    662a:	7a89      	ldrb	r1, [r1, #10]
	return msg->hdr.ids.domain_id;
    662c:	f3c1 0cc2 	ubfx	ip, r1, #3, #3
	return msg->hdr.ids.source_id;
    6630:	8960      	ldrh	r0, [r4, #10]
	int16_t source_id = (int16_t)log_msg_source_id_get(msg);
    6632:	f3c0 1089 	ubfx	r0, r0, #6, #10
			0 : prefix_print(output, flags, std_msg, timestamp,
    6636:	f011 0507 	ands.w	r5, r1, #7
    663a:	d10f      	bne.n	665c <log_output_msg_process+0x48>
    663c:	2200      	movs	r2, #0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
    663e:	7a23      	ldrb	r3, [r4, #8]
	if (log_msg_is_std(msg)) {
    6640:	f013 0f01 	tst.w	r3, #1
    6644:	d014      	beq.n	6670 <log_output_msg_process+0x5c>
	} else if (raw_string) {
    6646:	b9c5      	cbnz	r5, 667a <log_output_msg_process+0x66>
		raw_string_print(msg, output);
    6648:	4631      	mov	r1, r6
    664a:	4620      	mov	r0, r4
    664c:	f7fb fb1e 	bl	1c8c <raw_string_print>
	if (!raw_string) {
    6650:	b9cd      	cbnz	r5, 6686 <log_output_msg_process+0x72>
	log_output_flush(output);
    6652:	4630      	mov	r0, r6
    6654:	f7ff ffb5 	bl	65c2 <log_output_flush>
}
    6658:	b005      	add	sp, #20
    665a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			0 : prefix_print(output, flags, std_msg, timestamp,
    665c:	9002      	str	r0, [sp, #8]
    665e:	f8cd c004 	str.w	ip, [sp, #4]
    6662:	9500      	str	r5, [sp, #0]
    6664:	4639      	mov	r1, r7
    6666:	4630      	mov	r0, r6
    6668:	f7ff fe29 	bl	62be <prefix_print>
    666c:	4602      	mov	r2, r0
    666e:	e7e6      	b.n	663e <log_output_msg_process+0x2a>
		std_print(msg, output);
    6670:	4631      	mov	r1, r6
    6672:	4620      	mov	r0, r4
    6674:	f7ff fe4a 	bl	630c <std_print>
    6678:	e7ea      	b.n	6650 <log_output_msg_process+0x3c>
		hexdump_print(msg, output, prefix_offset, flags);
    667a:	463b      	mov	r3, r7
    667c:	4631      	mov	r1, r6
    667e:	4620      	mov	r0, r4
    6680:	f7fb fada 	bl	1c38 <hexdump_print>
    6684:	e7e4      	b.n	6650 <log_output_msg_process+0x3c>
		postfix_print(output, flags, level);
    6686:	462a      	mov	r2, r5
    6688:	4639      	mov	r1, r7
    668a:	4630      	mov	r0, r6
    668c:	f7ff fe0b 	bl	62a6 <postfix_print>
    6690:	e7df      	b.n	6652 <log_output_msg_process+0x3e>

00006692 <pm_policy_next_state>:
			return pm_min_residency[i];
		}
	}

	LOG_DBG("No suitable power state found!");
	return (struct pm_state_info){PM_STATE_ACTIVE, 0, 0};
    6692:	2200      	movs	r2, #0
    6694:	6002      	str	r2, [r0, #0]
    6696:	6042      	str	r2, [r0, #4]
    6698:	6082      	str	r2, [r0, #8]
}
    669a:	4770      	bx	lr

0000669c <get_sub_data>:
	struct nrf_clock_control_data *data = dev->data;
    669c:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
    669e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    66a2:	0089      	lsls	r1, r1, #2
    66a4:	3138      	adds	r1, #56	; 0x38
}
    66a6:	4408      	add	r0, r1
    66a8:	4770      	bx	lr

000066aa <get_sub_config>:
	const struct nrf_clock_control_config *config =
    66aa:	6840      	ldr	r0, [r0, #4]
	return &config->subsys[type];
    66ac:	eb01 0141 	add.w	r1, r1, r1, lsl #1
}
    66b0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    66b4:	4770      	bx	lr

000066b6 <get_onoff_manager>:
	struct nrf_clock_control_data *data = dev->data;
    66b6:	6900      	ldr	r0, [r0, #16]
	return &data->mgr[type];
    66b8:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
}
    66bc:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    66c0:	4770      	bx	lr

000066c2 <get_status>:
{
    66c2:	b508      	push	{r3, lr}
	return GET_STATUS(get_sub_data(dev, type)->flags);
    66c4:	b2c9      	uxtb	r1, r1
    66c6:	f7ff ffe9 	bl	669c <get_sub_data>
    66ca:	6880      	ldr	r0, [r0, #8]
}
    66cc:	f000 0007 	and.w	r0, r0, #7
    66d0:	bd08      	pop	{r3, pc}

000066d2 <set_off_state>:
	__asm__ volatile(
    66d2:	f04f 0320 	mov.w	r3, #32
    66d6:	f3ef 8211 	mrs	r2, BASEPRI
    66da:	f383 8811 	msr	BASEPRI, r3
    66de:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    66e2:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    66e4:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
    66e8:	d001      	beq.n	66ee <set_off_state+0x1c>
    66ea:	428b      	cmp	r3, r1
    66ec:	d107      	bne.n	66fe <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
    66ee:	2301      	movs	r3, #1
    66f0:	6003      	str	r3, [r0, #0]
	int err = 0;
    66f2:	2000      	movs	r0, #0
	__asm__ volatile(
    66f4:	f382 8811 	msr	BASEPRI, r2
    66f8:	f3bf 8f6f 	isb	sy
}
    66fc:	4770      	bx	lr
		err = -EPERM;
    66fe:	f04f 30ff 	mov.w	r0, #4294967295
    6702:	e7f7      	b.n	66f4 <set_off_state+0x22>

00006704 <set_starting_state>:
{
    6704:	b410      	push	{r4}
	__asm__ volatile(
    6706:	f04f 0320 	mov.w	r3, #32
    670a:	f3ef 8211 	mrs	r2, BASEPRI
    670e:	f383 8811 	msr	BASEPRI, r3
    6712:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    6716:	6803      	ldr	r3, [r0, #0]
    6718:	f003 04c0 	and.w	r4, r3, #192	; 0xc0
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    671c:	f003 0307 	and.w	r3, r3, #7
    6720:	2b01      	cmp	r3, #1
    6722:	d009      	beq.n	6738 <set_starting_state+0x34>
	} else if (current_ctx != ctx) {
    6724:	428c      	cmp	r4, r1
    6726:	d00a      	beq.n	673e <set_starting_state+0x3a>
		err = -EPERM;
    6728:	f04f 30ff 	mov.w	r0, #4294967295
	__asm__ volatile(
    672c:	f382 8811 	msr	BASEPRI, r2
    6730:	f3bf 8f6f 	isb	sy
}
    6734:	bc10      	pop	{r4}
    6736:	4770      	bx	lr
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    6738:	6001      	str	r1, [r0, #0]
	int err = 0;
    673a:	2000      	movs	r0, #0
    673c:	e7f6      	b.n	672c <set_starting_state+0x28>
		err = -EALREADY;
    673e:	f06f 0077 	mvn.w	r0, #119	; 0x77
    6742:	e7f3      	b.n	672c <set_starting_state+0x28>

00006744 <set_on_state>:
	__asm__ volatile(
    6744:	f04f 0320 	mov.w	r3, #32
    6748:	f3ef 8211 	mrs	r2, BASEPRI
    674c:	f383 8811 	msr	BASEPRI, r3
    6750:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    6754:	6803      	ldr	r3, [r0, #0]
    6756:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    675a:	f043 0302 	orr.w	r3, r3, #2
    675e:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
    6760:	f382 8811 	msr	BASEPRI, r2
    6764:	f3bf 8f6f 	isb	sy
}
    6768:	4770      	bx	lr

0000676a <clkstarted_handle>:
{
    676a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    676c:	4606      	mov	r6, r0
    676e:	460c      	mov	r4, r1
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
    6770:	f7ff ff94 	bl	669c <get_sub_data>
	clock_control_cb_t callback = sub_data->cb;
    6774:	6805      	ldr	r5, [r0, #0]
	void *user_data = sub_data->user_data;
    6776:	6847      	ldr	r7, [r0, #4]
	sub_data->cb = NULL;
    6778:	2300      	movs	r3, #0
    677a:	f840 3b08 	str.w	r3, [r0], #8
	set_on_state(&sub_data->flags);
    677e:	f7ff ffe1 	bl	6744 <set_on_state>
	if (callback) {
    6782:	b11d      	cbz	r5, 678c <clkstarted_handle+0x22>
		callback(dev, (clock_control_subsys_t)type, user_data);
    6784:	463a      	mov	r2, r7
    6786:	4621      	mov	r1, r4
    6788:	4630      	mov	r0, r6
    678a:	47a8      	blx	r5
}
    678c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000678e <stop>:
{
    678e:	b570      	push	{r4, r5, r6, lr}
    6790:	4606      	mov	r6, r0
    6792:	4615      	mov	r5, r2
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    6794:	b2cc      	uxtb	r4, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    6796:	4621      	mov	r1, r4
    6798:	f7ff ff80 	bl	669c <get_sub_data>
	err = set_off_state(&subdata->flags, ctx);
    679c:	4629      	mov	r1, r5
    679e:	3008      	adds	r0, #8
    67a0:	f7ff ff97 	bl	66d2 <set_off_state>
	if (err < 0) {
    67a4:	2800      	cmp	r0, #0
    67a6:	db06      	blt.n	67b6 <stop+0x28>
	get_sub_config(dev, type)->stop();
    67a8:	4621      	mov	r1, r4
    67aa:	4630      	mov	r0, r6
    67ac:	f7ff ff7d 	bl	66aa <get_sub_config>
    67b0:	6843      	ldr	r3, [r0, #4]
    67b2:	4798      	blx	r3
	return 0;
    67b4:	2000      	movs	r0, #0
}
    67b6:	bd70      	pop	{r4, r5, r6, pc}

000067b8 <api_stop>:
{
    67b8:	b508      	push	{r3, lr}
	return stop(dev, subsys, CTX_API);
    67ba:	2280      	movs	r2, #128	; 0x80
    67bc:	f7ff ffe7 	bl	678e <stop>
}
    67c0:	bd08      	pop	{r3, pc}

000067c2 <async_start>:
{
    67c2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    67c6:	4606      	mov	r6, r0
    67c8:	4690      	mov	r8, r2
    67ca:	461f      	mov	r7, r3
	enum clock_control_nrf_type type = (enum clock_control_nrf_type)subsys;
    67cc:	b2cd      	uxtb	r5, r1
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
    67ce:	4629      	mov	r1, r5
    67d0:	f7ff ff64 	bl	669c <get_sub_data>
    67d4:	4604      	mov	r4, r0
	err = set_starting_state(&subdata->flags, ctx);
    67d6:	9906      	ldr	r1, [sp, #24]
    67d8:	3008      	adds	r0, #8
    67da:	f7ff ff93 	bl	6704 <set_starting_state>
	if (err < 0) {
    67de:	2800      	cmp	r0, #0
    67e0:	db09      	blt.n	67f6 <async_start+0x34>
	subdata->cb = cb;
    67e2:	f8c4 8000 	str.w	r8, [r4]
	subdata->user_data = user_data;
    67e6:	6067      	str	r7, [r4, #4]
	 get_sub_config(dev, type)->start();
    67e8:	4629      	mov	r1, r5
    67ea:	4630      	mov	r0, r6
    67ec:	f7ff ff5d 	bl	66aa <get_sub_config>
    67f0:	6803      	ldr	r3, [r0, #0]
    67f2:	4798      	blx	r3
	return 0;
    67f4:	2000      	movs	r0, #0
}
    67f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000067fa <api_start>:
{
    67fa:	b510      	push	{r4, lr}
    67fc:	b082      	sub	sp, #8
	return async_start(dev, subsys, cb, user_data, CTX_API);
    67fe:	2480      	movs	r4, #128	; 0x80
    6800:	9400      	str	r4, [sp, #0]
    6802:	f7ff ffde 	bl	67c2 <async_start>
}
    6806:	b002      	add	sp, #8
    6808:	bd10      	pop	{r4, pc}

0000680a <onoff_started_callback>:
{
    680a:	b510      	push	{r4, lr}
    680c:	4614      	mov	r4, r2
	struct onoff_manager *mgr = get_onoff_manager(dev, type);
    680e:	b2c9      	uxtb	r1, r1
    6810:	f7ff ff51 	bl	66b6 <get_onoff_manager>
	notify(mgr, 0);
    6814:	2100      	movs	r1, #0
    6816:	47a0      	blx	r4
}
    6818:	bd10      	pop	{r4, pc}

0000681a <hfclk_start>:
{
    681a:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    681c:	2001      	movs	r0, #1
    681e:	f7fd fafb 	bl	3e18 <nrfx_clock_start>
}
    6822:	bd08      	pop	{r3, pc}

00006824 <hfclk_stop>:
{
    6824:	b508      	push	{r3, lr}
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    6826:	2001      	movs	r0, #1
    6828:	f7fd fb34 	bl	3e94 <nrfx_clock_stop>
}
    682c:	bd08      	pop	{r3, pc}

0000682e <lfclk_stop>:
{
    682e:	b508      	push	{r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    6830:	2000      	movs	r0, #0
    6832:	f7fd fb2f 	bl	3e94 <nrfx_clock_stop>
}
    6836:	bd08      	pop	{r3, pc}

00006838 <blocking_start_callback>:
{
    6838:	b508      	push	{r3, lr}
    683a:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
    683c:	f7fe f970 	bl	4b20 <z_impl_k_sem_give>
}
    6840:	bd08      	pop	{r3, pc}

00006842 <sys_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces*/

void __weak sys_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
    6842:	4770      	bx	lr

00006844 <sys_clock_idle_exit>:
{
}

void __weak sys_clock_idle_exit(void)
{
}
    6844:	4770      	bx	lr

00006846 <counter_sub>:
	return (a - b) & COUNTER_MAX;
    6846:	1a40      	subs	r0, r0, r1
}
    6848:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
    684c:	4770      	bx	lr

0000684e <event_clear>:
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    684e:	f100 0350 	add.w	r3, r0, #80	; 0x50
    6852:	009b      	lsls	r3, r3, #2
    6854:	b29b      	uxth	r3, r3
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    6856:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    685a:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
    685e:	2200      	movs	r2, #0
    6860:	601a      	str	r2, [r3, #0]
    6862:	681b      	ldr	r3, [r3, #0]
}
    6864:	4770      	bx	lr

00006866 <set_absolute_alarm>:
{
    6866:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6868:	4606      	mov	r6, r0
	uint32_t cc_val = abs_val & COUNTER_MAX;
    686a:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	uint32_t prev_cc = get_comparator(chan);
    686e:	f7fb fddb 	bl	2428 <get_comparator>
    6872:	4607      	mov	r7, r0
    6874:	e019      	b.n	68aa <set_absolute_alarm+0x44>
	z_impl_k_busy_wait(usec_to_wait);
    6876:	2013      	movs	r0, #19
    6878:	f000 ff7c 	bl	7774 <z_impl_k_busy_wait>
}
    687c:	e022      	b.n	68c4 <set_absolute_alarm+0x5e>
		event_clear(chan);
    687e:	4630      	mov	r0, r6
    6880:	f7ff ffe5 	bl	684e <event_clear>
		event_enable(chan);
    6884:	4630      	mov	r0, r6
    6886:	f7fb fdd7 	bl	2438 <event_enable>
		set_comparator(chan, cc_val);
    688a:	4629      	mov	r1, r5
    688c:	4630      	mov	r0, r6
    688e:	f7fb fdc1 	bl	2414 <set_comparator>
		now2 = counter();
    6892:	f7fb fde5 	bl	2460 <counter>
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    6896:	4284      	cmp	r4, r0
    6898:	d01e      	beq.n	68d8 <set_absolute_alarm+0x72>
    689a:	1c81      	adds	r1, r0, #2
    689c:	4628      	mov	r0, r5
    689e:	f7ff ffd2 	bl	6846 <counter_sub>
	} while ((now2 != now) &&
    68a2:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    68a6:	d917      	bls.n	68d8 <set_absolute_alarm+0x72>
		prev_cc = cc_val;
    68a8:	462f      	mov	r7, r5
		now = counter();
    68aa:	f7fb fdd9 	bl	2460 <counter>
    68ae:	4604      	mov	r4, r0
		set_comparator(chan, now);
    68b0:	4601      	mov	r1, r0
    68b2:	4630      	mov	r0, r6
    68b4:	f7fb fdae 	bl	2414 <set_comparator>
		if (counter_sub(prev_cc, now) == 1) {
    68b8:	4621      	mov	r1, r4
    68ba:	4638      	mov	r0, r7
    68bc:	f7ff ffc3 	bl	6846 <counter_sub>
    68c0:	2801      	cmp	r0, #1
    68c2:	d0d8      	beq.n	6876 <set_absolute_alarm+0x10>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    68c4:	1ca7      	adds	r7, r4, #2
    68c6:	4639      	mov	r1, r7
    68c8:	4628      	mov	r0, r5
    68ca:	f7ff ffbc 	bl	6846 <counter_sub>
    68ce:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    68d2:	d9d4      	bls.n	687e <set_absolute_alarm+0x18>
			cc_val = now + 2;
    68d4:	463d      	mov	r5, r7
    68d6:	e7d2      	b.n	687e <set_absolute_alarm+0x18>
}
    68d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

000068da <z_irq_spurious>:
 * called.
 *
 * @return N/A
 */
void z_irq_spurious(const void *unused)
{
    68da:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    68dc:	2100      	movs	r1, #0
    68de:	2001      	movs	r0, #1
    68e0:	f000 f801 	bl	68e6 <z_arm_fatal_error>
}
    68e4:	bd08      	pop	{r3, pc}

000068e6 <z_arm_fatal_error>:

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    68e6:	b538      	push	{r3, r4, r5, lr}
    68e8:	4604      	mov	r4, r0

	if (esf != NULL) {
    68ea:	460d      	mov	r5, r1
    68ec:	b111      	cbz	r1, 68f4 <z_arm_fatal_error+0xe>
		esf_dump(esf);
    68ee:	4608      	mov	r0, r1
    68f0:	f7fb ffa8 	bl	2844 <esf_dump>
	}
	z_fatal_error(reason, esf);
    68f4:	4629      	mov	r1, r5
    68f6:	4620      	mov	r0, r4
    68f8:	f7fd fd92 	bl	4420 <z_fatal_error>
}
    68fc:	bd38      	pop	{r3, r4, r5, pc}

000068fe <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    68fe:	b508      	push	{r3, lr}
    6900:	4601      	mov	r1, r0
	}

#endif /* CONFIG_USERSPACE */

#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	z_arm_fatal_error(reason, esf);
    6902:	6800      	ldr	r0, [r0, #0]
    6904:	f7ff ffef 	bl	68e6 <z_arm_fatal_error>

	memcpy(&esf_copy, esf, offsetof(z_arch_esf_t, extra_info));
	esf_copy.extra_info = (struct __extra_esf_info) { 0 };
	z_arm_fatal_error(reason, &esf_copy);
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
}
    6908:	bd08      	pop	{r3, pc}

0000690a <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
    690a:	b508      	push	{r3, lr}
	handler();
    690c:	f7fb ffe8 	bl	28e0 <z_SysNmiOnReset>
	z_arm_int_exit();
    6910:	f7fc fbde 	bl	30d0 <z_arm_exc_exit>
}
    6914:	bd08      	pop	{r3, pc}

00006916 <memory_fault_recoverable>:
}
    6916:	2000      	movs	r0, #0
    6918:	4770      	bx	lr

0000691a <fault_handle>:
{
    691a:	b508      	push	{r3, lr}
	*recoverable = false;
    691c:	2300      	movs	r3, #0
    691e:	7013      	strb	r3, [r2, #0]
	switch (fault) {
    6920:	1ecb      	subs	r3, r1, #3
    6922:	2b09      	cmp	r3, #9
    6924:	d81a      	bhi.n	695c <fault_handle+0x42>
    6926:	e8df f003 	tbb	[pc, r3]
    692a:	0905      	.short	0x0905
    692c:	1919110d 	.word	0x1919110d
    6930:	14191919 	.word	0x14191919
		reason = hard_fault(esf, recoverable);
    6934:	4611      	mov	r1, r2
    6936:	f7fc facd 	bl	2ed4 <hard_fault>
}
    693a:	bd08      	pop	{r3, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
    693c:	2100      	movs	r1, #0
    693e:	f7fc f9e7 	bl	2d10 <mem_manage_fault>
		break;
    6942:	e7fa      	b.n	693a <fault_handle+0x20>
		reason = bus_fault(esf, 0, recoverable);
    6944:	2100      	movs	r1, #0
    6946:	f7fc f90b 	bl	2b60 <bus_fault>
		break;
    694a:	e7f6      	b.n	693a <fault_handle+0x20>
		reason = usage_fault(esf);
    694c:	f7fc f83c 	bl	29c8 <usage_fault>
		break;
    6950:	e7f3      	b.n	693a <fault_handle+0x20>
		debug_monitor(esf, recoverable);
    6952:	4611      	mov	r1, r2
    6954:	f7fc f8ea 	bl	2b2c <debug_monitor>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    6958:	2000      	movs	r0, #0
		break;
    695a:	e7ee      	b.n	693a <fault_handle+0x20>
		reserved_exception(esf, fault);
    695c:	f7fc fb2a 	bl	2fb4 <reserved_exception>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    6960:	2000      	movs	r0, #0
	return reason;
    6962:	e7ea      	b.n	693a <fault_handle+0x20>

00006964 <mpu_partition_is_valid>:
		((part->size & (part->size - 1U)) == 0U)
    6964:	6843      	ldr	r3, [r0, #4]
    6966:	1e5a      	subs	r2, r3, #1
		&&
    6968:	4213      	tst	r3, r2
    696a:	d106      	bne.n	697a <mpu_partition_is_valid+0x16>
		&&
    696c:	2b1f      	cmp	r3, #31
    696e:	d906      	bls.n	697e <mpu_partition_is_valid+0x1a>
		((part->start & (part->size - 1U)) == 0U);
    6970:	6803      	ldr	r3, [r0, #0]
		&&
    6972:	421a      	tst	r2, r3
    6974:	d005      	beq.n	6982 <mpu_partition_is_valid+0x1e>
    6976:	2000      	movs	r0, #0
    6978:	4770      	bx	lr
    697a:	2000      	movs	r0, #0
    697c:	4770      	bx	lr
    697e:	2000      	movs	r0, #0
    6980:	4770      	bx	lr
    6982:	2001      	movs	r0, #1
}
    6984:	4770      	bx	lr

00006986 <mpu_configure_region>:
{
    6986:	b500      	push	{lr}
    6988:	b085      	sub	sp, #20
	region_conf.base = new_region->start;
    698a:	680b      	ldr	r3, [r1, #0]
    698c:	9301      	str	r3, [sp, #4]
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
    698e:	684b      	ldr	r3, [r1, #4]
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    6990:	688a      	ldr	r2, [r1, #8]
	if (size <= 32U) {
    6992:	2b20      	cmp	r3, #32
    6994:	d912      	bls.n	69bc <mpu_configure_region+0x36>
	if (size > (1UL << 31)) {
    6996:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
    699a:	d811      	bhi.n	69c0 <mpu_configure_region+0x3a>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    699c:	3b01      	subs	r3, #1
    699e:	fab3 f383 	clz	r3, r3
    69a2:	f1c3 031f 	rsb	r3, r3, #31
    69a6:	005b      	lsls	r3, r3, #1
    69a8:	f003 033e 	and.w	r3, r3, #62	; 0x3e
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    69ac:	4313      	orrs	r3, r2
    69ae:	9303      	str	r3, [sp, #12]
	return region_allocate_and_init(index,
    69b0:	a901      	add	r1, sp, #4
    69b2:	f7fc fc35 	bl	3220 <region_allocate_and_init>
}
    69b6:	b005      	add	sp, #20
    69b8:	f85d fb04 	ldr.w	pc, [sp], #4
		return REGION_32B;
    69bc:	2308      	movs	r3, #8
    69be:	e7f5      	b.n	69ac <mpu_configure_region+0x26>
		return REGION_4G;
    69c0:	233e      	movs	r3, #62	; 0x3e
    69c2:	e7f3      	b.n	69ac <mpu_configure_region+0x26>

000069c4 <arm_core_mpu_configure_static_mpu_regions>:
{
    69c4:	b508      	push	{r3, lr}
	if (mpu_configure_static_mpu_regions(static_regions, regions_num,
    69c6:	f7fc fc8d 	bl	32e4 <mpu_configure_static_mpu_regions>
}
    69ca:	bd08      	pop	{r3, pc}

000069cc <arm_core_mpu_configure_dynamic_mpu_regions>:
{
    69cc:	b508      	push	{r3, lr}
	if (mpu_configure_dynamic_mpu_regions(dynamic_regions, regions_num)
    69ce:	f7fc fc93 	bl	32f8 <mpu_configure_dynamic_mpu_regions>
}
    69d2:	bd08      	pop	{r3, pc}

000069d4 <strcpy>:

char *strcpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s)
{
	char *dest = d;

	while (*s != '\0') {
    69d4:	4602      	mov	r2, r0
    69d6:	780b      	ldrb	r3, [r1, #0]
    69d8:	b11b      	cbz	r3, 69e2 <strcpy+0xe>
		*d = *s;
    69da:	f802 3b01 	strb.w	r3, [r2], #1
		d++;
		s++;
    69de:	3101      	adds	r1, #1
    69e0:	e7f9      	b.n	69d6 <strcpy+0x2>
	}

	*d = '\0';
    69e2:	7013      	strb	r3, [r2, #0]

	return dest;
}
    69e4:	4770      	bx	lr

000069e6 <strncpy>:

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
	char *dest = d;

	while ((n > 0) && *s != '\0') {
    69e6:	4603      	mov	r3, r0
    69e8:	b1a2      	cbz	r2, 6a14 <strncpy+0x2e>
{
    69ea:	b410      	push	{r4}
	while ((n > 0) && *s != '\0') {
    69ec:	780c      	ldrb	r4, [r1, #0]
    69ee:	b12c      	cbz	r4, 69fc <strncpy+0x16>
		*d = *s;
    69f0:	f803 4b01 	strb.w	r4, [r3], #1
		s++;
    69f4:	3101      	adds	r1, #1
		d++;
		n--;
    69f6:	3a01      	subs	r2, #1
	while ((n > 0) && *s != '\0') {
    69f8:	2a00      	cmp	r2, #0
    69fa:	d1f7      	bne.n	69ec <strncpy+0x6>
	}

	while (n > 0) {
    69fc:	b122      	cbz	r2, 6a08 <strncpy+0x22>
		*d = '\0';
    69fe:	2100      	movs	r1, #0
    6a00:	f803 1b01 	strb.w	r1, [r3], #1
		d++;
		n--;
    6a04:	3a01      	subs	r2, #1
    6a06:	e7f9      	b.n	69fc <strncpy+0x16>
	}

	return dest;
}
    6a08:	bc10      	pop	{r4}
    6a0a:	4770      	bx	lr
		*d = '\0';
    6a0c:	2100      	movs	r1, #0
    6a0e:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    6a12:	3a01      	subs	r2, #1
	while (n > 0) {
    6a14:	2a00      	cmp	r2, #0
    6a16:	d1f9      	bne.n	6a0c <strncpy+0x26>
    6a18:	4770      	bx	lr

00006a1a <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
    6a1a:	4603      	mov	r3, r0
	size_t n = 0;
    6a1c:	2000      	movs	r0, #0

	while (*s != '\0') {
    6a1e:	781a      	ldrb	r2, [r3, #0]
    6a20:	b112      	cbz	r2, 6a28 <strlen+0xe>
		s++;
    6a22:	3301      	adds	r3, #1
		n++;
    6a24:	3001      	adds	r0, #1
    6a26:	e7fa      	b.n	6a1e <strlen+0x4>
	}

	return n;
}
    6a28:	4770      	bx	lr

00006a2a <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
    6a2a:	4603      	mov	r3, r0
	size_t n = 0;
    6a2c:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
    6a2e:	781a      	ldrb	r2, [r3, #0]
    6a30:	b122      	cbz	r2, 6a3c <strnlen+0x12>
    6a32:	4288      	cmp	r0, r1
    6a34:	d202      	bcs.n	6a3c <strnlen+0x12>
		s++;
    6a36:	3301      	adds	r3, #1
		n++;
    6a38:	3001      	adds	r0, #1
    6a3a:	e7f8      	b.n	6a2e <strnlen+0x4>
	}

	return n;
}
    6a3c:	4770      	bx	lr

00006a3e <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    6a3e:	7803      	ldrb	r3, [r0, #0]
    6a40:	780a      	ldrb	r2, [r1, #0]
    6a42:	4293      	cmp	r3, r2
    6a44:	d103      	bne.n	6a4e <strcmp+0x10>
    6a46:	b113      	cbz	r3, 6a4e <strcmp+0x10>
		s1++;
    6a48:	3001      	adds	r0, #1
		s2++;
    6a4a:	3101      	adds	r1, #1
    6a4c:	e7f7      	b.n	6a3e <strcmp>
	}

	return *s1 - *s2;
}
    6a4e:	1a98      	subs	r0, r3, r2
    6a50:	4770      	bx	lr

00006a52 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
    6a52:	b410      	push	{r4}
	const unsigned char *s_byte = (const unsigned char *)s;

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
    6a54:	ea80 0301 	eor.w	r3, r0, r1
    6a58:	f013 0f03 	tst.w	r3, #3
    6a5c:	d001      	beq.n	6a62 <memcpy+0x10>
	unsigned char *d_byte = (unsigned char *)d;
    6a5e:	4603      	mov	r3, r0
    6a60:	e017      	b.n	6a92 <memcpy+0x40>
    6a62:	4603      	mov	r3, r0

		/* do byte-sized copying until word-aligned or finished */

		while (((uintptr_t)d_byte) & mask) {
    6a64:	f013 0f03 	tst.w	r3, #3
    6a68:	d00b      	beq.n	6a82 <memcpy+0x30>
			if (n == 0) {
    6a6a:	b1a2      	cbz	r2, 6a96 <memcpy+0x44>
				return d;
			}
			*(d_byte++) = *(s_byte++);
    6a6c:	f811 4b01 	ldrb.w	r4, [r1], #1
    6a70:	f803 4b01 	strb.w	r4, [r3], #1
			n--;
    6a74:	3a01      	subs	r2, #1
    6a76:	e7f5      	b.n	6a64 <memcpy+0x12>

		mem_word_t *d_word = (mem_word_t *)d_byte;
		const mem_word_t *s_word = (const mem_word_t *)s_byte;

		while (n >= sizeof(mem_word_t)) {
			*(d_word++) = *(s_word++);
    6a78:	f851 4b04 	ldr.w	r4, [r1], #4
    6a7c:	f843 4b04 	str.w	r4, [r3], #4
			n -= sizeof(mem_word_t);
    6a80:	3a04      	subs	r2, #4
		while (n >= sizeof(mem_word_t)) {
    6a82:	2a03      	cmp	r2, #3
    6a84:	d8f8      	bhi.n	6a78 <memcpy+0x26>
    6a86:	e004      	b.n	6a92 <memcpy+0x40>
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
		*(d_byte++) = *(s_byte++);
    6a88:	f811 4b01 	ldrb.w	r4, [r1], #1
    6a8c:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
    6a90:	3a01      	subs	r2, #1
	while (n > 0) {
    6a92:	2a00      	cmp	r2, #0
    6a94:	d1f8      	bne.n	6a88 <memcpy+0x36>
	}

	return d;
}
    6a96:	bc10      	pop	{r4}
    6a98:	4770      	bx	lr

00006a9a <memset>:
 *
 * @return pointer to start of buffer
 */

void *memset(void *buf, int c, size_t n)
{
    6a9a:	b410      	push	{r4}
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    6a9c:	b2cc      	uxtb	r4, r1
	unsigned char *d_byte = (unsigned char *)buf;
    6a9e:	4603      	mov	r3, r0

#if !defined(CONFIG_MINIMAL_LIBC_OPTIMIZE_STRING_FOR_SIZE)
	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
    6aa0:	f013 0f03 	tst.w	r3, #3
    6aa4:	d004      	beq.n	6ab0 <memset+0x16>
		if (n == 0) {
    6aa6:	b19a      	cbz	r2, 6ad0 <memset+0x36>
			return buf;
		}
		*(d_byte++) = c_byte;
    6aa8:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
    6aac:	3a01      	subs	r2, #1
    6aae:	e7f7      	b.n	6aa0 <memset+0x6>
	}

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
    6ab0:	b2c9      	uxtb	r1, r1

	c_word |= c_word << 8;
    6ab2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
	c_word |= c_word << 16;
    6ab6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
    6aba:	2a03      	cmp	r2, #3
    6abc:	d906      	bls.n	6acc <memset+0x32>
		*(d_word++) = c_word;
    6abe:	f843 1b04 	str.w	r1, [r3], #4
		n -= sizeof(mem_word_t);
    6ac2:	3a04      	subs	r2, #4
    6ac4:	e7f9      	b.n	6aba <memset+0x20>

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
		*(d_byte++) = c_byte;
    6ac6:	f803 4b01 	strb.w	r4, [r3], #1
		n--;
    6aca:	3a01      	subs	r2, #1
	while (n > 0) {
    6acc:	2a00      	cmp	r2, #0
    6ace:	d1fa      	bne.n	6ac6 <memset+0x2c>
	}

	return buf;
}
    6ad0:	bc10      	pop	{r4}
    6ad2:	4770      	bx	lr

00006ad4 <_stdout_hook_default>:
}
    6ad4:	f04f 30ff 	mov.w	r0, #4294967295
    6ad8:	4770      	bx	lr

00006ada <pm_power_state_set>:
#include <logging/log.h>
LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);

/* Invoke Low Power/System Off specific Tasks */
__weak void pm_power_state_set(struct pm_state_info info)
{
    6ada:	b084      	sub	sp, #16
    6adc:	ab04      	add	r3, sp, #16
    6ade:	e903 0007 	stmdb	r3, {r0, r1, r2}
	switch (info.state) {
    6ae2:	f89d 3004 	ldrb.w	r3, [sp, #4]
    6ae6:	2b06      	cmp	r3, #6
    6ae8:	d001      	beq.n	6aee <pm_power_state_set+0x14>
		break;
	default:
		LOG_DBG("Unsupported power state %u", info.state);
		break;
	}
}
    6aea:	b004      	add	sp, #16
    6aec:	4770      	bx	lr
    p_reg->SYSTEMOFF = POWER_SYSTEMOFF_SYSTEMOFF_Enter;
    6aee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    6af2:	2201      	movs	r2, #1
    6af4:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
  __ASM volatile ("dsb 0xF":::"memory");
    6af8:	f3bf 8f4f 	dsb	sy
        __WFE();
    6afc:	bf20      	wfe
    while (true)
    6afe:	e7fd      	b.n	6afc <pm_power_state_set+0x22>

00006b00 <pm_power_state_exit_post_ops>:

/* Handle SOC specific activity after Low Power Mode Exit */
__weak void pm_power_state_exit_post_ops(struct pm_state_info info)
{
    6b00:	b084      	sub	sp, #16
    6b02:	ab04      	add	r3, sp, #16
    6b04:	e903 0007 	stmdb	r3, {r0, r1, r2}
    6b08:	2300      	movs	r3, #0
    6b0a:	f383 8811 	msr	BASEPRI, r3
    6b0e:	f3bf 8f6f 	isb	sy
	/*
	 * System is now in active mode. Reenable interrupts which were disabled
	 * when OS started idling code.
	 */
	irq_unlock(0);
}
    6b12:	b004      	add	sp, #16
    6b14:	4770      	bx	lr

00006b16 <gpio_nrfx_port_get_raw>:
	return port->config;
    6b16:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    6b18:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
    6b1a:	f8d3 3510 	ldr.w	r3, [r3, #1296]	; 0x510
	*value = nrf_gpio_port_in_read(reg);
    6b1e:	600b      	str	r3, [r1, #0]
}
    6b20:	2000      	movs	r0, #0
    6b22:	4770      	bx	lr

00006b24 <gpio_nrfx_port_set_masked_raw>:
	return port->config;
    6b24:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    6b26:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
    6b28:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
    6b2c:	4042      	eors	r2, r0
    6b2e:	400a      	ands	r2, r1
    6b30:	4042      	eors	r2, r0
    p_reg->OUT = value;
    6b32:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
    6b36:	2000      	movs	r0, #0
    6b38:	4770      	bx	lr

00006b3a <gpio_nrfx_port_set_bits_raw>:
	return port->config;
    6b3a:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    6b3c:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
    6b3e:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
}
    6b42:	2000      	movs	r0, #0
    6b44:	4770      	bx	lr

00006b46 <gpio_nrfx_port_clear_bits_raw>:
	return port->config;
    6b46:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    6b48:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
    6b4a:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
}
    6b4e:	2000      	movs	r0, #0
    6b50:	4770      	bx	lr

00006b52 <gpio_nrfx_port_toggle_bits>:
	return port->config;
    6b52:	6843      	ldr	r3, [r0, #4]
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    6b54:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
    6b56:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
	nrf_gpio_port_out_write(reg, value ^ mask);
    6b5a:	404b      	eors	r3, r1
    p_reg->OUT = value;
    6b5c:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
}
    6b60:	2000      	movs	r0, #0
    6b62:	4770      	bx	lr

00006b64 <gpio_nrfx_manage_callback>:
{
    6b64:	b470      	push	{r4, r5, r6}
	return port->data;
    6b66:	6900      	ldr	r0, [r0, #16]
	return gpio_manage_callback(&get_port_data(port)->callbacks,
    6b68:	1d05      	adds	r5, r0, #4
	return list->head;
    6b6a:	6843      	ldr	r3, [r0, #4]
	if (!sys_slist_is_empty(callbacks)) {
    6b6c:	b1db      	cbz	r3, 6ba6 <gpio_nrfx_manage_callback+0x42>
		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
    6b6e:	460e      	mov	r6, r1
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

/** @} */
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    6b70:	2400      	movs	r4, #0
    6b72:	e00a      	b.n	6b8a <gpio_nrfx_manage_callback+0x26>
	return node->next;
    6b74:	680b      	ldr	r3, [r1, #0]
	list->head = node;
    6b76:	6043      	str	r3, [r0, #4]
	return list->tail;
    6b78:	686c      	ldr	r4, [r5, #4]
Z_GENLIST_REMOVE(slist, snode)
    6b7a:	42a1      	cmp	r1, r4
    6b7c:	d10f      	bne.n	6b9e <gpio_nrfx_manage_callback+0x3a>
	list->tail = node;
    6b7e:	606b      	str	r3, [r5, #4]
}
    6b80:	e00d      	b.n	6b9e <gpio_nrfx_manage_callback+0x3a>
	list->tail = node;
    6b82:	606c      	str	r4, [r5, #4]
}
    6b84:	e00b      	b.n	6b9e <gpio_nrfx_manage_callback+0x3a>
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    6b86:	461c      	mov	r4, r3
    6b88:	681b      	ldr	r3, [r3, #0]
    6b8a:	b15b      	cbz	r3, 6ba4 <gpio_nrfx_manage_callback+0x40>
    6b8c:	429e      	cmp	r6, r3
    6b8e:	d1fa      	bne.n	6b86 <gpio_nrfx_manage_callback+0x22>
Z_GENLIST_REMOVE(slist, snode)
    6b90:	2c00      	cmp	r4, #0
    6b92:	d0ef      	beq.n	6b74 <gpio_nrfx_manage_callback+0x10>
	return node->next;
    6b94:	680b      	ldr	r3, [r1, #0]
	parent->next = child;
    6b96:	6023      	str	r3, [r4, #0]
	return list->tail;
    6b98:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_REMOVE(slist, snode)
    6b9a:	4299      	cmp	r1, r3
    6b9c:	d0f1      	beq.n	6b82 <gpio_nrfx_manage_callback+0x1e>
	parent->next = child;
    6b9e:	2300      	movs	r3, #0
    6ba0:	600b      	str	r3, [r1, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
    6ba2:	e000      	b.n	6ba6 <gpio_nrfx_manage_callback+0x42>
			if (!set) {
    6ba4:	b152      	cbz	r2, 6bbc <gpio_nrfx_manage_callback+0x58>
	if (set) {
    6ba6:	b162      	cbz	r2, 6bc2 <gpio_nrfx_manage_callback+0x5e>
	return list->head;
    6ba8:	6843      	ldr	r3, [r0, #4]
	parent->next = child;
    6baa:	600b      	str	r3, [r1, #0]
	list->head = node;
    6bac:	6041      	str	r1, [r0, #4]
	return list->tail;
    6bae:	686b      	ldr	r3, [r5, #4]
Z_GENLIST_PREPEND(slist, snode)
    6bb0:	b10b      	cbz	r3, 6bb6 <gpio_nrfx_manage_callback+0x52>
	return 0;
    6bb2:	2000      	movs	r0, #0
    6bb4:	e006      	b.n	6bc4 <gpio_nrfx_manage_callback+0x60>
	list->tail = node;
    6bb6:	6069      	str	r1, [r5, #4]
    6bb8:	2000      	movs	r0, #0
}
    6bba:	e003      	b.n	6bc4 <gpio_nrfx_manage_callback+0x60>
				return -EINVAL;
    6bbc:	f06f 0015 	mvn.w	r0, #21
    6bc0:	e000      	b.n	6bc4 <gpio_nrfx_manage_callback+0x60>
	return 0;
    6bc2:	2000      	movs	r0, #0
}
    6bc4:	bc70      	pop	{r4, r5, r6}
    6bc6:	4770      	bx	lr

00006bc8 <cfg_level_pins>:
{
    6bc8:	b4f0      	push	{r4, r5, r6, r7}
	return port->data;
    6bca:	6905      	ldr	r5, [r0, #16]
	return port->config;
    6bcc:	6846      	ldr	r6, [r0, #4]
	uint32_t out = data->pin_int_en;
    6bce:	68e9      	ldr	r1, [r5, #12]
	out &= ~data->trig_edge & ~data->double_edge;
    6bd0:	696a      	ldr	r2, [r5, #20]
    6bd2:	69ab      	ldr	r3, [r5, #24]
    6bd4:	4313      	orrs	r3, r2
    6bd6:	ea21 0103 	bic.w	r1, r1, r3
	uint32_t bit = 1U << pin;
    6bda:	2201      	movs	r2, #1
	uint32_t pin = 0U;
    6bdc:	2000      	movs	r0, #0
	while (level_pins) {
    6bde:	e013      	b.n	6c08 <cfg_level_pins+0x40>
		return NRF_GPIO_PIN_SENSE_HIGH;
    6be0:	f04f 0c02 	mov.w	ip, #2
    *p_pin = pin_number & 0x1F;
    6be4:	f003 031f 	and.w	r3, r3, #31
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    6be8:	f04f 47a0 	mov.w	r7, #1342177280	; 0x50000000
    6bec:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    6bf0:	f857 4023 	ldr.w	r4, [r7, r3, lsl #2]
    6bf4:	f424 3440 	bic.w	r4, r4, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    6bf8:	ea44 440c 	orr.w	r4, r4, ip, lsl #16
    6bfc:	f847 4023 	str.w	r4, [r7, r3, lsl #2]
			level_pins &= ~bit;
    6c00:	ea21 0102 	bic.w	r1, r1, r2
		++pin;
    6c04:	3001      	adds	r0, #1
		bit <<= 1;
    6c06:	0052      	lsls	r2, r2, #1
	while (level_pins) {
    6c08:	b171      	cbz	r1, 6c28 <cfg_level_pins+0x60>
		if (level_pins & bit) {
    6c0a:	420a      	tst	r2, r1
    6c0c:	d0fa      	beq.n	6c04 <cfg_level_pins+0x3c>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    6c0e:	7a34      	ldrb	r4, [r6, #8]
    6c10:	f000 031f 	and.w	r3, r0, #31
    6c14:	ea43 1344 	orr.w	r3, r3, r4, lsl #5
	if ((BIT(pin) & data->int_active_level) != 0U) {
    6c18:	692c      	ldr	r4, [r5, #16]
    6c1a:	40c4      	lsrs	r4, r0
    6c1c:	f014 0f01 	tst.w	r4, #1
    6c20:	d1de      	bne.n	6be0 <cfg_level_pins+0x18>
	return NRF_GPIO_PIN_SENSE_LOW;
    6c22:	f04f 0c03 	mov.w	ip, #3
    6c26:	e7dd      	b.n	6be4 <cfg_level_pins+0x1c>
}
    6c28:	bcf0      	pop	{r4, r5, r6, r7}
    6c2a:	4770      	bx	lr

00006c2c <check_level_trigger_pins>:
{
    6c2c:	b5f0      	push	{r4, r5, r6, r7, lr}
    6c2e:	468e      	mov	lr, r1
	return port->data;
    6c30:	6903      	ldr	r3, [r0, #16]
	return port->config;
    6c32:	6841      	ldr	r1, [r0, #4]
	uint32_t out = data->pin_int_en;
    6c34:	68d8      	ldr	r0, [r3, #12]
	out &= ~data->trig_edge & ~data->double_edge;
    6c36:	695a      	ldr	r2, [r3, #20]
    6c38:	699c      	ldr	r4, [r3, #24]
    6c3a:	4322      	orrs	r2, r4
    6c3c:	ea20 0c02 	bic.w	ip, r0, r2
	uint32_t port_in = nrf_gpio_port_in_read(cfg->port);
    6c40:	684a      	ldr	r2, [r1, #4]
    return p_reg->IN;
    6c42:	f8d2 2510 	ldr.w	r2, [r2, #1296]	; 0x510
	uint32_t pin_states = ~(port_in ^ data->int_active_level);
    6c46:	6918      	ldr	r0, [r3, #16]
    6c48:	4050      	eors	r0, r2
	uint32_t out = pin_states & level_pins;
    6c4a:	ea2c 0000 	bic.w	r0, ip, r0
	uint32_t check_pins = level_pins;
    6c4e:	4664      	mov	r4, ip
	uint32_t bit = 1U << pin;
    6c50:	2201      	movs	r2, #1
	uint32_t pin = 0U;
    6c52:	2500      	movs	r5, #0
	while (check_pins) {
    6c54:	e00f      	b.n	6c76 <check_level_trigger_pins+0x4a>
    *p_pin = pin_number & 0x1F;
    6c56:	f003 031f 	and.w	r3, r3, #31
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    6c5a:	f04f 47a0 	mov.w	r7, #1342177280	; 0x50000000
    6c5e:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    6c62:	f857 6023 	ldr.w	r6, [r7, r3, lsl #2]
    6c66:	f426 3640 	bic.w	r6, r6, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    6c6a:	f847 6023 	str.w	r6, [r7, r3, lsl #2]
			check_pins &= ~bit;
    6c6e:	ea24 0402 	bic.w	r4, r4, r2
		++pin;
    6c72:	3501      	adds	r5, #1
		bit <<= 1;
    6c74:	0052      	lsls	r2, r2, #1
	while (check_pins) {
    6c76:	b1dc      	cbz	r4, 6cb0 <check_level_trigger_pins+0x84>
		if (check_pins & bit) {
    6c78:	4222      	tst	r2, r4
    6c7a:	d0fa      	beq.n	6c72 <check_level_trigger_pins+0x46>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    6c7c:	7a0e      	ldrb	r6, [r1, #8]
    6c7e:	f005 031f 	and.w	r3, r5, #31
    6c82:	ea43 1346 	orr.w	r3, r3, r6, lsl #5
			if (!(level_pins & bit)) {
    6c86:	ea12 0f0c 	tst.w	r2, ip
    6c8a:	d1e4      	bne.n	6c56 <check_level_trigger_pins+0x2a>
    *p_pin = pin_number & 0x1F;
    6c8c:	f003 061f 	and.w	r6, r3, #31
    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
    6c90:	f506 76e0 	add.w	r6, r6, #448	; 0x1c0
    6c94:	f04f 47a0 	mov.w	r7, #1342177280	; 0x50000000
    6c98:	f857 6026 	ldr.w	r6, [r7, r6, lsl #2]
                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
    6c9c:	f3c6 4601 	ubfx	r6, r6, #16, #2
				if (high) {
    6ca0:	2e02      	cmp	r6, #2
    6ca2:	d1d8      	bne.n	6c56 <check_level_trigger_pins+0x2a>
					*sense_levels |= bit;
    6ca4:	f8de 6000 	ldr.w	r6, [lr]
    6ca8:	4316      	orrs	r6, r2
    6caa:	f8ce 6000 	str.w	r6, [lr]
    6cae:	e7d2      	b.n	6c56 <check_level_trigger_pins+0x2a>
}
    6cb0:	bdf0      	pop	{r4, r5, r6, r7, pc}

00006cb2 <gpiote_pin_int_cfg>:
{
    6cb2:	b570      	push	{r4, r5, r6, lr}
    6cb4:	460c      	mov	r4, r1
	return port->data;
    6cb6:	6906      	ldr	r6, [r0, #16]
	return port->config;
    6cb8:	6843      	ldr	r3, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
    6cba:	7a1b      	ldrb	r3, [r3, #8]
    6cbc:	f001 051f 	and.w	r5, r1, #31
    6cc0:	ea45 1543 	orr.w	r5, r5, r3, lsl #5
	gpiote_pin_cleanup(abs_pin);
    6cc4:	4628      	mov	r0, r5
    6cc6:	f7fc fc7b 	bl	35c0 <gpiote_pin_cleanup>
    *p_pin = pin_number & 0x1F;
    6cca:	f005 021f 	and.w	r2, r5, #31
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    6cce:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    6cd2:	f502 70e0 	add.w	r0, r2, #448	; 0x1c0
    6cd6:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
    6cda:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    6cde:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
	if (data->pin_int_en & BIT(pin)) {
    6ce2:	68f3      	ldr	r3, [r6, #12]
    6ce4:	40e3      	lsrs	r3, r4
    6ce6:	f013 0f01 	tst.w	r3, #1
    6cea:	d02f      	beq.n	6d4c <gpiote_pin_int_cfg+0x9a>
		if (data->trig_edge & BIT(pin)) {
    6cec:	6973      	ldr	r3, [r6, #20]
    6cee:	40e3      	lsrs	r3, r4
    6cf0:	f013 0f01 	tst.w	r3, #1
    6cf4:	d013      	beq.n	6d1e <gpiote_pin_int_cfg+0x6c>
				if (data->double_edge & BIT(pin)) {
    6cf6:	69b3      	ldr	r3, [r6, #24]
    6cf8:	40e3      	lsrs	r3, r4
    6cfa:	f013 0f01 	tst.w	r3, #1
    6cfe:	d107      	bne.n	6d10 <gpiote_pin_int_cfg+0x5e>
				} else if ((data->int_active_level & BIT(pin)) != 0U) {
    6d00:	6931      	ldr	r1, [r6, #16]
    6d02:	fa21 f404 	lsr.w	r4, r1, r4
    6d06:	f014 0f01 	tst.w	r4, #1
    6d0a:	d006      	beq.n	6d1a <gpiote_pin_int_cfg+0x68>
					pol = NRF_GPIOTE_POLARITY_LOTOHI;
    6d0c:	2101      	movs	r1, #1
    6d0e:	e000      	b.n	6d12 <gpiote_pin_int_cfg+0x60>
					pol = NRF_GPIOTE_POLARITY_TOGGLE;
    6d10:	2103      	movs	r1, #3
				res = gpiote_channel_alloc(abs_pin, pol);
    6d12:	4628      	mov	r0, r5
    6d14:	f7fc fc80 	bl	3618 <gpiote_channel_alloc>
    6d18:	e019      	b.n	6d4e <gpiote_pin_int_cfg+0x9c>
					pol = NRF_GPIOTE_POLARITY_HITOLO;
    6d1a:	2102      	movs	r1, #2
    6d1c:	e7f9      	b.n	6d12 <gpiote_pin_int_cfg+0x60>
	if ((BIT(pin) & data->int_active_level) != 0U) {
    6d1e:	6931      	ldr	r1, [r6, #16]
    6d20:	fa21 f404 	lsr.w	r4, r1, r4
    6d24:	f014 0f01 	tst.w	r4, #1
    6d28:	d10e      	bne.n	6d48 <gpiote_pin_int_cfg+0x96>
	return NRF_GPIO_PIN_SENSE_LOW;
    6d2a:	2003      	movs	r0, #3
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    6d2c:	f04f 41a0 	mov.w	r1, #1342177280	; 0x50000000
    6d30:	f502 72e0 	add.w	r2, r2, #448	; 0x1c0
    6d34:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
    6d38:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    6d3c:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    6d40:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	int res = 0;
    6d44:	2000      	movs	r0, #0
}
    6d46:	e002      	b.n	6d4e <gpiote_pin_int_cfg+0x9c>
		return NRF_GPIO_PIN_SENSE_HIGH;
    6d48:	2002      	movs	r0, #2
    6d4a:	e7ef      	b.n	6d2c <gpiote_pin_int_cfg+0x7a>
	int res = 0;
    6d4c:	2000      	movs	r0, #0
}
    6d4e:	bd70      	pop	{r4, r5, r6, pc}

00006d50 <gpio_nrfx_pin_interrupt_configure>:
{
    6d50:	b570      	push	{r4, r5, r6, lr}
	return port->data;
    6d52:	6904      	ldr	r4, [r0, #16]
	return port->config;
    6d54:	6845      	ldr	r5, [r0, #4]
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    6d56:	7a2e      	ldrb	r6, [r5, #8]
    6d58:	f001 051f 	and.w	r5, r1, #31
    6d5c:	ea45 1546 	orr.w	r5, r5, r6, lsl #5
	if (!IS_ENABLED(CONFIG_GPIO_NRF_INT_EDGE_USING_SENSE) &&
    6d60:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    6d64:	d025      	beq.n	6db2 <gpio_nrfx_pin_interrupt_configure+0x62>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    6d66:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    6d6a:	d030      	beq.n	6dce <gpio_nrfx_pin_interrupt_configure+0x7e>
    6d6c:	68e5      	ldr	r5, [r4, #12]
    6d6e:	2601      	movs	r6, #1
    6d70:	408e      	lsls	r6, r1
    6d72:	4335      	orrs	r5, r6
    6d74:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    6d76:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    6d7a:	d02e      	beq.n	6dda <gpio_nrfx_pin_interrupt_configure+0x8a>
    6d7c:	6962      	ldr	r2, [r4, #20]
    6d7e:	2501      	movs	r5, #1
    6d80:	408d      	lsls	r5, r1
    6d82:	ea22 0205 	bic.w	r2, r2, r5
    6d86:	6162      	str	r2, [r4, #20]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    6d88:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    6d8c:	d02a      	beq.n	6de4 <gpio_nrfx_pin_interrupt_configure+0x94>
    6d8e:	69a2      	ldr	r2, [r4, #24]
    6d90:	2501      	movs	r5, #1
    6d92:	408d      	lsls	r5, r1
    6d94:	ea22 0205 	bic.w	r2, r2, r5
    6d98:	61a2      	str	r2, [r4, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    6d9a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    6d9e:	d026      	beq.n	6dee <gpio_nrfx_pin_interrupt_configure+0x9e>
    6da0:	6923      	ldr	r3, [r4, #16]
    6da2:	2201      	movs	r2, #1
    6da4:	408a      	lsls	r2, r1
    6da6:	ea23 0302 	bic.w	r3, r3, r2
    6daa:	6123      	str	r3, [r4, #16]
	return gpiote_pin_int_cfg(port, pin);
    6dac:	f7ff ff81 	bl	6cb2 <gpiote_pin_int_cfg>
}
    6db0:	bd70      	pop	{r4, r5, r6, pc}
    *p_pin = pin_number & 0x1F;
    6db2:	f005 051f 	and.w	r5, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    6db6:	f505 75e0 	add.w	r5, r5, #448	; 0x1c0
    6dba:	f04f 46a0 	mov.w	r6, #1342177280	; 0x50000000
    6dbe:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
	    (mode == GPIO_INT_MODE_EDGE) &&
    6dc2:	f015 0f01 	tst.w	r5, #1
    6dc6:	d0ce      	beq.n	6d66 <gpio_nrfx_pin_interrupt_configure+0x16>
		return -ENOTSUP;
    6dc8:	f06f 0085 	mvn.w	r0, #133	; 0x85
    6dcc:	e7f0      	b.n	6db0 <gpio_nrfx_pin_interrupt_configure+0x60>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    6dce:	68e5      	ldr	r5, [r4, #12]
    6dd0:	2601      	movs	r6, #1
    6dd2:	408e      	lsls	r6, r1
    6dd4:	ea25 0506 	bic.w	r5, r5, r6
    6dd8:	e7cc      	b.n	6d74 <gpio_nrfx_pin_interrupt_configure+0x24>
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    6dda:	6962      	ldr	r2, [r4, #20]
    6ddc:	2501      	movs	r5, #1
    6dde:	408d      	lsls	r5, r1
    6de0:	432a      	orrs	r2, r5
    6de2:	e7d0      	b.n	6d86 <gpio_nrfx_pin_interrupt_configure+0x36>
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    6de4:	69a2      	ldr	r2, [r4, #24]
    6de6:	2501      	movs	r5, #1
    6de8:	408d      	lsls	r5, r1
    6dea:	432a      	orrs	r2, r5
    6dec:	e7d4      	b.n	6d98 <gpio_nrfx_pin_interrupt_configure+0x48>
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    6dee:	6923      	ldr	r3, [r4, #16]
    6df0:	2201      	movs	r2, #1
    6df2:	408a      	lsls	r2, r1
    6df4:	4313      	orrs	r3, r2
    6df6:	e7d8      	b.n	6daa <gpio_nrfx_pin_interrupt_configure+0x5a>

00006df8 <endtx_isr>:
	return dev->config;
    6df8:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    6dfa:	681b      	ldr	r3, [r3, #0]
	__asm__ volatile(
    6dfc:	f04f 0120 	mov.w	r1, #32
    6e00:	f3ef 8211 	mrs	r2, BASEPRI
    6e04:	f381 8811 	msr	BASEPRI, r1
    6e08:	f3bf 8f6f 	isb	sy
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    6e0c:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
    6e10:	b131      	cbz	r1, 6e20 <endtx_isr+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    6e12:	2100      	movs	r1, #0
    6e14:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
    6e18:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    6e1c:	2101      	movs	r1, #1
    6e1e:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
    6e20:	f382 8811 	msr	BASEPRI, r2
    6e24:	f3bf 8f6f 	isb	sy
}
    6e28:	4770      	bx	lr

00006e2a <uarte_nrfx_isr_int>:
{
    6e2a:	b538      	push	{r3, r4, r5, lr}
    6e2c:	4604      	mov	r4, r0
	return dev->config;
    6e2e:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    6e30:	681d      	ldr	r5, [r3, #0]
    return p_reg->INTENSET & mask;
    6e32:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
    6e36:	f413 7f80 	tst.w	r3, #256	; 0x100
    6e3a:	d002      	beq.n	6e42 <uarte_nrfx_isr_int+0x18>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    6e3c:	f8d5 3120 	ldr.w	r3, [r5, #288]	; 0x120
    6e40:	b9db      	cbnz	r3, 6e7a <uarte_nrfx_isr_int+0x50>
	return dev->config;
    6e42:	6863      	ldr	r3, [r4, #4]
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
    6e44:	685b      	ldr	r3, [r3, #4]
    6e46:	f013 0f10 	tst.w	r3, #16
    6e4a:	d015      	beq.n	6e78 <uarte_nrfx_isr_int+0x4e>
	__asm__ volatile(
    6e4c:	f04f 0220 	mov.w	r2, #32
    6e50:	f3ef 8311 	mrs	r3, BASEPRI
    6e54:	f382 8811 	msr	BASEPRI, r2
    6e58:	f3bf 8f6f 	isb	sy
    6e5c:	f8d5 2158 	ldr.w	r2, [r5, #344]	; 0x158
		if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED)) {
    6e60:	b112      	cbz	r2, 6e68 <uarte_nrfx_isr_int+0x3e>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    6e62:	2200      	movs	r2, #0
    6e64:	f8c5 2500 	str.w	r2, [r5, #1280]	; 0x500
    p_reg->INTENCLR = mask;
    6e68:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
    6e6c:	f8c5 2308 	str.w	r2, [r5, #776]	; 0x308
	__asm__ volatile(
    6e70:	f383 8811 	msr	BASEPRI, r3
    6e74:	f3bf 8f6f 	isb	sy
}
    6e78:	bd38      	pop	{r3, r4, r5, pc}
		endtx_isr(dev);
    6e7a:	f7ff ffbd 	bl	6df8 <endtx_isr>
    6e7e:	e7e0      	b.n	6e42 <uarte_nrfx_isr_int+0x18>

00006e80 <uarte_nrfx_configure>:
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
    6e80:	794b      	ldrb	r3, [r1, #5]
    6e82:	2b01      	cmp	r3, #1
    6e84:	d142      	bne.n	6f0c <uarte_nrfx_configure+0x8c>
{
    6e86:	b530      	push	{r4, r5, lr}
    6e88:	b083      	sub	sp, #12
    6e8a:	4605      	mov	r5, r0
    6e8c:	460c      	mov	r4, r1
	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    6e8e:	798b      	ldrb	r3, [r1, #6]
    6e90:	2b03      	cmp	r3, #3
    6e92:	d13f      	bne.n	6f14 <uarte_nrfx_configure+0x94>
	switch (cfg->flow_ctrl) {
    6e94:	79cb      	ldrb	r3, [r1, #7]
    6e96:	b133      	cbz	r3, 6ea6 <uarte_nrfx_configure+0x26>
    6e98:	2b01      	cmp	r3, #1
    6e9a:	d00e      	beq.n	6eba <uarte_nrfx_configure+0x3a>
    6e9c:	f06f 0385 	mvn.w	r3, #133	; 0x85
}
    6ea0:	4618      	mov	r0, r3
    6ea2:	b003      	add	sp, #12
    6ea4:	bd30      	pop	{r4, r5, pc}
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
    6ea6:	2300      	movs	r3, #0
    6ea8:	f88d 3004 	strb.w	r3, [sp, #4]
	switch (cfg->parity) {
    6eac:	7923      	ldrb	r3, [r4, #4]
    6eae:	b183      	cbz	r3, 6ed2 <uarte_nrfx_configure+0x52>
    6eb0:	2b02      	cmp	r3, #2
    6eb2:	d027      	beq.n	6f04 <uarte_nrfx_configure+0x84>
    6eb4:	f06f 0385 	mvn.w	r3, #133	; 0x85
    6eb8:	e7f2      	b.n	6ea0 <uarte_nrfx_configure+0x20>
	return dev->config;
    6eba:	6843      	ldr	r3, [r0, #4]
		if (IS_HWFC_PINS_USED(get_dev_config(dev)->flags)) {
    6ebc:	685b      	ldr	r3, [r3, #4]
    6ebe:	f003 0201 	and.w	r2, r3, #1
    6ec2:	f003 0302 	and.w	r3, r3, #2
    6ec6:	4313      	orrs	r3, r2
    6ec8:	d027      	beq.n	6f1a <uarte_nrfx_configure+0x9a>
			uarte_cfg.hwfc = NRF_UARTE_HWFC_ENABLED;
    6eca:	2301      	movs	r3, #1
    6ecc:	f88d 3004 	strb.w	r3, [sp, #4]
		break;
    6ed0:	e7ec      	b.n	6eac <uarte_nrfx_configure+0x2c>
		uarte_cfg.parity = NRF_UARTE_PARITY_EXCLUDED;
    6ed2:	2300      	movs	r3, #0
    6ed4:	f88d 3005 	strb.w	r3, [sp, #5]
	if (baudrate_set(dev, cfg->baudrate) != 0) {
    6ed8:	6821      	ldr	r1, [r4, #0]
    6eda:	4628      	mov	r0, r5
    6edc:	f7fc fbfe 	bl	36dc <baudrate_set>
    6ee0:	4603      	mov	r3, r0
    6ee2:	b9e8      	cbnz	r0, 6f20 <uarte_nrfx_configure+0xa0>
	return dev->config;
    6ee4:	686a      	ldr	r2, [r5, #4]
	return config->uarte_regs;
    6ee6:	6811      	ldr	r1, [r2, #0]
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    6ee8:	f89d 2005 	ldrb.w	r2, [sp, #5]
                    | (uint32_t)p_cfg->hwfc;
    6eec:	f89d 0004 	ldrb.w	r0, [sp, #4]
    6ef0:	4302      	orrs	r2, r0
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    6ef2:	f8c1 256c 	str.w	r2, [r1, #1388]	; 0x56c
	return dev->data;
    6ef6:	692a      	ldr	r2, [r5, #16]
	get_dev_data(dev)->uart_config = *cfg;
    6ef8:	3204      	adds	r2, #4
    6efa:	e894 0003 	ldmia.w	r4, {r0, r1}
    6efe:	e882 0003 	stmia.w	r2, {r0, r1}
	return 0;
    6f02:	e7cd      	b.n	6ea0 <uarte_nrfx_configure+0x20>
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    6f04:	230e      	movs	r3, #14
    6f06:	f88d 3005 	strb.w	r3, [sp, #5]
		break;
    6f0a:	e7e5      	b.n	6ed8 <uarte_nrfx_configure+0x58>
		return -ENOTSUP;
    6f0c:	f06f 0385 	mvn.w	r3, #133	; 0x85
}
    6f10:	4618      	mov	r0, r3
    6f12:	4770      	bx	lr
		return -ENOTSUP;
    6f14:	f06f 0385 	mvn.w	r3, #133	; 0x85
    6f18:	e7c2      	b.n	6ea0 <uarte_nrfx_configure+0x20>
			return -ENOTSUP;
    6f1a:	f06f 0385 	mvn.w	r3, #133	; 0x85
    6f1e:	e7bf      	b.n	6ea0 <uarte_nrfx_configure+0x20>
		return -ENOTSUP;
    6f20:	f06f 0385 	mvn.w	r3, #133	; 0x85
    6f24:	e7bc      	b.n	6ea0 <uarte_nrfx_configure+0x20>

00006f26 <uarte_nrfx_config_get>:
{
    6f26:	460b      	mov	r3, r1
	return dev->data;
    6f28:	6902      	ldr	r2, [r0, #16]
	*cfg = get_dev_data(dev)->uart_config;
    6f2a:	6891      	ldr	r1, [r2, #8]
    6f2c:	6850      	ldr	r0, [r2, #4]
    6f2e:	e883 0003 	stmia.w	r3, {r0, r1}
}
    6f32:	2000      	movs	r0, #0
    6f34:	4770      	bx	lr

00006f36 <uarte_nrfx_err_check>:
	return dev->config;
    6f36:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    6f38:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
    6f3a:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
    6f3e:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
    6f42:	4770      	bx	lr

00006f44 <is_tx_ready>:
	return dev->config;
    6f44:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    6f46:	681a      	ldr	r2, [r3, #0]
	bool ppi_endtx = get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX;
    6f48:	685b      	ldr	r3, [r3, #4]
    6f4a:	f003 0308 	and.w	r3, r3, #8
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    6f4e:	f8d2 1158 	ldr.w	r1, [r2, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
    6f52:	b929      	cbnz	r1, 6f60 <is_tx_ready+0x1c>
    6f54:	b933      	cbnz	r3, 6f64 <is_tx_ready+0x20>
    6f56:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
    6f5a:	b92b      	cbnz	r3, 6f68 <is_tx_ready+0x24>
    6f5c:	2000      	movs	r0, #0
    6f5e:	4770      	bx	lr
    6f60:	2001      	movs	r0, #1
    6f62:	4770      	bx	lr
    6f64:	2000      	movs	r0, #0
    6f66:	4770      	bx	lr
    6f68:	2001      	movs	r0, #1
}
    6f6a:	4770      	bx	lr

00006f6c <uarte_enable>:
	return dev->config;
    6f6c:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    6f6e:	681b      	ldr	r3, [r3, #0]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    6f70:	2208      	movs	r2, #8
    6f72:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
}
    6f76:	4770      	bx	lr

00006f78 <tx_start>:
{
    6f78:	b510      	push	{r4, lr}
	return dev->config;
    6f7a:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    6f7c:	681c      	ldr	r4, [r3, #0]

NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    6f7e:	f8c4 1544 	str.w	r1, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    6f82:	f8c4 2548 	str.w	r2, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    6f86:	2300      	movs	r3, #0
    6f88:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
    6f8c:	f8d4 2120 	ldr.w	r2, [r4, #288]	; 0x120
    6f90:	f8c4 3158 	str.w	r3, [r4, #344]	; 0x158
    6f94:	f8d4 3158 	ldr.w	r3, [r4, #344]	; 0x158
	return dev->config;
    6f98:	6843      	ldr	r3, [r0, #4]
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
    6f9a:	685b      	ldr	r3, [r3, #4]
    6f9c:	f013 0f10 	tst.w	r3, #16
    6fa0:	d102      	bne.n	6fa8 <tx_start+0x30>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    6fa2:	2301      	movs	r3, #1
    6fa4:	60a3      	str	r3, [r4, #8]
}
    6fa6:	bd10      	pop	{r4, pc}
		uarte_enable(dev, UARTE_LOW_POWER_TX);
    6fa8:	2101      	movs	r1, #1
    6faa:	f7ff ffdf 	bl	6f6c <uarte_enable>
    p_reg->INTENSET = mask;
    6fae:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    6fb2:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
}
    6fb6:	e7f4      	b.n	6fa2 <tx_start+0x2a>

00006fb8 <uarte_nrfx_poll_in>:
{
    6fb8:	b410      	push	{r4}
	return dev->data;
    6fba:	6904      	ldr	r4, [r0, #16]
	return dev->config;
    6fbc:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    6fbe:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    6fc0:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
    6fc4:	b152      	cbz	r2, 6fdc <uarte_nrfx_poll_in+0x24>
	*c = data->rx_data;
    6fc6:	7c62      	ldrb	r2, [r4, #17]
    6fc8:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    6fca:	2000      	movs	r0, #0
    6fcc:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    6fd0:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    6fd4:	2201      	movs	r2, #1
    6fd6:	601a      	str	r2, [r3, #0]
}
    6fd8:	bc10      	pop	{r4}
    6fda:	4770      	bx	lr
		return -1;
    6fdc:	f04f 30ff 	mov.w	r0, #4294967295
    6fe0:	e7fa      	b.n	6fd8 <uarte_nrfx_poll_in+0x20>

00006fe2 <wait_tx_ready>:
{
    6fe2:	b570      	push	{r4, r5, r6, lr}
    6fe4:	4606      	mov	r6, r0
    6fe6:	e014      	b.n	7012 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x12>
		if (res) {
    6fe8:	b17d      	cbz	r5, 700a <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0xa>
	__asm__ volatile(
    6fea:	f04f 0320 	mov.w	r3, #32
    6fee:	f3ef 8411 	mrs	r4, BASEPRI
    6ff2:	f383 8811 	msr	BASEPRI, r3
    6ff6:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
    6ffa:	4630      	mov	r0, r6
    6ffc:	f7ff ffa2 	bl	6f44 <is_tx_ready>
    7000:	b9a0      	cbnz	r0, 702c <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x2c>
	__asm__ volatile(
    7002:	f384 8811 	msr	BASEPRI, r4
    7006:	f3bf 8f6f 	isb	sy
	return z_impl_k_sleep(timeout);
    700a:	2021      	movs	r0, #33	; 0x21
    700c:	2100      	movs	r1, #0
    700e:	f7fe facd 	bl	55ac <z_impl_k_sleep>
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
    7012:	2464      	movs	r4, #100	; 0x64
    7014:	4630      	mov	r0, r6
    7016:	f7ff ff95 	bl	6f44 <is_tx_ready>
    701a:	4605      	mov	r5, r0
    701c:	2800      	cmp	r0, #0
    701e:	d1e3      	bne.n	6fe8 <wait_tx_ready+0x6>
    7020:	2001      	movs	r0, #1
    7022:	f000 f8a3 	bl	716c <nrfx_busy_wait>
    7026:	3c01      	subs	r4, #1
    7028:	d1f4      	bne.n	7014 <CONFIG_PM_PARTITION_SIZE_B0_IMAGE+0x14>
    702a:	e7dd      	b.n	6fe8 <wait_tx_ready+0x6>
}
    702c:	4620      	mov	r0, r4
    702e:	bd70      	pop	{r4, r5, r6, pc}

00007030 <uarte_instance_init>:
{
    7030:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    7034:	4606      	mov	r6, r0
    7036:	460c      	mov	r4, r1
	return dev->config;
    7038:	6843      	ldr	r3, [r0, #4]
	return config->uarte_regs;
    703a:	681d      	ldr	r5, [r3, #0]
	return dev->data;
    703c:	6907      	ldr	r7, [r0, #16]
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    703e:	2300      	movs	r3, #0
    7040:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
	data->dev = dev;
    7044:	6038      	str	r0, [r7, #0]
	nrf_gpio_pin_write(config->pseltxd, 1);
    7046:	680b      	ldr	r3, [r1, #0]
    *p_pin = pin_number & 0x1F;
    7048:	f003 021f 	and.w	r2, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    704c:	2301      	movs	r3, #1
    704e:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    7050:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    7054:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
	nrf_gpio_cfg_output(config->pseltxd);
    7058:	680b      	ldr	r3, [r1, #0]
    *p_pin = pin_number & 0x1F;
    705a:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    705e:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    7062:	2103      	movs	r1, #3
    7064:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	if (config->pselrxd !=  NRF_UARTE_PSEL_DISCONNECTED) {
    7068:	6863      	ldr	r3, [r4, #4]
    706a:	f1b3 3fff 	cmp.w	r3, #4294967295
    706e:	d006      	beq.n	707e <uarte_instance_init+0x4e>
    *p_pin = pin_number & 0x1F;
    7070:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    7074:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    7078:	210c      	movs	r1, #12
    707a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	nrf_uarte_txrx_pins_set(uarte, config->pseltxd, config->pselrxd);
    707e:	6822      	ldr	r2, [r4, #0]
    7080:	6863      	ldr	r3, [r4, #4]
    p_reg->PSEL.TXD = pseltxd;
    7082:	f8c5 250c 	str.w	r2, [r5, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    7086:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
	if (config->pselcts != NRF_UARTE_PSEL_DISCONNECTED) {
    708a:	68a3      	ldr	r3, [r4, #8]
    708c:	f1b3 3fff 	cmp.w	r3, #4294967295
    7090:	d008      	beq.n	70a4 <uarte_instance_init+0x74>
    *p_pin = pin_number & 0x1F;
    7092:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    7096:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    709a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    709e:	210c      	movs	r1, #12
    70a0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	if (config->pselrts != NRF_UARTE_PSEL_DISCONNECTED) {
    70a4:	68e3      	ldr	r3, [r4, #12]
    70a6:	f1b3 3fff 	cmp.w	r3, #4294967295
    70aa:	d010      	beq.n	70ce <uarte_instance_init+0x9e>
    *p_pin = pin_number & 0x1F;
    70ac:	f003 031f 	and.w	r3, r3, #31
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    70b0:	2201      	movs	r2, #1
    70b2:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->OUTSET = set_mask;
    70b6:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
    70ba:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
		nrf_gpio_cfg_output(config->pselrts);
    70be:	68e3      	ldr	r3, [r4, #12]
    *p_pin = pin_number & 0x1F;
    70c0:	f003 031f 	and.w	r3, r3, #31
    reg->PIN_CNF[pin_number] = cnf;
    70c4:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    70c8:	2103      	movs	r1, #3
    70ca:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	nrf_uarte_hwfc_pins_set(uarte, config->pselrts, config->pselcts);
    70ce:	68e2      	ldr	r2, [r4, #12]
    70d0:	68a3      	ldr	r3, [r4, #8]
    p_reg->PSEL.RTS = pselrts;
    70d2:	f8c5 2508 	str.w	r2, [r5, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    70d6:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
	return dev->data;
    70da:	6931      	ldr	r1, [r6, #16]
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    70dc:	3104      	adds	r1, #4
    70de:	4630      	mov	r0, r6
    70e0:	f7ff fece 	bl	6e80 <uarte_nrfx_configure>
	if (err) {
    70e4:	4680      	mov	r8, r0
    70e6:	bb98      	cbnz	r0, 7150 <uarte_instance_init+0x120>
	return dev->config;
    70e8:	6873      	ldr	r3, [r6, #4]
	    get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX) {
    70ea:	685b      	ldr	r3, [r3, #4]
	if (IS_ENABLED(CONFIG_UART_ENHANCED_POLL_OUT) &&
    70ec:	f013 0f08 	tst.w	r3, #8
    70f0:	d131      	bne.n	7156 <uarte_instance_init+0x126>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    70f2:	2308      	movs	r3, #8
    70f4:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
		if (config->pselrxd != NRF_UARTE_PSEL_DISCONNECTED) {
    70f8:	6863      	ldr	r3, [r4, #4]
    70fa:	f1b3 3fff 	cmp.w	r3, #4294967295
    70fe:	d00c      	beq.n	711a <uarte_instance_init+0xea>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    7100:	2300      	movs	r3, #0
    7102:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
    7106:	f8d5 3110 	ldr.w	r3, [r5, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    710a:	f107 0311 	add.w	r3, r7, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    710e:	f8c5 3534 	str.w	r3, [r5, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    7112:	2301      	movs	r3, #1
    7114:	f8c5 3538 	str.w	r3, [r5, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    7118:	602b      	str	r3, [r5, #0]
	return dev->config;
    711a:	6873      	ldr	r3, [r6, #4]
	if (!(get_dev_config(dev)->flags & UARTE_CFG_FLAG_PPI_ENDTX)) {
    711c:	685b      	ldr	r3, [r3, #4]
    711e:	f013 0f08 	tst.w	r3, #8
    7122:	d103      	bne.n	712c <uarte_instance_init+0xfc>
    p_reg->INTENSET = mask;
    7124:	f44f 7380 	mov.w	r3, #256	; 0x100
    7128:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
	return dev->config;
    712c:	6873      	ldr	r3, [r6, #4]
	if (get_dev_config(dev)->flags & UARTE_CFG_FLAG_LOW_POWER) {
    712e:	685b      	ldr	r3, [r3, #4]
    7130:	f013 0f10 	tst.w	r3, #16
    7134:	d003      	beq.n	713e <uarte_instance_init+0x10e>
    7136:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    713a:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
    713e:	3710      	adds	r7, #16
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    7140:	f8c5 7544 	str.w	r7, [r5, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    7144:	2300      	movs	r3, #0
    7146:	f8c5 3548 	str.w	r3, [r5, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    714a:	2301      	movs	r3, #1
    714c:	60ab      	str	r3, [r5, #8]
    714e:	60eb      	str	r3, [r5, #12]
}
    7150:	4640      	mov	r0, r8
    7152:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		err = endtx_stoptx_ppi_init(uarte, data);
    7156:	4639      	mov	r1, r7
    7158:	4628      	mov	r0, r5
    715a:	f7fc fb9f 	bl	389c <endtx_stoptx_ppi_init>
		if (err < 0) {
    715e:	2800      	cmp	r0, #0
    7160:	dac7      	bge.n	70f2 <uarte_instance_init+0xc2>
			return err;
    7162:	4680      	mov	r8, r0
    7164:	e7f4      	b.n	7150 <uarte_instance_init+0x120>

00007166 <nrfx_isr>:

#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
    7166:	b508      	push	{r3, lr}
	((nrfx_irq_handler_t)irq_handler)();
    7168:	4780      	blx	r0
}
    716a:	bd08      	pop	{r3, pc}

0000716c <nrfx_busy_wait>:

void nrfx_busy_wait(uint32_t usec_to_wait)
{
    716c:	b508      	push	{r3, lr}
	z_impl_k_busy_wait(usec_to_wait);
    716e:	f000 fb01 	bl	7774 <z_impl_k_busy_wait>
	k_busy_wait(usec_to_wait);
}
    7172:	bd08      	pop	{r3, pc}

00007174 <nrfx_clock_enable>:
{
    7174:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    7176:	2000      	movs	r0, #0
    7178:	f7fb fabc 	bl	26f4 <arch_irq_is_enabled>
    717c:	b100      	cbz	r0, 7180 <nrfx_clock_enable+0xc>
}
    717e:	bd08      	pop	{r3, pc}
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    7180:	f7fb faa8 	bl	26d4 <arch_irq_enable>
    7184:	e7fb      	b.n	717e <nrfx_clock_enable+0xa>

00007186 <is_app_channel>:
    return NRFX_GPIOTE_APP_CHANNELS_MASK & (1UL << index);
    7186:	2301      	movs	r3, #1
    7188:	4083      	lsls	r3, r0
    718a:	f013 0fff 	tst.w	r3, #255	; 0xff
}
    718e:	bf14      	ite	ne
    7190:	2001      	movne	r0, #1
    7192:	2000      	moveq	r0, #0
    7194:	4770      	bx	lr

00007196 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
    7196:	b508      	push	{r3, lr}
  _DoInit();
    7198:	f7fd f808 	bl	41ac <_DoInit>
}
    719c:	bd08      	pop	{r3, pc}

0000719e <rtt_init>:
 */

K_MUTEX_DEFINE(rtt_term_mutex);

static int rtt_init(const struct device *unused)
{
    719e:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	SEGGER_RTT_Init();
    71a0:	f7ff fff9 	bl	7196 <SEGGER_RTT_Init>

	return 0;
}
    71a4:	2000      	movs	r0, #0
    71a6:	bd08      	pop	{r3, pc}

000071a8 <z_device_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    71a8:	b148      	cbz	r0, 71be <z_device_ready+0x16>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    71aa:	68c3      	ldr	r3, [r0, #12]
    71ac:	8818      	ldrh	r0, [r3, #0]
    71ae:	f3c0 0008 	ubfx	r0, r0, #0, #9
    71b2:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    71b6:	bf14      	ite	ne
    71b8:	2000      	movne	r0, #0
    71ba:	2001      	moveq	r0, #1
    71bc:	4770      	bx	lr
		return false;
    71be:	2000      	movs	r0, #0
}
    71c0:	4770      	bx	lr

000071c2 <create_free_list>:
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    71c2:	68c2      	ldr	r2, [r0, #12]
    71c4:	6903      	ldr	r3, [r0, #16]
    71c6:	431a      	orrs	r2, r3
    71c8:	f012 0203 	ands.w	r2, r2, #3
    71cc:	d10d      	bne.n	71ea <create_free_list+0x28>
	slab->free_list = NULL;
    71ce:	2100      	movs	r1, #0
    71d0:	6141      	str	r1, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    71d2:	e005      	b.n	71e0 <create_free_list+0x1e>
		*(char **)p = slab->free_list;
    71d4:	6941      	ldr	r1, [r0, #20]
    71d6:	6019      	str	r1, [r3, #0]
		slab->free_list = p;
    71d8:	6143      	str	r3, [r0, #20]
		p += slab->block_size;
    71da:	68c1      	ldr	r1, [r0, #12]
    71dc:	440b      	add	r3, r1
	for (j = 0U; j < slab->num_blocks; j++) {
    71de:	3201      	adds	r2, #1
    71e0:	6881      	ldr	r1, [r0, #8]
    71e2:	4291      	cmp	r1, r2
    71e4:	d8f6      	bhi.n	71d4 <create_free_list+0x12>
	return 0;
    71e6:	2000      	movs	r0, #0
    71e8:	4770      	bx	lr
		return -EINVAL;
    71ea:	f06f 0015 	mvn.w	r0, #21
}
    71ee:	4770      	bx	lr

000071f0 <k_mem_slab_init>:
{
    71f0:	b510      	push	{r4, lr}
    71f2:	4604      	mov	r4, r0
	slab->num_blocks = num_blocks;
    71f4:	6083      	str	r3, [r0, #8]
	slab->block_size = block_size;
    71f6:	60c2      	str	r2, [r0, #12]
	slab->buffer = buffer;
    71f8:	6101      	str	r1, [r0, #16]
	slab->num_used = 0U;
    71fa:	2300      	movs	r3, #0
    71fc:	6183      	str	r3, [r0, #24]
	rc = create_free_list(slab);
    71fe:	f7ff ffe0 	bl	71c2 <create_free_list>
	if (rc < 0) {
    7202:	2800      	cmp	r0, #0
    7204:	db01      	blt.n	720a <k_mem_slab_init+0x1a>
	list->head = (sys_dnode_t *)list;
    7206:	6024      	str	r4, [r4, #0]
	list->tail = (sys_dnode_t *)list;
    7208:	6064      	str	r4, [r4, #4]
}
    720a:	bd10      	pop	{r4, pc}

0000720c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    720c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    720e:	4604      	mov	r4, r0
    7210:	460d      	mov	r5, r1
	__asm__ volatile(
    7212:	f04f 0320 	mov.w	r3, #32
    7216:	f3ef 8611 	mrs	r6, BASEPRI
    721a:	f383 8811 	msr	BASEPRI, r3
    721e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&slab->lock);

	SYS_PORT_TRACING_OBJ_FUNC_ENTER(k_mem_slab, free, slab);
	if (slab->free_list == NULL && IS_ENABLED(CONFIG_MULTITHREADING)) {
    7222:	6943      	ldr	r3, [r0, #20]
    7224:	b163      	cbz	r3, 7240 <k_mem_slab_free+0x34>
			z_ready_thread(pending_thread);
			z_reschedule(&slab->lock, key);
			return;
		}
	}
	**(char ***) mem = slab->free_list;
    7226:	682b      	ldr	r3, [r5, #0]
    7228:	6962      	ldr	r2, [r4, #20]
    722a:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
    722c:	682b      	ldr	r3, [r5, #0]
    722e:	6163      	str	r3, [r4, #20]
	slab->num_used--;
    7230:	69a3      	ldr	r3, [r4, #24]
    7232:	3b01      	subs	r3, #1
    7234:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    7236:	f386 8811 	msr	BASEPRI, r6
    723a:	f3bf 8f6f 	isb	sy

	SYS_PORT_TRACING_OBJ_FUNC_EXIT(k_mem_slab, free, slab);

	k_spin_unlock(&slab->lock, key);
}
    723e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    7240:	f100 0708 	add.w	r7, r0, #8
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    7244:	f000 f9ba 	bl	75bc <z_unpend_first_thread>
		if (pending_thread != NULL) {
    7248:	2800      	cmp	r0, #0
    724a:	d0ec      	beq.n	7226 <k_mem_slab_free+0x1a>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    724c:	682a      	ldr	r2, [r5, #0]
    724e:	2100      	movs	r1, #0
    7250:	f8c0 10ac 	str.w	r1, [r0, #172]	; 0xac
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    7254:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
    7256:	f000 f93a 	bl	74ce <z_ready_thread>
			z_reschedule(&slab->lock, key);
    725a:	4631      	mov	r1, r6
    725c:	4638      	mov	r0, r7
    725e:	f7fd fe75 	bl	4f4c <z_reschedule>
			return;
    7262:	e7ec      	b.n	723e <k_mem_slab_free+0x32>

00007264 <setup_thread_stack>:
{
    7264:	b410      	push	{r4}
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    7266:	3207      	adds	r2, #7
    7268:	f022 0207 	bic.w	r2, r2, #7
    726c:	f102 0320 	add.w	r3, r2, #32

/** @} */

static inline char *Z_KERNEL_STACK_BUFFER(k_thread_stack_t *sym)
{
	return (char *)sym + K_KERNEL_STACK_RESERVED;
    7270:	f101 0420 	add.w	r4, r1, #32
	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
    7274:	f8c0 4098 	str.w	r4, [r0, #152]	; 0x98
	new_thread->stack_info.size = stack_buf_size;
    7278:	f8c0 209c 	str.w	r2, [r0, #156]	; 0x9c
	new_thread->stack_info.delta = delta;
    727c:	2200      	movs	r2, #0
    727e:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
}
    7282:	18c8      	adds	r0, r1, r3
    7284:	bc10      	pop	{r4}
    7286:	4770      	bx	lr

00007288 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    7288:	f3ef 8005 	mrs	r0, IPSR
}
    728c:	3800      	subs	r0, #0
    728e:	bf18      	it	ne
    7290:	2001      	movne	r0, #1
    7292:	4770      	bx	lr

00007294 <k_thread_name_get>:
}
    7294:	3074      	adds	r0, #116	; 0x74
    7296:	4770      	bx	lr

00007298 <z_impl_k_thread_start>:
{
    7298:	b508      	push	{r3, lr}
	z_sched_start(thread);
    729a:	f7fe f819 	bl	52d0 <z_sched_start>
}
    729e:	bd08      	pop	{r3, pc}

000072a0 <z_init_thread_base>:
#endif

void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
    72a0:	b410      	push	{r4}
	/* k_q_node is initialized upon first insertion in a list */
	thread_base->pended_on = NULL;
    72a2:	2400      	movs	r4, #0
    72a4:	6084      	str	r4, [r0, #8]
	thread_base->user_options = (uint8_t)options;
    72a6:	7303      	strb	r3, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    72a8:	7342      	strb	r2, [r0, #13]

	thread_base->prio = priority;
    72aa:	7381      	strb	r1, [r0, #14]

	thread_base->sched_locked = 0U;
    72ac:	73c4      	strb	r4, [r0, #15]
	node->next = NULL;
    72ae:	6184      	str	r4, [r0, #24]
	node->prev = NULL;
    72b0:	61c4      	str	r4, [r0, #28]
#endif

	/* swap_data does not need to be initialized */

	z_init_thread_timeout(thread_base);
}
    72b2:	bc10      	pop	{r4}
    72b4:	4770      	bx	lr

000072b6 <z_impl_k_thread_create>:
{
    72b6:	b5f0      	push	{r4, r5, r6, r7, lr}
    72b8:	b087      	sub	sp, #28
    72ba:	4604      	mov	r4, r0
    72bc:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
    72c0:	2500      	movs	r5, #0
    72c2:	9505      	str	r5, [sp, #20]
    72c4:	9d10      	ldr	r5, [sp, #64]	; 0x40
    72c6:	9504      	str	r5, [sp, #16]
    72c8:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
    72ca:	9503      	str	r5, [sp, #12]
    72cc:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    72ce:	9502      	str	r5, [sp, #8]
    72d0:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    72d2:	9501      	str	r5, [sp, #4]
    72d4:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    72d6:	9500      	str	r5, [sp, #0]
    72d8:	f7fd fa94 	bl	4804 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
    72dc:	f1b7 3fff 	cmp.w	r7, #4294967295
    72e0:	bf08      	it	eq
    72e2:	f1b6 3fff 	cmpeq.w	r6, #4294967295
    72e6:	d102      	bne.n	72ee <z_impl_k_thread_create+0x38>
}
    72e8:	4620      	mov	r0, r4
    72ea:	b007      	add	sp, #28
    72ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		schedule_new_thread(new_thread, delay);
    72ee:	4632      	mov	r2, r6
    72f0:	463b      	mov	r3, r7
    72f2:	4620      	mov	r0, r4
    72f4:	f7fd fa74 	bl	47e0 <schedule_new_thread>
    72f8:	e7f6      	b.n	72e8 <z_impl_k_thread_create+0x32>

000072fa <z_pm_save_idle_exit>:

void z_pm_save_idle_exit(int32_t ticks)
{
    72fa:	b508      	push	{r3, lr}
	/* Some CPU low power states require notification at the ISR
	 * to allow any operations that needs to be done before kernel
	 * switches task or processes nested interrupts.
	 * This can be simply ignored if not required.
	 */
	pm_system_resume();
    72fc:	f7fa fe16 	bl	1f2c <pm_system_resume>
#endif	/* CONFIG_PM */
	sys_clock_idle_exit();
    7300:	f7ff faa0 	bl	6844 <sys_clock_idle_exit>
}
    7304:	bd08      	pop	{r3, pc}

00007306 <idle>:

void idle(void *unused1, void *unused2, void *unused3)
{
    7306:	b508      	push	{r3, lr}
	__asm__ volatile(
    7308:	f04f 0220 	mov.w	r2, #32
    730c:	f3ef 8311 	mrs	r3, BASEPRI
    7310:	f382 8811 	msr	BASEPRI, r2
    7314:	f3bf 8f6f 	isb	sy
		 * higher level construct.
		 */
		(void) arch_irq_lock();

		if (IS_ENABLED(CONFIG_PM)) {
			pm_save_idle();
    7318:	f7fd fb26 	bl	4968 <pm_save_idle>
    731c:	e7f4      	b.n	7308 <idle+0x2>

0000731e <new_prio_for_inheritance>:
	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
    731e:	4288      	cmp	r0, r1
    7320:	da00      	bge.n	7324 <new_prio_for_inheritance+0x6>
    7322:	4601      	mov	r1, r0
	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
    7324:	f111 0f7f 	cmn.w	r1, #127	; 0x7f
    7328:	db01      	blt.n	732e <new_prio_for_inheritance+0x10>
    732a:	4608      	mov	r0, r1
    732c:	4770      	bx	lr
    732e:	f06f 007e 	mvn.w	r0, #126	; 0x7e
}
    7332:	4770      	bx	lr

00007334 <adjust_owner_prio>:
{
    7334:	b508      	push	{r3, lr}
	if (mutex->owner->base.prio != new_prio) {
    7336:	6880      	ldr	r0, [r0, #8]
    7338:	f990 300e 	ldrsb.w	r3, [r0, #14]
    733c:	428b      	cmp	r3, r1
    733e:	d101      	bne.n	7344 <adjust_owner_prio+0x10>
	return false;
    7340:	2000      	movs	r0, #0
}
    7342:	bd08      	pop	{r3, pc}
		return z_set_prio(mutex->owner, new_prio);
    7344:	f7fd ffe2 	bl	530c <z_set_prio>
    7348:	e7fb      	b.n	7342 <adjust_owner_prio+0xe>

0000734a <k_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
    734a:	2300      	movs	r3, #0
    734c:	6003      	str	r3, [r0, #0]
    734e:	6083      	str	r3, [r0, #8]
    7350:	60c3      	str	r3, [r0, #12]
    7352:	6041      	str	r1, [r0, #4]
}
    7354:	4770      	bx	lr

00007356 <k_work_submit_to_queue>:
{
    7356:	b530      	push	{r4, r5, lr}
    7358:	b083      	sub	sp, #12
    735a:	9001      	str	r0, [sp, #4]
    735c:	4608      	mov	r0, r1
    735e:	f04f 0320 	mov.w	r3, #32
    7362:	f3ef 8511 	mrs	r5, BASEPRI
    7366:	f383 8811 	msr	BASEPRI, r3
    736a:	f3bf 8f6f 	isb	sy
	int ret = submit_to_queue_locked(work, &queue);
    736e:	a901      	add	r1, sp, #4
    7370:	f7fd fc24 	bl	4bbc <submit_to_queue_locked>
    7374:	4604      	mov	r4, r0
	__asm__ volatile(
    7376:	f385 8811 	msr	BASEPRI, r5
    737a:	f3bf 8f6f 	isb	sy
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
    737e:	2800      	cmp	r0, #0
    7380:	dc02      	bgt.n	7388 <k_work_submit_to_queue+0x32>
}
    7382:	4620      	mov	r0, r4
    7384:	b003      	add	sp, #12
    7386:	bd30      	pop	{r4, r5, pc}
	return z_impl_k_is_preempt_thread();
    7388:	f7fe f942 	bl	5610 <z_impl_k_is_preempt_thread>
	if ((ret > 0) && (k_is_preempt_thread() != 0)) {
    738c:	2800      	cmp	r0, #0
    738e:	d0f8      	beq.n	7382 <k_work_submit_to_queue+0x2c>
	z_impl_k_yield();
    7390:	f7fe f878 	bl	5484 <z_impl_k_yield>
	return ret;
    7394:	e7f5      	b.n	7382 <k_work_submit_to_queue+0x2c>

00007396 <thread_active_elsewhere>:
}
    7396:	2000      	movs	r0, #0
    7398:	4770      	bx	lr

0000739a <pended_on_thread>:
}
    739a:	6880      	ldr	r0, [r0, #8]
    739c:	4770      	bx	lr

0000739e <z_sched_prio_cmp>:
	int32_t b1 = thread_1->base.prio;
    739e:	f990 300e 	ldrsb.w	r3, [r0, #14]
	int32_t b2 = thread_2->base.prio;
    73a2:	f991 000e 	ldrsb.w	r0, [r1, #14]
	if (b1 != b2) {
    73a6:	4283      	cmp	r3, r0
    73a8:	d001      	beq.n	73ae <z_sched_prio_cmp+0x10>
		return b2 - b1;
    73aa:	1ac0      	subs	r0, r0, r3
    73ac:	4770      	bx	lr
	return 0;
    73ae:	2000      	movs	r0, #0
}
    73b0:	4770      	bx	lr

000073b2 <z_unpend_thread_no_timeout>:
{
    73b2:	b538      	push	{r3, r4, r5, lr}
    73b4:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
    73b6:	2300      	movs	r3, #0
	__asm__ volatile(
    73b8:	f04f 0220 	mov.w	r2, #32
    73bc:	f3ef 8511 	mrs	r5, BASEPRI
    73c0:	f382 8811 	msr	BASEPRI, r2
    73c4:	f3bf 8f6f 	isb	sy
    73c8:	b98b      	cbnz	r3, 73ee <z_unpend_thread_no_timeout+0x3c>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    73ca:	4620      	mov	r0, r4
    73cc:	f7ff ffe5 	bl	739a <pended_on_thread>
    73d0:	4621      	mov	r1, r4
    73d2:	f000 f822 	bl	741a <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    73d6:	7b63      	ldrb	r3, [r4, #13]
    73d8:	f023 0302 	bic.w	r3, r3, #2
    73dc:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    73de:	2300      	movs	r3, #0
    73e0:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
    73e2:	f385 8811 	msr	BASEPRI, r5
    73e6:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    73ea:	2301      	movs	r3, #1
    73ec:	e7ec      	b.n	73c8 <z_unpend_thread_no_timeout+0x16>
}
    73ee:	bd38      	pop	{r3, r4, r5, pc}

000073f0 <z_reschedule_irqlock>:
{
    73f0:	b508      	push	{r3, lr}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    73f2:	4603      	mov	r3, r0
    73f4:	b920      	cbnz	r0, 7400 <z_reschedule_irqlock+0x10>
    73f6:	f3ef 8205 	mrs	r2, IPSR
    73fa:	b942      	cbnz	r2, 740e <z_reschedule_irqlock+0x1e>
    73fc:	2201      	movs	r2, #1
    73fe:	e000      	b.n	7402 <z_reschedule_irqlock+0x12>
    7400:	2200      	movs	r2, #0
	if (resched(key)) {
    7402:	b932      	cbnz	r2, 7412 <z_reschedule_irqlock+0x22>
    7404:	f383 8811 	msr	BASEPRI, r3
    7408:	f3bf 8f6f 	isb	sy
}
    740c:	bd08      	pop	{r3, pc}
	return arch_irq_unlocked(key) && !arch_is_in_isr();
    740e:	2200      	movs	r2, #0
    7410:	e7f7      	b.n	7402 <z_reschedule_irqlock+0x12>
	ret = arch_swap(key);
    7412:	4618      	mov	r0, r3
    7414:	f7fb f906 	bl	2624 <arch_swap>
	return ret;
    7418:	e7f8      	b.n	740c <z_reschedule_irqlock+0x1c>

0000741a <z_priq_dumb_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    741a:	684a      	ldr	r2, [r1, #4]
	sys_dnode_t *const next = node->next;
    741c:	680b      	ldr	r3, [r1, #0]

	prev->next = next;
    741e:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    7420:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    7422:	2300      	movs	r3, #0
    7424:	600b      	str	r3, [r1, #0]
	node->prev = NULL;
    7426:	604b      	str	r3, [r1, #4]
}
    7428:	4770      	bx	lr

0000742a <z_priq_dumb_best>:
{
    742a:	4603      	mov	r3, r0
	return list->head == list;
    742c:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    742e:	4283      	cmp	r3, r0
    7430:	d000      	beq.n	7434 <z_priq_dumb_best+0xa>
}
    7432:	4770      	bx	lr
	struct k_thread *thread = NULL;
    7434:	2000      	movs	r0, #0
	return thread;
    7436:	e7fc      	b.n	7432 <z_priq_dumb_best+0x8>

00007438 <add_to_waitq_locked>:
{
    7438:	b570      	push	{r4, r5, r6, lr}
    743a:	4605      	mov	r5, r0
    743c:	460e      	mov	r6, r1
	unready_thread(thread);
    743e:	f7fd fddf 	bl	5000 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
    7442:	7b6b      	ldrb	r3, [r5, #13]
    7444:	f043 0302 	orr.w	r3, r3, #2
    7448:	736b      	strb	r3, [r5, #13]
	if (wait_q != NULL) {
    744a:	b1b6      	cbz	r6, 747a <add_to_waitq_locked+0x42>
		thread->base.pended_on = wait_q;
    744c:	60ae      	str	r6, [r5, #8]
	return list->head == list;
    744e:	6834      	ldr	r4, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    7450:	42a6      	cmp	r6, r4
    7452:	d019      	beq.n	7488 <add_to_waitq_locked+0x50>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7454:	b164      	cbz	r4, 7470 <add_to_waitq_locked+0x38>
		if (z_sched_prio_cmp(thread, t) > 0) {
    7456:	4621      	mov	r1, r4
    7458:	4628      	mov	r0, r5
    745a:	f7ff ffa0 	bl	739e <z_sched_prio_cmp>
    745e:	2800      	cmp	r0, #0
    7460:	dc0c      	bgt.n	747c <add_to_waitq_locked+0x44>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    7462:	b12c      	cbz	r4, 7470 <add_to_waitq_locked+0x38>
	return (node == list->tail) ? NULL : node->next;
    7464:	6873      	ldr	r3, [r6, #4]
    7466:	429c      	cmp	r4, r3
    7468:	d002      	beq.n	7470 <add_to_waitq_locked+0x38>
    746a:	6824      	ldr	r4, [r4, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    746c:	2c00      	cmp	r4, #0
    746e:	d1f1      	bne.n	7454 <add_to_waitq_locked+0x1c>
	sys_dnode_t *const tail = list->tail;
    7470:	6873      	ldr	r3, [r6, #4]
	node->next = list;
    7472:	602e      	str	r6, [r5, #0]
	node->prev = tail;
    7474:	606b      	str	r3, [r5, #4]
	tail->next = node;
    7476:	601d      	str	r5, [r3, #0]
	list->tail = node;
    7478:	6075      	str	r5, [r6, #4]
}
    747a:	bd70      	pop	{r4, r5, r6, pc}
	sys_dnode_t *const prev = successor->prev;
    747c:	6863      	ldr	r3, [r4, #4]
	node->prev = prev;
    747e:	606b      	str	r3, [r5, #4]
	node->next = successor;
    7480:	602c      	str	r4, [r5, #0]
	prev->next = node;
    7482:	601d      	str	r5, [r3, #0]
	successor->prev = node;
    7484:	6065      	str	r5, [r4, #4]
}
    7486:	e7f8      	b.n	747a <add_to_waitq_locked+0x42>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    7488:	2400      	movs	r4, #0
    748a:	e7e3      	b.n	7454 <add_to_waitq_locked+0x1c>

0000748c <pend>:
{
    748c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7490:	4605      	mov	r5, r0
    7492:	460f      	mov	r7, r1
    7494:	4691      	mov	r9, r2
    7496:	4698      	mov	r8, r3
	LOCKED(&sched_spinlock) {
    7498:	2400      	movs	r4, #0
	__asm__ volatile(
    749a:	f04f 0320 	mov.w	r3, #32
    749e:	f3ef 8611 	mrs	r6, BASEPRI
    74a2:	f383 8811 	msr	BASEPRI, r3
    74a6:	f3bf 8f6f 	isb	sy
    74aa:	b94c      	cbnz	r4, 74c0 <pend+0x34>
		add_to_waitq_locked(thread, wait_q);
    74ac:	4639      	mov	r1, r7
    74ae:	4628      	mov	r0, r5
    74b0:	f7ff ffc2 	bl	7438 <add_to_waitq_locked>
	__asm__ volatile(
    74b4:	f386 8811 	msr	BASEPRI, r6
    74b8:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    74bc:	2401      	movs	r4, #1
    74be:	e7f4      	b.n	74aa <pend+0x1e>
	add_thread_timeout(thread, timeout);
    74c0:	464a      	mov	r2, r9
    74c2:	4643      	mov	r3, r8
    74c4:	4628      	mov	r0, r5
    74c6:	f7fd fcdf 	bl	4e88 <add_thread_timeout>
}
    74ca:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

000074ce <z_ready_thread>:
{
    74ce:	b538      	push	{r3, r4, r5, lr}
    74d0:	4604      	mov	r4, r0
	LOCKED(&sched_spinlock) {
    74d2:	2300      	movs	r3, #0
	__asm__ volatile(
    74d4:	f04f 0220 	mov.w	r2, #32
    74d8:	f3ef 8511 	mrs	r5, BASEPRI
    74dc:	f382 8811 	msr	BASEPRI, r2
    74e0:	f3bf 8f6f 	isb	sy
    74e4:	e007      	b.n	74f6 <z_ready_thread+0x28>
			ready_thread(thread);
    74e6:	4620      	mov	r0, r4
    74e8:	f7fd feb2 	bl	5250 <ready_thread>
	__asm__ volatile(
    74ec:	f385 8811 	msr	BASEPRI, r5
    74f0:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    74f4:	2301      	movs	r3, #1
    74f6:	b92b      	cbnz	r3, 7504 <z_ready_thread+0x36>
		if (!thread_active_elsewhere(thread)) {
    74f8:	4620      	mov	r0, r4
    74fa:	f7ff ff4c 	bl	7396 <thread_active_elsewhere>
    74fe:	2800      	cmp	r0, #0
    7500:	d1f4      	bne.n	74ec <z_ready_thread+0x1e>
    7502:	e7f0      	b.n	74e6 <z_ready_thread+0x18>
}
    7504:	bd38      	pop	{r3, r4, r5, pc}

00007506 <z_thread_timeout>:
{
    7506:	b570      	push	{r4, r5, r6, lr}
    7508:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
    750a:	f1a0 0518 	sub.w	r5, r0, #24
	LOCKED(&sched_spinlock) {
    750e:	2300      	movs	r3, #0
	__asm__ volatile(
    7510:	f04f 0220 	mov.w	r2, #32
    7514:	f3ef 8611 	mrs	r6, BASEPRI
    7518:	f382 8811 	msr	BASEPRI, r2
    751c:	f3bf 8f6f 	isb	sy
    7520:	e019      	b.n	7556 <z_thread_timeout+0x50>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    7522:	4628      	mov	r0, r5
    7524:	f7ff ff39 	bl	739a <pended_on_thread>
    7528:	4629      	mov	r1, r5
    752a:	f7ff ff76 	bl	741a <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    752e:	7b6b      	ldrb	r3, [r5, #13]
    7530:	f023 0302 	bic.w	r3, r3, #2
    7534:	736b      	strb	r3, [r5, #13]
	thread->base.pended_on = NULL;
    7536:	2300      	movs	r3, #0
    7538:	60ab      	str	r3, [r5, #8]
	thread->base.thread_state &= ~_THREAD_PRESTART;
    753a:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
    753e:	f003 03eb 	and.w	r3, r3, #235	; 0xeb
    7542:	f804 3c0b 	strb.w	r3, [r4, #-11]
			ready_thread(thread);
    7546:	4628      	mov	r0, r5
    7548:	f7fd fe82 	bl	5250 <ready_thread>
	__asm__ volatile(
    754c:	f386 8811 	msr	BASEPRI, r6
    7550:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    7554:	2301      	movs	r3, #1
    7556:	b94b      	cbnz	r3, 756c <z_thread_timeout+0x66>
		bool killed = ((thread->base.thread_state & _THREAD_DEAD) ||
    7558:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
		if (!killed) {
    755c:	f013 0f28 	tst.w	r3, #40	; 0x28
    7560:	d1f4      	bne.n	754c <z_thread_timeout+0x46>
			if (thread->base.pended_on != NULL) {
    7562:	f854 3c10 	ldr.w	r3, [r4, #-16]
    7566:	2b00      	cmp	r3, #0
    7568:	d1db      	bne.n	7522 <z_thread_timeout+0x1c>
    756a:	e7e6      	b.n	753a <z_thread_timeout+0x34>
}
    756c:	bd70      	pop	{r4, r5, r6, pc}

0000756e <z_unpend1_no_timeout>:
{
    756e:	b570      	push	{r4, r5, r6, lr}
    7570:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
    7572:	2300      	movs	r3, #0
	__asm__ volatile(
    7574:	f04f 0220 	mov.w	r2, #32
    7578:	f3ef 8511 	mrs	r5, BASEPRI
    757c:	f382 8811 	msr	BASEPRI, r2
    7580:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = NULL;
    7584:	461c      	mov	r4, r3
    7586:	e00f      	b.n	75a8 <z_unpend1_no_timeout+0x3a>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    7588:	f7ff ff07 	bl	739a <pended_on_thread>
    758c:	4621      	mov	r1, r4
    758e:	f7ff ff44 	bl	741a <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    7592:	7b63      	ldrb	r3, [r4, #13]
    7594:	f023 0302 	bic.w	r3, r3, #2
    7598:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    759a:	2300      	movs	r3, #0
    759c:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
    759e:	f385 8811 	msr	BASEPRI, r5
    75a2:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    75a6:	2301      	movs	r3, #1
    75a8:	b933      	cbnz	r3, 75b8 <z_unpend1_no_timeout+0x4a>
		thread = _priq_wait_best(&wait_q->waitq);
    75aa:	4630      	mov	r0, r6
    75ac:	f7ff ff3d 	bl	742a <z_priq_dumb_best>
		if (thread != NULL) {
    75b0:	4604      	mov	r4, r0
    75b2:	2800      	cmp	r0, #0
    75b4:	d1e8      	bne.n	7588 <z_unpend1_no_timeout+0x1a>
    75b6:	e7f2      	b.n	759e <z_unpend1_no_timeout+0x30>
}
    75b8:	4620      	mov	r0, r4
    75ba:	bd70      	pop	{r4, r5, r6, pc}

000075bc <z_unpend_first_thread>:
{
    75bc:	b570      	push	{r4, r5, r6, lr}
    75be:	4606      	mov	r6, r0
	LOCKED(&sched_spinlock) {
    75c0:	2300      	movs	r3, #0
	__asm__ volatile(
    75c2:	f04f 0220 	mov.w	r2, #32
    75c6:	f3ef 8511 	mrs	r5, BASEPRI
    75ca:	f382 8811 	msr	BASEPRI, r2
    75ce:	f3bf 8f6f 	isb	sy
	struct k_thread *thread = NULL;
    75d2:	461c      	mov	r4, r3
    75d4:	e013      	b.n	75fe <z_unpend_first_thread+0x42>
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    75d6:	f7ff fee0 	bl	739a <pended_on_thread>
    75da:	4621      	mov	r1, r4
    75dc:	f7ff ff1d 	bl	741a <z_priq_dumb_remove>
    75e0:	7b63      	ldrb	r3, [r4, #13]
    75e2:	f023 0302 	bic.w	r3, r3, #2
    75e6:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    75e8:	2300      	movs	r3, #0
    75ea:	60a3      	str	r3, [r4, #8]
	return z_abort_timeout(&thread->base.timeout);
    75ec:	f104 0018 	add.w	r0, r4, #24
    75f0:	f000 f85d 	bl	76ae <z_abort_timeout>
	__asm__ volatile(
    75f4:	f385 8811 	msr	BASEPRI, r5
    75f8:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    75fc:	2301      	movs	r3, #1
    75fe:	b933      	cbnz	r3, 760e <z_unpend_first_thread+0x52>
		thread = _priq_wait_best(&wait_q->waitq);
    7600:	4630      	mov	r0, r6
    7602:	f7ff ff12 	bl	742a <z_priq_dumb_best>
		if (thread != NULL) {
    7606:	4604      	mov	r4, r0
    7608:	2800      	cmp	r0, #0
    760a:	d1e4      	bne.n	75d6 <z_unpend_first_thread+0x1a>
    760c:	e7f2      	b.n	75f4 <z_unpend_first_thread+0x38>
}
    760e:	4620      	mov	r0, r4
    7610:	bd70      	pop	{r4, r5, r6, pc}

00007612 <z_sched_wake>:
{
    7612:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    7616:	4606      	mov	r6, r0
    7618:	4688      	mov	r8, r1
    761a:	4617      	mov	r7, r2
	LOCKED(&sched_spinlock) {
    761c:	2300      	movs	r3, #0
	__asm__ volatile(
    761e:	f04f 0220 	mov.w	r2, #32
    7622:	f3ef 8511 	mrs	r5, BASEPRI
    7626:	f382 8811 	msr	BASEPRI, r2
    762a:	f3bf 8f6f 	isb	sy
	bool ret = false;
    762e:	4699      	mov	r9, r3
    7630:	e01b      	b.n	766a <z_sched_wake+0x58>
    7632:	f8c0 80ac 	str.w	r8, [r0, #172]	; 0xac
    7636:	6147      	str	r7, [r0, #20]
	_priq_wait_remove(&pended_on_thread(thread)->waitq, thread);
    7638:	f7ff feaf 	bl	739a <pended_on_thread>
    763c:	4621      	mov	r1, r4
    763e:	f7ff feec 	bl	741a <z_priq_dumb_remove>
    7642:	7b63      	ldrb	r3, [r4, #13]
    7644:	f023 0302 	bic.w	r3, r3, #2
    7648:	7363      	strb	r3, [r4, #13]
	thread->base.pended_on = NULL;
    764a:	2300      	movs	r3, #0
    764c:	60a3      	str	r3, [r4, #8]
    764e:	f104 0018 	add.w	r0, r4, #24
    7652:	f000 f82c 	bl	76ae <z_abort_timeout>
			ready_thread(thread);
    7656:	4620      	mov	r0, r4
    7658:	f7fd fdfa 	bl	5250 <ready_thread>
			ret = true;
    765c:	f04f 0901 	mov.w	r9, #1
	__asm__ volatile(
    7660:	f385 8811 	msr	BASEPRI, r5
    7664:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
    7668:	2301      	movs	r3, #1
    766a:	b933      	cbnz	r3, 767a <z_sched_wake+0x68>
		thread = _priq_wait_best(&wait_q->waitq);
    766c:	4630      	mov	r0, r6
    766e:	f7ff fedc 	bl	742a <z_priq_dumb_best>
		if (thread != NULL) {
    7672:	4604      	mov	r4, r0
    7674:	2800      	cmp	r0, #0
    7676:	d1dc      	bne.n	7632 <z_sched_wake+0x20>
    7678:	e7f2      	b.n	7660 <z_sched_wake+0x4e>
}
    767a:	4648      	mov	r0, r9
    767c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00007680 <remove_timeout>:
{
    7680:	b538      	push	{r3, r4, r5, lr}
    7682:	4604      	mov	r4, r0
	if (next(t) != NULL) {
    7684:	f7fe f832 	bl	56ec <next>
    7688:	b148      	cbz	r0, 769e <remove_timeout+0x1e>
    768a:	4602      	mov	r2, r0
		next(t)->dticks += t->dticks;
    768c:	6920      	ldr	r0, [r4, #16]
    768e:	6965      	ldr	r5, [r4, #20]
    7690:	6913      	ldr	r3, [r2, #16]
    7692:	6951      	ldr	r1, [r2, #20]
    7694:	181b      	adds	r3, r3, r0
    7696:	eb45 0101 	adc.w	r1, r5, r1
    769a:	6113      	str	r3, [r2, #16]
    769c:	6151      	str	r1, [r2, #20]
	sys_dnode_t *const prev = node->prev;
    769e:	6862      	ldr	r2, [r4, #4]
	sys_dnode_t *const next = node->next;
    76a0:	6823      	ldr	r3, [r4, #0]
	prev->next = next;
    76a2:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    76a4:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    76a6:	2300      	movs	r3, #0
    76a8:	6023      	str	r3, [r4, #0]
	node->prev = NULL;
    76aa:	6063      	str	r3, [r4, #4]
}
    76ac:	bd38      	pop	{r3, r4, r5, pc}

000076ae <z_abort_timeout>:
{
    76ae:	b570      	push	{r4, r5, r6, lr}
    76b0:	4604      	mov	r4, r0
	LOCKED(&timeout_lock) {
    76b2:	2300      	movs	r3, #0
	__asm__ volatile(
    76b4:	f04f 0220 	mov.w	r2, #32
    76b8:	f3ef 8611 	mrs	r6, BASEPRI
    76bc:	f382 8811 	msr	BASEPRI, r2
    76c0:	f3bf 8f6f 	isb	sy
	int ret = -EINVAL;
    76c4:	f06f 0015 	mvn.w	r0, #21
    76c8:	e008      	b.n	76dc <z_abort_timeout+0x2e>
			remove_timeout(to);
    76ca:	4620      	mov	r0, r4
    76cc:	f7ff ffd8 	bl	7680 <remove_timeout>
			ret = 0;
    76d0:	4628      	mov	r0, r5
	__asm__ volatile(
    76d2:	f386 8811 	msr	BASEPRI, r6
    76d6:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    76da:	2301      	movs	r3, #1
    76dc:	461d      	mov	r5, r3
    76de:	b91b      	cbnz	r3, 76e8 <z_abort_timeout+0x3a>
	return node->next != NULL;
    76e0:	6823      	ldr	r3, [r4, #0]
		if (sys_dnode_is_linked(&to->node)) {
    76e2:	2b00      	cmp	r3, #0
    76e4:	d1f1      	bne.n	76ca <z_abort_timeout+0x1c>
    76e6:	e7f4      	b.n	76d2 <z_abort_timeout+0x24>
}
    76e8:	bd70      	pop	{r4, r5, r6, pc}

000076ea <z_get_next_timeout_expiry>:
{
    76ea:	b510      	push	{r4, lr}
	LOCKED(&timeout_lock) {
    76ec:	2300      	movs	r3, #0
	__asm__ volatile(
    76ee:	f04f 0220 	mov.w	r2, #32
    76f2:	f3ef 8411 	mrs	r4, BASEPRI
    76f6:	f382 8811 	msr	BASEPRI, r2
    76fa:	f3bf 8f6f 	isb	sy
	int32_t ret = (int32_t) K_TICKS_FOREVER;
    76fe:	f04f 30ff 	mov.w	r0, #4294967295
	LOCKED(&timeout_lock) {
    7702:	b93b      	cbnz	r3, 7714 <z_get_next_timeout_expiry+0x2a>
		ret = next_timeout();
    7704:	f7fe f80a 	bl	571c <next_timeout>
	__asm__ volatile(
    7708:	f384 8811 	msr	BASEPRI, r4
    770c:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    7710:	2301      	movs	r3, #1
    7712:	e7f6      	b.n	7702 <z_get_next_timeout_expiry+0x18>
}
    7714:	bd10      	pop	{r4, pc}

00007716 <z_set_timeout_expiry>:
{
    7716:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    7718:	4606      	mov	r6, r0
    771a:	460f      	mov	r7, r1
	LOCKED(&timeout_lock) {
    771c:	2300      	movs	r3, #0
	__asm__ volatile(
    771e:	f04f 0220 	mov.w	r2, #32
    7722:	f3ef 8511 	mrs	r5, BASEPRI
    7726:	f382 8811 	msr	BASEPRI, r2
    772a:	f3bf 8f6f 	isb	sy
    772e:	e00a      	b.n	7746 <z_set_timeout_expiry+0x30>
			      || (ticks <= next_to);
    7730:	2401      	movs	r4, #1
		bool sooner = (next_to == K_TICKS_FOREVER)
    7732:	f004 0401 	and.w	r4, r4, #1
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
    7736:	2801      	cmp	r0, #1
    7738:	dd00      	ble.n	773c <z_set_timeout_expiry+0x26>
    773a:	b97c      	cbnz	r4, 775c <z_set_timeout_expiry+0x46>
	__asm__ volatile(
    773c:	f385 8811 	msr	BASEPRI, r5
    7740:	f3bf 8f6f 	isb	sy
	LOCKED(&timeout_lock) {
    7744:	2301      	movs	r3, #1
    7746:	461c      	mov	r4, r3
    7748:	b97b      	cbnz	r3, 776a <z_set_timeout_expiry+0x54>
		int next_to = next_timeout();
    774a:	f7fd ffe7 	bl	571c <next_timeout>
			      || (ticks <= next_to);
    774e:	f1b0 3fff 	cmp.w	r0, #4294967295
    7752:	d0ed      	beq.n	7730 <z_set_timeout_expiry+0x1a>
    7754:	42b0      	cmp	r0, r6
    7756:	dbec      	blt.n	7732 <z_set_timeout_expiry+0x1c>
    7758:	2401      	movs	r4, #1
    775a:	e7ea      	b.n	7732 <z_set_timeout_expiry+0x1c>
			sys_clock_set_timeout(MIN(ticks, next_to), is_idle);
    775c:	4639      	mov	r1, r7
    775e:	42b0      	cmp	r0, r6
    7760:	bfa8      	it	ge
    7762:	4630      	movge	r0, r6
    7764:	f7fa ff0c 	bl	2580 <sys_clock_set_timeout>
    7768:	e7e8      	b.n	773c <z_set_timeout_expiry+0x26>
}
    776a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0000776c <sys_clock_tick_get_32>:

uint32_t sys_clock_tick_get_32(void)
{
    776c:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)sys_clock_tick_get();
    776e:	f7fe f907 	bl	5980 <sys_clock_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
    7772:	bd08      	pop	{r3, pc}

00007774 <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    7774:	b900      	cbnz	r0, 7778 <z_impl_k_busy_wait+0x4>
    7776:	4770      	bx	lr
{
    7778:	b508      	push	{r3, lr}
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    777a:	f7fb fe3d 	bl	33f8 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    777e:	bd08      	pop	{r3, pc}

00007780 <k_timer_init>:
	timer->expiry_fn = expiry_fn;
    7780:	6201      	str	r1, [r0, #32]
	timer->stop_fn = stop_fn;
    7782:	6242      	str	r2, [r0, #36]	; 0x24
	timer->status = 0U;
    7784:	2300      	movs	r3, #0
    7786:	6303      	str	r3, [r0, #48]	; 0x30
	sys_dlist_init(&w->waitq);
    7788:	f100 0218 	add.w	r2, r0, #24
	list->head = (sys_dnode_t *)list;
    778c:	6182      	str	r2, [r0, #24]
	list->tail = (sys_dnode_t *)list;
    778e:	61c2      	str	r2, [r0, #28]
	node->next = NULL;
    7790:	6003      	str	r3, [r0, #0]
	node->prev = NULL;
    7792:	6043      	str	r3, [r0, #4]
	timer->user_data = NULL;
    7794:	6343      	str	r3, [r0, #52]	; 0x34
}
    7796:	4770      	bx	lr

00007798 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
    7798:	b510      	push	{r4, lr}
    779a:	4604      	mov	r4, r0
	SYS_PORT_TRACING_OBJ_FUNC(k_timer, stop, timer);

	int inactive = z_abort_timeout(&timer->timeout) != 0;
    779c:	f7ff ff87 	bl	76ae <z_abort_timeout>

	if (inactive) {
    77a0:	b9a0      	cbnz	r0, 77cc <z_impl_k_timer_stop+0x34>
		return;
	}

	if (timer->stop_fn != NULL) {
    77a2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    77a4:	b10b      	cbz	r3, 77aa <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
    77a6:	4620      	mov	r0, r4
    77a8:	4798      	blx	r3
	}

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);
    77aa:	f104 0018 	add.w	r0, r4, #24
    77ae:	f7ff fede 	bl	756e <z_unpend1_no_timeout>

		if (pending_thread != NULL) {
    77b2:	b158      	cbz	r0, 77cc <z_impl_k_timer_stop+0x34>
			z_ready_thread(pending_thread);
    77b4:	f7ff fe8b 	bl	74ce <z_ready_thread>
	__asm__ volatile(
    77b8:	f04f 0320 	mov.w	r3, #32
    77bc:	f3ef 8011 	mrs	r0, BASEPRI
    77c0:	f383 8811 	msr	BASEPRI, r3
    77c4:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
    77c8:	f7ff fe12 	bl	73f0 <z_reschedule_irqlock>
			z_reschedule_unlocked();
		}
	}
}
    77cc:	bd10      	pop	{r4, pc}

000077ce <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    77ce:	4770      	bx	lr

000077d0 <z_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
    77d0:	f7fc b9ee 	b.w	3bb0 <SystemInit>
